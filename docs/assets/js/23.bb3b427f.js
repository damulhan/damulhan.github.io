(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{306:function(e,t,a){"use strict";a.r(t);var n=a(14),o=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"clojure-distilled"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clojure-distilled"}},[e._v("#")]),e._v(" Clojure Distilled")]),e._v(" "),t("p",[e._v("The difficulty in learning Clojure does not stem from its syntax, which happens to be extremely simple, but from having to learn new methods for solving problems. As such, we'll focus on understanding the core concepts and how they can be combined to solve problems the functional way.")]),e._v(" "),t("p",[e._v("All the mainstream languages belong to the same family. Once you learn one of these languages there is very little effort involved in learning another. Generally, all you have to do is learn some syntax sugar and the useful functions in the standard library to become productive. There might be a new concept here and there, but most of your existing skills are easily transferable.")]),e._v(" "),t("p",[e._v("This is not the case with Clojure. Being a Lisp dialect, it comes from a different family of languages and requires learning new concepts in order to use effectively. There is no reason to be discouraged if the code appears hard to read at first. I assure you that the syntax is not inherently difficult to understand, and that with a bit of practice you might find it to be quite the opposite.")]),e._v(" "),t("p",[e._v("The goal of this guide is to provide an overview of the core concepts necessary to become productive with Clojure. Let's start by examining some of the key advantages of the functional style and why you would want to learn a functional language in the first place.")]),e._v(" "),t("h2",{attrs:{id:"immutable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#immutable"}},[e._v("#")]),e._v(" Immutable")]),e._v(" "),t("p",[e._v("Clojure is a functional language. This makes it extremely well positioned for writing large applications. As the application grows it's imperative to be able to reason about its constituent parts in isolation. Conversely, there is a lot of value in building code out of components that are testable and reusable by nature. Let's take a look at why the functional approach is such a good fit here.")]),e._v(" "),t("p",[e._v("Functional languages are ideal for writing large applications because they eschew global state and favor immutability as the default. Having immutable shared state allows us to safely reason about parts of the application in isolation. At first glance, the idea of using immutable data structures sounds unnecessarily restrictive. However, as we'll soon see, many of the benefits associated with the functional style stem directly from it.")]),e._v(" "),t("p",[e._v("Mutable data can either be passed around by value or by reference. The safe approach would be to pass the data by value as it guarantees that any changes to the data will remain in the local scope. Unfortunately, this approach is extremely inefficient, so most languages pass data by reference instead.")]),e._v(" "),t("p",[e._v("Passing data by reference is fast, but it makes the code difficult to reason about. In order to safely work with the data you have to know all the places where it might be referenced. The complexity grows with the size of the application. The more code has access to a piece of data the more proverbial balls you end up having to juggle in your head.")]),e._v(" "),t("p",[e._v("Immutable data structures provide us with an ingenious alternative to the above dilemma. Every time a change is made to the data structure a revision is created. We now have the same guarantees offered by naive copying of the data, but we only pay the price proportional to the size of the change.")]),e._v(" "),t("p",[e._v('Just like garbage collection frees us from having to manually track data allocation and deallocation, immutable data structures free us from having to manage data references by hand. From the user perspective we simply "copy" the data any time we make a change. The language will take care of figuring out what parts of it can be cleaned up when they\'re no longer used.')]),e._v(" "),t("p",[e._v("Having such data structures facilitates writing pure functions. A pure function is simply a function without side effects. These functions do not rely on any state outside their inputs and they do not modify any external state when they run. Given the same parameters, the function will always produce the same result, regardless of the global state of the application.")]),e._v(" "),t("p",[e._v("Such functions can be safely reasoned about in isolation because we can guarantee that they're only able to modify their local scope. They provide us with self-contained components that can be composed to create complex behaviors. This type of code is referred to as being referentially transparent.")]),e._v(" "),t("h2",{attrs:{id:"reusable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reusable"}},[e._v("#")]),e._v(" Reusable")]),e._v(" "),t("p",[e._v("Object-oriented languages use classes for composition. The data in each class is tightly coupled to the logic associated with it. Each class represents a specific domain and the methods written in it are not easily reusable outside that domain. When we wish to reuse the existing code we often have to resort to patterns such as adapters and wrappers.")]),e._v(" "),t("p",[e._v("The focus, in such a language, is primarily on modeling the state using classes. The data is seen as being incidental to the whole process. Functional programming brings data to the forefront and it encourages us to think about our problems in terms of data transformations.")]),e._v(" "),t("p",[e._v("In a functional language, the logic and the data are kept separate. Clojure provides a small set of common data structures such as lists, vectors, maps, and sets. All the functions in the language operate on the same data structures allowing us to combine them without any additional ceremony. With this approach the function becomes the core reusable component.")]),e._v(" "),t("p",[e._v("Each function represents a certain transformation that we wish to apply to our data. When we need to solve a problem we simply have to break it up into a sequence of transformations and map those to the appropriate functions. The functions capture how the tasks are accomplished, while their composition states what is being accomplished. Code that separates what is being done from how it is done is referred to as being declarative.")]),e._v(" "),t("p",[e._v("Let's take iteration as an example. With the imperative style we would write a loop and put the logic that's invoked during each step inside it. By contrast, the functional approach is to use an iterator function and pass the logic that we want to execute during the iteration as a parameter.")]),e._v(" "),t("p",[e._v("An iterator function can be written once and it encapsulates all the logic required for iteration, edge cases, and boundary checks. We can now reuse this function without having to worry about remembering to do these checks each time we need to iterate.")]),e._v(" "),t("h2",{attrs:{id:"scalable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scalable"}},[e._v("#")]),e._v(" Scalable")]),e._v(" "),t("p",[e._v("The focus on immutability makes it much easier to tackle the difficult problems of parallelism and concurrency. While there is no silver bullet for addressing either problem, the language can go a long way in helping us reason about them.")]),e._v(" "),t("p",[e._v("As you'll recall, pure functions rely solely on their arguments and do not modify any state outside their scope. These properties make it possible to safely run them in parallel allowing us to easily take advantage of the extra cores.")]),e._v(" "),t("p",[e._v("An example of this is mapping a function over the items in a collection. We can start by using the "),t("code",[e._v("map")]),e._v(" function. This function will iterate over a collection and apply a transformer function to each element inside it. Should we discover that each operation takes a significant amount of time, we can then simply switch to using the "),t("code",[e._v("pmap")]),e._v(" function to run these operations in parallel.")]),e._v(" "),t("p",[e._v("Finally, it turns out that the immutable data structures are also an excellent tool for managing shared mutable state. Clojure provides a Software Transactional Memory (STM) library based on these data structures. With transactional memory we no longer have to worry about manual locking when dealing with threads. Better still, shared state backed by immutable data only needs to be locked for writing since the current revision can be safely read while the new revision is being generated.")]),e._v(" "),t("h1",{attrs:{id:"clojure-in-action"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clojure-in-action"}},[e._v("#")]),e._v(" Clojure In Action")]),e._v(" "),t("p",[e._v("Now that we've discussed some of the reasons to start using the functional style, let's see how to apply these ideas in practice with Clojure.")]),e._v(" "),t("h2",{attrs:{id:"the-core"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-core"}},[e._v("#")]),e._v(" The Core")]),e._v(" "),t("h3",{attrs:{id:"data-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#data-types"}},[e._v("#")]),e._v(" Data Types")]),e._v(" "),t("p",[e._v("Clojure provides a number of standard data types, most of which should look familiar:")]),e._v(" "),t("ul",[t("li",[e._v("Vars provide mutable storage locations. These can be bound and rebound on a per-thread basis.")]),e._v(" "),t("li",[e._v("Booleans can have a value of true or false; nil values are also treated as false.")]),e._v(" "),t("li",[e._v("Numbers can be integers, doubles, floats, and fractions.")]),e._v(" "),t("li",[e._v("Symbols are used as identifiers for variables.")]),e._v(" "),t("li",[e._v("Keywords are symbols that reference themselves and are denoted by a colon; these are often used as keys in maps.")]),e._v(" "),t("li",[e._v("Strings are denoted by double quotes and can span multiple lines.")]),e._v(" "),t("li",[e._v("Characters are denoted by a preceding backslash.")]),e._v(" "),t("li",[e._v("Regular expressions are strings prefixed with a hash symbol.")])]),e._v(" "),t("p",[e._v("In addition to the data types, Clojure provides us with a literal notation for common collection types such as lists, vectors, maps, and sets:")]),e._v(" "),t("ul",[t("li",[e._v("List: "),t("code",[e._v("'(1 2 3)")])]),e._v(" "),t("li",[e._v("Vector: "),t("code",[e._v("[1 2 3]")])]),e._v(" "),t("li",[e._v("Map: "),t("code",[e._v('{:foo "a" :bar "b"}')])]),e._v(" "),t("li",[e._v("Set: "),t("code",[e._v('#{"a" "b" "c"}')])])]),e._v(" "),t("p",[e._v("Interestingly, Clojure logic is written using its data structures. Using the same syntax for both data and logic allows for powerful metaprogramming features. We can manipulate any piece of Clojure code just like we would any other data structure. This feature makes it trivial to template the code for recurring patterns in your problem domain. In Clojure, code is data and data is code.")]),e._v(" "),t("h3",{attrs:{id:"special-forms"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#special-forms"}},[e._v("#")]),e._v(" Special Forms")]),e._v(" "),t("p",[e._v("Special forms provide a small set of primitives, such as the "),t("code",[e._v("if")]),e._v(" conditional, that define the core syntax. These are akin to reserved keywords found in other languages. However, unlike most languages, Clojure uses a minimal amount of reserved syntax and majority of the language is implemented using functions and macros in the standard library.")]),e._v(" "),t("h2",{attrs:{id:"functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[e._v("#")]),e._v(" Functions")]),e._v(" "),t("p",[e._v("Function calls in Clojure work the same as any mainstream languages. The main difference being that the function name comes after the paren in the Clojure version.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("functionName(param1, param2)\n\n\n(function-name param1 param2)\n")])])]),t("p",[e._v("There is a very simple reason for this difference. The function call is simply a list containing the function name and its parameters. In Clojure, a list is a special type of data structure reserved for creating callable expressions. To create a list data structure we'd have to call the list function:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(list 1 2 3)\n")])])]),t("h3",{attrs:{id:"anonymous-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#anonymous-functions"}},[e._v("#")]),e._v(" Anonymous Functions")]),e._v(" "),t("p",[e._v("As the name implies, anonymous functions are simply functions that aren't bound to a name. Let's take a look at the following function that accepts a single argument and prints it:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(fn [arg] (println arg))\n")])])]),t("p",[e._v("The function is defined by using the "),t("code",[e._v("fn")]),e._v(" form followed by the vector containing its argument and the body. We could call the above function by setting it as a first item in a list and its argument as the second:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('((fn [arg] (println arg)) "hello")\n=>"hello"\n')])])]),t("p",[e._v("Clojure provides syntactic sugar for defining anonymous functions using the "),t("code",[e._v("#")]),e._v(" notation. With it we can rewrite our function more concisely as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("#(println %)\n")])])]),t("p",[e._v("Here, the "),t("code",[e._v("%")]),e._v(" symbol indicates an unnamed argument. Multiple arguments would each be followed by a number indicating its position as seen below:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("#(println %1 %2 %3)\n")])])]),t("p",[e._v("This type of function is useful when you need to perform a one-off computations that don't warrant defining a named function. They are commonly used in conjunction with the higher-order functions that we'll see in a moment.")]),e._v(" "),t("h3",{attrs:{id:"named-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#named-functions"}},[e._v("#")]),e._v(" Named Functions")]),e._v(" "),t("p",[e._v("Named functions are simply anonymous functions bound to a symbol used as an identifier. Clojure provides a special form called "),t("code",[e._v("def")]),e._v(" that's used for creating global variables. It accepts a name and the body to be assigned to it. We can create a named function using the "),t("code",[e._v("def")]),e._v(" form as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(def double\n  (fn [x] (* 2 x)))\n")])])]),t("p",[e._v("Since this is such a common operation, Clojure provides a form called "),t("code",[e._v("defn")]),e._v(" that does it for us:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(defn square [x]\n  (* x x))\n")])])]),t("p",[e._v("The "),t("code",[e._v("defn")]),e._v(" form behaves the same as the "),t("code",[e._v("fn")]),e._v(" form we saw above, except that its first argument is the name of the function. The body of the function can consist of multiple expressions:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn bmi [height weight]\n  (println "height:" height)\n  (println "weight:" weight)\n  (/ weight (* height height)))\n')])])]),t("p",[e._v("Here we define a function to calculate the BMI using the height and weight parameters. The body consists of two print statements and a call to divide the weight by the square of the height. All the expressions are evaluated from the inside out. In the last statement, "),t("code",[e._v("(* height height)")]),e._v(" is evaluated, then the weight is divided by the result and returned. In Clojure, mathematical operators, such as "),t("code",[e._v("/")]),e._v(" and "),t("code",[e._v("*")]),e._v(", are regular functions and so we call them using the prefix notation as we would with any other function.")]),e._v(" "),t("p",[e._v("Note that only the result from the last expression is returned from the function, the results of all the other expressions are discarded. Therefore, any intermediate expressions should strictly be used for side effects as is the case with the "),t("code",[e._v("println")]),e._v(" calls above.")]),e._v(" "),t("p",[e._v("One thing to note is that Clojure uses a single pass compiler. For this reason, the functions must be declared before they are used. In a case when we need to refer to a function before it's been declared, we must use the "),t("code",[e._v("declare")]),e._v(" macro in order to provide a forward declaration.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(declare down)\n\n(defn up [n]\n  (if (< n 10)\n    (down (+ 2 n)) n))\n\n(defn down [n]\n  (up (dec n)))\n")])])]),t("p",[e._v("A keen reader will have noticed that the code is structured as a tree. This tree is called the abstract syntax tree, or AST for short. By being able to see the AST directly, we can examine the relationships between pieces of logic visually.")]),e._v(" "),t("p",[e._v("Since we write our code in terms of data, there are fewer syntactic hints than in most languages. For example, there is no explicit return statement and the last expression of the function body is returned implicitly.")]),e._v(" "),t("p",[e._v("This might take a little getting used to if you're accustomed to seeing a lot of annotations in your code. To aid readability, functions are often kept short while indentation and spacing are used for grouping code visually.")]),e._v(" "),t("p",[e._v("In Clojure, there is no distinction between functions and variables. You can assign a function to a label, pass it as a parameter, or return a function from another function. Functions that can be treated as data are referred to as being first-class because they don't have any additional restrictions attached to them.")]),e._v(" "),t("h3",{attrs:{id:"higher-order-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#higher-order-functions"}},[e._v("#")]),e._v(" Higher-Order Functions")]),e._v(" "),t("p",[e._v("Functions that take other functions as parameters are called higher-order functions. One example of such a function is "),t("code",[e._v("map")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(map #(* % %) [1 2 3 4 5]) => (1 4 9 16 25)\n")])])]),t("p",[e._v("This function accepts two parameters where the first is an anonymous function that squares its argument and the second is a collection of numbers. The map function will visit each item in the collection and square it.")]),e._v(" "),t("p",[e._v("One major advantage of using a higher order function is that we can infer the intent of the code from the function being used. Let's contrast the above example to an imperative style loop:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(loop [[n & numbers] [1 2 3 4 5]\n       result []]\n  (let [result (conj result (* n n))]\n    (if numbers\n      (recur numbers result)\n      result)))\n")])])]),t("p",[e._v("The looping approach ends up having a lot more noise and thus we have to read through the code more carefully to tell what it's doing. The other problem is that the code becomes monolithic and no part of it can be used individually.")]),e._v(" "),t("p",[e._v("Another example of a higher-order function is "),t("code",[e._v("filter")]),e._v(". This function goes through a collection and keeps only the items matching the specified predicate.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(filter even? [1 2 3 4 5]) => (2 4)\n")])])]),t("p",[e._v("Higher order functions can be easily chained together to create complex transformations:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(filter even?\n  (map #(* 3 %) [1 2 3 4 5]))\n\n=>(6 12)\n")])])]),t("p",[e._v("Here we multiply each item by 3, then we use "),t("code",[e._v("filter")]),e._v(" to only keep the even items from the resulting sequence. Having higher-order functions means that you should rarely have to write loops or explicit recursion. When iterating a collection, use a function such as "),t("code",[e._v("map")]),e._v(" or "),t("code",[e._v("filter")]),e._v(" instead. Since Clojure has a rich standard library, practically any data transformation can be easily achieved by combining functions found there. See "),t("a",{attrs:{href:"https://github.com/mythz/clojure-linq-examples",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v(" for some examples of this approach in action.")]),e._v(" "),t("p",[e._v("Once you learn to associate data transformations with specific functions, many problems can be solved by simply putting these functions together in a specific order.")]),e._v(" "),t("p",[e._v("Let's take a look at using this idea for a simple real world problem. We'd like to display a formatted address given the fields representing it. Commonly an address has a unit number, a street, a city, a postal code, and a country. We'll have to examine each of these fields, remove the "),t("code",[e._v("nil")]),e._v(" and empty ones, and insert a separator between them. Given a table containing the following fields:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('unit      | street          | city      | postal_code | country\n""        | "1 Main street" | "Toronto" | nil         | "Canada"\n')])])]),t("p",[e._v("We would like to output the following formatted string using the strings in the table:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('"1 Main street, Toronto, Canada"\n')])])]),t("p",[e._v("All we have to do is find the functions for the tasks of removing empty fields, interposing the separator, and concatenating the result into a string:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn concat-fields [& fields]\n  (clojure.string/join ", " (remove empty? fields)))\n\n(concat-fields "" "1 Main street" "Toronto" nil "Canada")\n=> "1 Main street, Toronto, Canada"\n')])])]),t("p",[e._v("Notice that we didn't have to specify how to do any of the tasks when writing our code. Most of the time we simply say what we're doing by composing the functions representing the operations we wish to carry out. The resulting code also handles all the common edge cases:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(concat-fields) => ""\n(concat-fields nil) => ""\n(concat-fields "") => ""\n')])])]),t("p",[e._v("In Clojure, it's common for the code to work correctly for all inputs out of the box.")]),e._v(" "),t("h3",{attrs:{id:"closures"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#closures"}},[e._v("#")]),e._v(" Closures")]),e._v(" "),t("p",[e._v("We've now seen how we can declare functions, name them, and pass them as parameters to other functions. One last thing we can do is write functions that return other functions as their result. One use for such functions is to provide the functionality facilitated by constructors in object-oriented languages.")]),e._v(" "),t("p",[e._v("Let's say we wish to greet our guests with a warm greeting. We can write a function that will accept the greeting string as its parameter and return a function that takes the name of the guest and prints a customized greeting for that guest:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn greeting [greeting-string]\n  (fn [guest]\n    (println greeting-string guest)))\n\n(let [greet (greeting "Welcome to the wonderful world of Clojure")]\n  (greet "Jane")\n  (greet "John"))\n')])])]),t("p",[e._v("The inner function in the "),t("code",[e._v("greeting")]),e._v(" has access to the "),t("code",[e._v("greeting-string")]),e._v(" value since the value is defined in its outer scope. The "),t("code",[e._v("greeting")]),e._v(" function is called a closure because it closes over its parameters, in our case the "),t("code",[e._v("greeting-string")]),e._v(", and makes them available to the function that it returns.")]),e._v(" "),t("p",[e._v("You'll also notice that we're using a form called "),t("code",[e._v("let")]),e._v(" to bind the "),t("code",[e._v("greet")]),e._v(" symbol and make it available to any expressions inside it. The "),t("code",[e._v("let")]),e._v(" form serves the same purpose as declaring variables in imperative languages.")]),e._v(" "),t("h3",{attrs:{id:"threading-expressions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#threading-expressions"}},[e._v("#")]),e._v(" Threading Expressions")]),e._v(" "),t("p",[e._v("By this point you're probably noticing that nested expressions can get difficult to read. Fortunately, Clojure provides a couple of helper forms to deal with this problem. Let's say we have a range of numbers, and we want to increment each number, interpose the number 5 between them, then sum the result. We could write the following code to do that:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(reduce + (interpose 5 (map inc (range 10))))\n")])])]),t("p",[e._v("It's a little difficult to tell what's happening above at a glance. With a few more steps in the chain we'd be really lost. On top of that, if we wanted to rearrange any of the steps, such as interposing 5 before incrementing, then we'd have to renest all our expressions. An alternative way to write the above expression is to use the "),t("code",[e._v("->>")]),e._v(" form:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(->> (range 10) (map inc) (interpose 5) (reduce +))\n")])])]),t("p",[e._v("Here, we use "),t("code",[e._v("->>")]),e._v(" to thread the operations from one to the next. This means that we implicitly pass the result of each expression as the last argument of the next expression. To pass it as the first argument we'd use the "),t("code",[e._v("->")]),e._v(" form instead.")]),e._v(" "),t("h3",{attrs:{id:"laziness"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#laziness"}},[e._v("#")]),e._v(" Laziness")]),e._v(" "),t("p",[e._v("Many Clojure algorithms use lazy evaluation where the operations aren't performed unless their result actually needs to be evaluated. Laziness is crucial for making many algorithms work efficiently. For example, you might think the preceding example is very inefficient since we have to iterate our sequence each time to create the range, map across it, interpose the numbers, and reduce the result.")]),e._v(" "),t("p",[e._v("However, this is not actually the case. The evaluation of each expression happens on demand. The first value in the range is generated and passed to the rest of the functions, then the next, and so on, until the sequence is exhausted. This is a similar approach that languages like Python take with their iterator mechanics.")]),e._v(" "),t("h2",{attrs:{id:"code-structure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#code-structure"}},[e._v("#")]),e._v(" Code Structure")]),e._v(" "),t("p",[e._v("One nontrivial difference between Clojure and imperative languages is the way the code is structured. In imperative style, it's a common pattern to declare a shared mutable variable and modify it by passing it different functions. Each time we access the memory location we see the result of the code that previously worked with it. For example, if we have a list of integers and we wish to square each one then print the even ones, the following Python code would be perfectly valid:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("l = range(1, 6)\n\nfor i, val in enumerate(l) :\n  l[i] = val * val\n\nfor i in l :\n  if i % 2 == 0 :\n    print i\n")])])]),t("p",[e._v("In Clojure this interaction has to be made explicit. Instead of creating a shared memory location and then having different functions access it sequentially, we chain functions together and pipe the input through them:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(println\n  (filter #(= (mod % 2) 0)\n    (map #(* % %) (range 1 6))))\n")])])]),t("p",[e._v("We could also flatten out the steps using the "),t("code",[e._v("->>")]),e._v(" macro introduced earlier:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(->> (range 1 6)\n     (map #(* % %))\n     (filter #(= (mod % 2) 0))\n     (println))\n")])])]),t("p",[e._v("Each function returns a new value instead of modifying the existing data in place. You might think that this can get very expensive, and it would be with a naïve implementation where the entirety of the data is copied with every change.")]),e._v(" "),t("p",[e._v("In reality, Clojure is backed by persistent data structures that create in-memory revisions of the data. Each time a change is made a new revision is created proportional to the size of the change. With this approach we only pay the price of the difference between the old and the new structures while ensuring that any changes are localized.")]),e._v(" "),t("h3",{attrs:{id:"destructuring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#destructuring"}},[e._v("#")]),e._v(" Destructuring")]),e._v(" "),t("p",[e._v("Clojure has a powerful mechanism called destructuring for declaratively accessing values in data structures. This technique provides easy access to the data and serves to document the parameters to a function. Let's look at some examples to see how it works.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(let [[smaller bigger] (split-with #(< % 5) (range 10))]\n    (println smaller bigger))\n\n=>(0 1 2 3 4) (5 6 7 8 9)\n")])])]),t("p",[e._v("Above, we use "),t("code",[e._v("split-with")]),e._v(" function to split a range of ten numbers into a sequence containing two elements: numbers less than 5 and numbers greater than or equal to 5. Since we know the format of the result, we can write it in a literal form as "),t("code",[e._v("[smaller bigger]")]),e._v(" in the "),t("code",[e._v("let")]),e._v(" binding. Destructuring is not limited to the "),t("code",[e._v("let")]),e._v(" form and works for all types of bindings such as function arguments.")]),e._v(" "),t("p",[e._v("Let's look at another function called "),t("code",[e._v("print-user")]),e._v(" that accepts a vector with three elements and binds them to "),t("code",[e._v("name")]),e._v(", "),t("code",[e._v("address")]),e._v(", and "),t("code",[e._v("phone")]),e._v(", respectively:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn print-user [[name address phone]]\n  (println name "-" address phone))\n\n(print-user ["John" "397 King street, Toronto" "416-936-3218"])\n=> "John - 397 King street, Toronto 416-936-3218"\n')])])]),t("p",[e._v("We can also specify variable arguments as a sequence. This is done by using "),t("code",[e._v("&")]),e._v(" followed by the name of the list containing the remaining arguments:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn print-args [& args]\n  (println args))\n\n(print-args "a" "b" "c") => (a b c)\n')])])]),t("p",[e._v("Since the variable arguments are stored in a sequence, it can be destructured like any other:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn print-args [arg1 & [arg2]]\n  (println\n    (if arg2\n      "got two arguments"\n      "got one argument")))\n\n(print-args "bar")\n=>"got one argument"\n\n(print-args "bar" "baz")\n=>"got two arguments"\n')])])]),t("p",[e._v("Destructuring can also be applied to maps. When destructuring a map, we create a new map where we supply the names for the local bindings pointing to the keys from the original map:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(let [{foo :foo bar :bar} {:foo "foo" :bar "bar"}]\n  (println foo bar))\n')])])]),t("p",[e._v("It's also possible to destructure a nested data structure. As long as you know the structure of the data being passed in, you can simply write it out:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(let [{[a b c] :items id :id} {:id "foo" :items [1 2 3]}]\n  (println id "->" a b c))\n=> "foo -> 1 2 3"\n')])])]),t("p",[e._v("Finally, since extracting keys from maps is a very common operation, Clojure provides syntactic sugar for this task:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn login [{:keys [user pass]}]\n (and (= user "bob") (= pass "secret")))\n\n(login {:user "bob" :pass "secret"})\n')])])]),t("p",[e._v("Another useful destructuring option allows us to extract some keys while preserving the original map:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn register [{:keys [id pass repeat-pass] :as user}]\n  (cond\n    (nil? id) "user id is required"\n    (not= pass repeat-pass) "re-entered password doesn\'t match"\n    :else user))\n')])])]),t("h3",{attrs:{id:"namespaces"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#namespaces"}},[e._v("#")]),e._v(" Namespaces")]),e._v(" "),t("p",[e._v("When writing real-world applications we need tools to organize our code into separate components. Object-oriented languages provide classes for this purpose. The related methods will all be defined in the same class. In Clojure, we group our functions into namespaces instead. Let's look at how a namespace is defined.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns colors)\n\n(defn hex->rgb [[_ & rgb]]\n    (map #(->> % (apply str "0x") (Long/decode))\n         (partition 2 rgb)))\n\n(defn hex-str [n]\n  (-> (format "%2s" (Integer/toString n 16))\n      (clojure.string/replace " " "0")))\n\n(defn rgb->hex [color]\n  (apply str "#" (map hex-str color)))\n')])])]),t("p",[e._v("Above, we have a namespace called "),t("code",[e._v("colors")]),e._v(" containing three functions called "),t("code",[e._v("hex->rgb")]),e._v(", "),t("code",[e._v("hex-str")]),e._v(", and "),t("code",[e._v("rgb->hex")]),e._v(". The functions in the same namespace can call each other directly. However, if we wanted to call these functions from a different namespace we would have to reference the "),t("code",[e._v("colors")]),e._v(" namespace there first.")]),e._v(" "),t("p",[e._v("Clojure provides two ways to do this, we can either use the "),t("code",[e._v(":use")]),e._v(" or the "),t("code",[e._v(":require")]),e._v(" keywords. When we reference a namespace with "),t("code",[e._v(":use")]),e._v(", all its Vars become implicitly available as if they were defined in the namespace that references it.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns myns\n  (:use colors))\n\n(hex->rgb "#33d24f")\n')])])]),t("p",[e._v("There are two downsides to this approach. We don't know where the function was originally defined, making it difficult to navigate the code, and if we reference two namespaces that use the same name for a function, we'll get an error.")]),e._v(" "),t("p",[e._v("We can address the first problem by selecting the functions we wish to use explicitly using the "),t("code",[e._v(":only")]),e._v(" keyword in our "),t("code",[e._v(":use")]),e._v(" declaration.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns myns\n  (:use [colors :only [rgb->hex]]))\n\n(defn hex-str [c]\n  (println "I don\'t do much yet"))\n')])])]),t("p",[e._v("This way we document where "),t("code",[e._v("rgb->hex")]),e._v(" comes from, and we're able to declare our own "),t("code",[e._v("hex-str")]),e._v(" function in the "),t("code",[e._v("myns")]),e._v(" namespace without conflicts. Note that "),t("code",[e._v("rgb->hex")]),e._v(" will still use the "),t("code",[e._v("hex-str")]),e._v(" function defined in the "),t("code",[e._v("colors")]),e._v(" namespace.")]),e._v(" "),t("p",[e._v("The approach of using the "),t("code",[e._v(":require")]),e._v(" keyword to reference the namespace provides us with more flexible options. Let's look at each of these.")]),e._v(" "),t("p",[e._v("We can require a namespace without providing any further directives. In this case, any calls to Vars inside it must be prefixed with the namespace declaration indicating their origin.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns myns (:require colors))\n\n(colors/hex->rgb "#324a9b")\n')])])]),t("p",[e._v("This approach is explicit about the origin of the Vars being referenced and ensures that we won't have conflicts when referencing multiple namespaces. One problem is that when our namespace declaration is long, it gets tedious to have to type it out any time we wish to use a function declared inside it. To address this problem, the "),t("code",[e._v(":require")]),e._v(" statement provides the "),t("code",[e._v(":as")]),e._v(" directive, allowing us to create an alias for the namespace.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns myotherns\n  (:require [colors :as c]))\n\n(c/hex->rgb "#324a9b")\n')])])]),t("p",[e._v("We can also require functions from a namespace by using the "),t("code",[e._v(":refer")]),e._v(" keyword. This is synonymous with the "),t("code",[e._v(":use")]),e._v(" notation we saw earlier. To require all the functions from another namespace, we can write the following:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(ns myns\n  (:require [colors :refer :all]))\n")])])]),t("p",[e._v("If we wish to select what functions to require by name, we can instead write:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(ns myns\n  (:require [colors :refer [rgb->hex]))\n")])])]),t("p",[e._v("As you can see, there's a number of options available for referencing Vars declared in other namespaces. If you're not sure what option to pick, then requiring the namespace by name or alias is the safest route.")]),e._v(" "),t("h3",{attrs:{id:"dynamic-variables"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-variables"}},[e._v("#")]),e._v(" Dynamic Variables")]),e._v(" "),t("p",[e._v("Clojure provides support for declaring dynamic variables that can have their value changed within a particular scope. Let's look at how this works.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(declare ^{:dynamic true} *foo*)\n\n(println *foo*)\n=>#<Unbound Unbound: #'bar/*foo*>\n")])])]),t("p",[e._v("Here we declared "),t("code",[e._v("*foo*")]),e._v(" as a dynamic Var and didn't provide any value for it. When we try to print "),t("code",[e._v("*foo*")]),e._v(" we get an error indicating that this Var has not been bound to any value. Let's look at how we can assign a value to "),t("code",[e._v("*foo*")]),e._v(" using a binding.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn with-foo [f]\n  (binding [*foo* "I exist!"]\n    (f)))\n\n(with-foo #(println *foo*)) =>"I exist!"\n')])])]),t("p",[e._v("We set "),t("code",[e._v("*foo*")]),e._v(' to a string with value "I exist!" inside the '),t("code",[e._v("with-foo")]),e._v(" function. When our anonymous function is called inside with-foo we no longer get an error when trying to print its value.")]),e._v(" "),t("p",[e._v("This technique can be useful when dealing with resources such as file streams, database connections, or scoped variables. In general, the use of dynamic variables is discouraged since they make code more opaque and difficult to reason about. However, there are legitimate uses for them, and it's worth knowing how they work.")]),e._v(" "),t("h2",{attrs:{id:"polymorphism"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#polymorphism"}},[e._v("#")]),e._v(" Polymorphism")]),e._v(" "),t("p",[e._v("One useful aspect of object-orientation is polymorphism, while it happens to be associated with that style it's in no way exclusive to it. Clojure provides two common ways to achieve runtime polymorphism. Let's look at each of these in turn.")]),e._v(" "),t("h3",{attrs:{id:"multimethods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#multimethods"}},[e._v("#")]),e._v(" Multimethods")]),e._v(" "),t("p",[e._v("Multimethods provide an extremely flexible dispatching mechanism using a selector function associated with one or more methods. The multimethod is defined using "),t("code",[e._v("defmulti")]),e._v(" and its methods are each defined using "),t("code",[e._v("defmethod")]),e._v(". For example, if we had different shapes and we wanted to write a multimethod to calculate the area we could do the following:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defmulti area :shape)\n\n(defmethod area :circle [{:keys [r]}]\n  (* Math/PI r r))\n\n(defmethod area :rectangle [{:keys [l w]}]\n  (* l w))\n\n(defmethod area :default [shape]\n  (throw (Exception. (str "unrecognized shape: " shape))))\n\n(area {:shape :circle :r 10})\n=> 314.1592653589793\n\n(area {:shape :rectangle :l 5 :w 10})\n=> 50\n')])])]),t("p",[e._v("Above, the dispatch function uses a keyword to select the appropriate method to handle each type of map. This works because keywords act as functions and when passed a map will return the value associated with them. The dispatch function can be as sophisticated as we like however:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(defmulti encounter\n  (fn [x y] [(:role x) (:role y)]))\n\n(defmethod encounter [:manager :boss] [x y]\n  :promise-unrealistic-deadlines)\n\n(defmethod encounter [:manager :developer] [x y]\n  :demand-overtime)\n\n(defmethod encounter [:developer :developer] [x y]\n  :complain-about-poor-management)\n\n(encounter {:role :manager} {:role :boss})\n=> :promise-unrealistic-deadlines\n")])])]),t("h3",{attrs:{id:"protocols"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#protocols"}},[e._v("#")]),e._v(" Protocols")]),e._v(" "),t("p",[e._v("Protocols allow defining an abstract set of functions that can be implemented by a concrete type. Let's look at an example protocol:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defprotocol Foo\n  "Foo doc string"\n  (bar [this b] "bar doc string")\n  (baz [this] [this b] "baz doc string"))\n')])])]),t("p",[e._v("As you can see, the "),t("code",[e._v("Foo")]),e._v(" protocol specifies two methods, "),t("code",[e._v("bar")]),e._v(" and "),t("code",[e._v("baz")]),e._v(". The first argument to the method will be the type instance followed by its parameters. Note that the "),t("code",[e._v("baz")]),e._v(" method has multiple arity. We can now create a type that implements the Foo protocol using the deftype macro:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(deftype Bar [data] Foo\n  (bar [this param]\n    (println data param))\n  (baz [this]\n    (println (class this)))\n  (baz [this param]\n    (println param)))\n")])])]),t("p",[e._v("Here we create type "),t("code",[e._v("Bar")]),e._v(" that implements protocol "),t("code",[e._v("Foo")]),e._v(". Each of its methods will print out some of the parameters passed to it. Let's see what it looks like when we create an instance of "),t("code",[e._v("Bar")]),e._v(" and call its methods:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(let [b (Bar. "some data")]\n  (.bar b "param")\n  (.baz b)\n  (.baz b "baz with param"))\n\n\nsome data param\nBar\nbaz with param\n')])])]),t("p",[e._v("The first method call prints out the data "),t("code",[e._v("Bar")]),e._v(" was initialized with and the parameter that was passed in. The second method call prints out the object's class, while the last method call demonstrates the other arity of baz.")]),e._v(" "),t("p",[e._v("We can also use protocols to extend the functionality of existing types, including existing Java classes. For example, we can use extend-protocol to extend the "),t("code",[e._v("java.lang.String")]),e._v(" class with the "),t("code",[e._v("Foo")]),e._v(" protocol:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(extend-protocol Foo String\n  (bar [this param] (println this param)))\n\n(bar "hello" "world")\n=>"hello world"\n')])])]),t("p",[e._v("The above examples illustrate the basic principles of how protocols can be used to write polymorphic code. However, there are many other uses for protocols as well and I encourage you to discover these on your own.")]),e._v(" "),t("h2",{attrs:{id:"dealing-with-global-state"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dealing-with-global-state"}},[e._v("#")]),e._v(" Dealing With Global State")]),e._v(" "),t("p",[e._v("While predominantly immutable, Clojure provides support for shared mutable data via its STM functions in the standard library. The STM is used to ensure that all updates to shared mutable variables are done atomically.")]),e._v(" "),t("p",[e._v("There are two primary mutable types: the "),t("code",[e._v("atom")]),e._v(" and the "),t("code",[e._v("ref")]),e._v(". The "),t("code",[e._v("atom")]),e._v(" is used in cases where we need to do uncoordinated updates and the "),t("code",[e._v("ref")]),e._v(" is used when we might need to do multiple updates as a transaction. Let's look at an example of defining an "),t("code",[e._v("atom")]),e._v(" and using it.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(def global-val (atom nil))\n")])])]),t("p",[e._v("Above, we created an "),t("code",[e._v("atom")]),e._v(" called "),t("code",[e._v("global-val")]),e._v(" and its current value is "),t("code",[e._v("nil")]),e._v(". We can now read its value by using the "),t("code",[e._v("deref")]),e._v(" function, which returns the current value.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(println (deref global-val)) => nil\n")])])]),t("p",[e._v("Since this is a common operation, there is a shorthand for "),t("code",[e._v("deref")]),e._v(": the "),t("code",[e._v("@")]),e._v(" symbol:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(println @global-val)\n")])])]),t("p",[e._v("The above code is equivalent to the preceding example.")]),e._v(" "),t("p",[e._v("Let's look at two ways of setting a new value for our "),t("code",[e._v("atom")]),e._v(". We can either use "),t("code",[e._v("reset!")]),e._v(" and pass in the new value, or we can use "),t("code",[e._v("swap!")]),e._v(" and pass in a function that will be used to update the current value.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(reset! global-val 10) (println @global-val) =>10\n\n(swap! global-val inc) (println @global-val) =>11\n")])])]),t("p",[e._v("￼￼ Note that both "),t("code",[e._v("swap!")]),e._v(" and "),t("code",[e._v("reset!")]),e._v(" end in an exclamation point "),t("code",[e._v("!")]),e._v("; this is a convention to indicate that these functions modify mutable data.")]),e._v(" "),t("p",[e._v("We define refs the same way we define atoms, but the two are used rather differently. Let's take a quick look at how they work below.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(def names (ref []))\n\n(dosync\n  (ref-set names ["John"])\n  (alter names #(if (not-empty %)\n                  (conj % "Jane") %)))\n')])])]),t("p",[e._v("In this code, we define a "),t("code",[e._v("ref")]),e._v(" called "),t("code",[e._v("names")]),e._v(", then open a transaction using the "),t("code",[e._v("dosync")]),e._v(" statement. Inside the transaction we set "),t("code",[e._v("names")]),e._v(" to a vector with the value "),t("code",[e._v('"John"')]),e._v(". Next, we call "),t("code",[e._v("alter")]),e._v(" to check if "),t("code",[e._v("names")]),e._v(" is not empty and add "),t("code",[e._v('"Jane"')]),e._v(" to the vector of the names if that's the case.")]),e._v(" "),t("p",[e._v("Note that since this is happening inside a transaction, the check for emptiness depends on the existing state along with any state built up within the same transaction. If we tried to add or remove a name in a different transaction, it would have no visible effect on ours. In case of a collision, one of the transactions would end up being retried.")]),e._v(" "),t("h2",{attrs:{id:"writing-code-that-writes-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#writing-code-that-writes-code"}},[e._v("#")]),e._v(" Writing Code That Writes Code")]),e._v(" "),t("p",[e._v("Clojure, being a Lisp, provides a powerful macro system. Macros allow templating repetitive blocks of code and deferring evaluation, among numerous other uses. A macro works by treating code as data instead of evaluating it. This allows us to manipulate the code tree just like any other data structure.")]),e._v(" "),t("p",[e._v("Macros execute before evaluation time and the evaluator sees the result of macro execution. Because of this level of indirection, macros can be difficult to reason about, and thus it's best not to use them when a function will do the job.")]),e._v(" "),t("p",[e._v("Let's look at a concrete example of a macro and see how it differs from the regular code we saw previously. Imagine that we have a web application with a session atom that might contain a user. We might want to load certain content only if a user is present in the session and not otherwise.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(def session (atom {:user "Bob"}))\n\n(defn load-content []\n  (if (:user @session)\n    "Welcome back!"\n    "please log in"))\n')])])]),t("p",[e._v("This will work, but it's tedious and error-prone to write out the "),t("code",[e._v("if")]),e._v(" statement every single time. Since our condition's logic stays the same, we can template this function as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defmacro defprivate [name args & body]\n  `(defn ~(symbol name) ~args\n     (if (:user @session)\n       (do ~@body)\n       "please log in")))\n')])])]),t("p",[e._v("The macros are defined using the "),t("code",[e._v("defmacro")]),e._v(" special form. The major difference between "),t("code",[e._v("defn")]),e._v(" and "),t("code",[e._v("defmacro")]),e._v(" is that the parameters passed to "),t("code",[e._v("defmacro")]),e._v(" are not evaluated by default.")]),e._v(" "),t("p",[e._v("To evaluate the parameter we use the "),t("code",[e._v("~")]),e._v(", as we're doing with "),t("code",[e._v("~(symbol name)")]),e._v(". Using the "),t("code",[e._v("~")]),e._v(" notation indicates that we'd like to replace the name with the value it refers to. This is called unquoting.")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("~@")]),e._v(" notation used in "),t("code",[e._v("(do ~@body)")]),e._v(" is called unquote splicing. This notation is used when we're dealing with a sequence. The contents of the sequence will be merged into the outer form during the splicing. In this case the body consists of a list representing the function's body. The body must be wrapped in a "),t("code",[e._v("do")]),e._v(" block because the "),t("code",[e._v("if")]),e._v(" statement requires having no more than three arguments.")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("`")]),e._v(" sign means that we wish to treat the following list as data instead of executing it. This is the opposite of unquoting, and it's referred to as syntax-quoting.")]),e._v(" "),t("p",[e._v("As I mentioned earlier, the macros are executed before evaluation time. To see what the macro will be rewritten as when the evaluator sees it, we can call "),t("code",[e._v("macroexpand-1")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(macroexpand-1 \'(defprivate foo [greeting] (println greeting)))\n\n(clojure.core/defn foo [greeting]\n  (if (:user (clojure.core/deref session))\n    (do (println greeting))\n    "please log in"))\n')])])]),t("p",[e._v("We can see that "),t("code",[e._v('(defprivate foo (println "bar"))')]),e._v(" gets rewritten with a function definition that has the "),t("code",[e._v("if")]),e._v(" statement inside. This resulting code is what the evaluator will see, and it's equivalent to what we would have to write by hand otherwise. Now we can simply define a private function using our macro, and it will do the check for us automatically.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defprivate foo [message] (println message))\n\n(foo "this message is private")\n')])])]),t("p",[e._v("The preceding example might seem a little contrived, but it demonstrates the power of being able to easily template repetitions in code. This allows creating a notation that expresses your problem domain using the language that is natural to it.")]),e._v(" "),t("h2",{attrs:{id:"the-read-evaluate-print-loop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-read-evaluate-print-loop"}},[e._v("#")]),e._v(" The Read-Evaluate-Print Loop")]),e._v(" "),t("p",[e._v("Another big aspect of working in Clojure is the read-evaluate-print loop (REPL). In many languages you write the code, then run the entire program to see what it does. In Clojure, most development is done interactively using the REPL. In this mode we can see each piece of code we write in action as soon as it's written.")]),e._v(" "),t("p",[e._v("In nontrivial applications it's often necessary to build up a particular state before you can add more functionality. For example, a user has to log in and query some data from the database, then you need to write functions to format and display this data. With a REPL you can get the application to the state where the data is loaded and then write the display logic interactively without having to reload the application and build up the state every time you make a change.")]),e._v(" "),t("p",[e._v("This method of development is particularly satisfying because you see immediate feedback when making changes. You can easily try things out and see what approach works best for the problem you're solving. This encourages experimentation and refactoring code as you go, which in turn helps you to write better and cleaner code.")]),e._v(" "),t("h2",{attrs:{id:"calling-out-to-java"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#calling-out-to-java"}},[e._v("#")]),e._v(" Calling Out to Java")]),e._v(" "),t("p",[e._v("One last thing that we'll cover is how Clojure embraces its host platform to benefit from the rich ecosystem of existing Java libraries. In some cases we may wish to call a Java library to accomplish a particular task that doesn't have a native Clojure implementation. Calling Java classes is very simple, and follows the standard Clojure syntax fairly closely.")]),e._v(" "),t("h3",{attrs:{id:"importing-classes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#importing-classes"}},[e._v("#")]),e._v(" Importing Classes")]),e._v(" "),t("p",[e._v("When we wish to use a Clojure namespace, we employ either the "),t("code",[e._v(":use")]),e._v(" or the "),t("code",[e._v(":require")]),e._v(" statements discussed above. However, when we wish to import a Java class, we have to use the "),t("code",[e._v(":import")]),e._v(" statement instead:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(ns myns\n  (:import java.io.File))\n")])])]),t("p",[e._v("We can also group multiple classes from the same package in a single import, as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(ns myns\n  (:import [java.io File FileInputStream FileOutputStream]))\n")])])]),t("h3",{attrs:{id:"instantiating-classes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#instantiating-classes"}},[e._v("#")]),e._v(" Instantiating Classes")]),e._v(" "),t("p",[e._v("To create an instance of a class, we can call new just as we would in Java:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(new File ".")\n')])])]),t("p",[e._v("There is also a commonly used shorthand for instantiating objects:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(File. ".")\n')])])]),t("h3",{attrs:{id:"calling-methods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#calling-methods"}},[e._v("#")]),e._v(" Calling Methods")]),e._v(" "),t("p",[e._v("Once we have an instance of a class, we can start calling methods on it. The notation is similar to making a regular function call. When we call a method, we pass the object as its first parameter followed by any other parameters that the method accepts.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(let [f (File. ".")]\n  (println (.getAbsolutePath f)))\n')])])]),t("p",[e._v("Above, we created a new file object "),t("code",[e._v("f")]),e._v(", and then called the "),t("code",[e._v(".getAbsolutePath")]),e._v(" method on it. Notice that methods have a period "),t("code",[e._v(".")]),e._v(" in front of them to differentiate them from a regular Clojure function. If we wanted to reference a static method or a variable in a class, we would use the "),t("code",[e._v("/")]),e._v(" notation instead:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(str File/separator "foo" File/separator "bar")\n\n(Math/sqrt 256)\n')])])]),t("p",[e._v("There's also a shorthand for chaining multiple method calls together using the "),t("code",[e._v("..")]),e._v(" notation. Say we wanted to get the string indicating the file path and then get its bytes; we could write the code for that in two ways.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(.getBytes (.getAbsolutePath (File. ".")))\n\n(.. (File. ".") getAbsolutePath getBytes)\n')])])]),t("h2",{attrs:{id:"further-reading"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#further-reading"}},[e._v("#")]),e._v(" Further Reading")]),e._v(" "),t("p",[e._v("This concludes our tour of Clojure basics. While we only touched on only a small portion of the overall language, I hope that the guide has provided you with a bit of insight into how idiomatic Clojure code is written. Below are some useful links for more in-depth documentation about the language.")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://clojure.org/guides/getting_started",target:"_blank",rel:"noopener noreferrer"}},[e._v("Official Clojure documentation"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://www.braveclojure.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure for the Brave and True"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://aphyr.com/posts/301-clojure-from-the-ground-up-welcome",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure from the ground up"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://clojure-doc.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Community Clojure documentation site"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://grimoire.arrdem.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure API documentation"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://clojure.org/cheatsheet",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure cheatsheet"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/bbatsov/clojure-style-guide",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure style guide"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("Copyright © 2023 Dmitri Sotnikov")])])}),[],!1,null,null,null);t.default=o.exports}}]);