(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{281:function(t,e,a){t.exports=a.p+"assets/img/list.5da5bf8a.jpg"},282:function(t,e,a){t.exports=a.p+"assets/img/frame.7f99d2e7.jpg"},681:function(t,e,a){"use strict";a.r(e);var s=a(14),o=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"문법과-의미-syntax-and-meaning"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#문법과-의미-syntax-and-meaning"}},[t._v("#")]),t._v(" 문법과 의미 (Syntax and meaning)")]),t._v(" "),e("p",[t._v("Every computer language has code that is made up of syntax and semantics. The syntax of a programming language is the basic skeleton your program has to follow so that the compiler knows what's what in your program, so it can tell what's a function, a variable, etc. The semantics of a program is the more \"random\" stuff, like the different commands you have available and what variables you're allowed to look at at any point in the program. The first thing that is special about Lisp is that it has the simplest syntax of any major programming language.")]),t._v(" "),e("p",[t._v("모든 컴퓨터 언어에는 "),e("em",[t._v("문법(syntax)")]),t._v(" 과 "),e("em",[t._v("의미(semantics)")]),t._v(" 로 구성된 코드가 있습니다. 프로그래밍 언어의 "),e("em",[t._v("문법")]),t._v(" 은 프로그램이 따라야 할 기본 골격으로, 컴파일러는 프로그램의 "),e("em",[t._v("무엇이 무엇임")]),t._v(" 을 알고 있으므로, 무엇이 함수이고 변수인지 등을 알 수 있습니다. 프로그램의 "),e("em",[t._v("의미")]),t._v(' 는 좀 더 "무작위"으로, 사용 가능한 다른 명령이 있는 것과 프로그램의 어떤 시점에서 볼 수 있는 변수와 같은 것들입니다. Lisp의 특별한 점은 주요 프로그래밍 언어 중 가장 간단한 구문을 가지고 있다는 것입니다.')]),t._v(" "),e("p",[t._v("Basically, the Lisp syntax dictates that any text you give the Lisp compiler has to be arranged into lists, which can be nested into lists of lists or such as needed. The parenthesis mark the beginning and end of each list:")]),t._v(" "),e("p",[t._v("기본적으로 Lisp 구문은 Lisp 컴파일러에 제공하는 모든 텍스트가 목록으로 정렬되어야 하며, 목록의 목록에 중첩되거나 필요에 따라 정렬 될 수 있도록 지시합니다. 괄호는 각 목록의 시작과 끝을 표시합니다.")]),t._v(" "),e("p",[e("img",{attrs:{src:a(281),alt:"리스프 목록"}})]),t._v(" "),e("p",[t._v("Additionally, the Lisp compiler uses two modes when it reads your code: A Code Mode and a Data Mode. When you're in Data Mode, you can put anything you want into your lists. However, the compiler first starts off reading your code in Code Mode - In Code Mode, your lists need to be a special type of list called a form:")]),t._v(" "),e("p",[t._v("또한 Lisp 컴파일러는 코드를 읽을 때 "),e("strong",[t._v("코드 모드")]),t._v("와 "),e("strong",[t._v("데이터 모드")]),t._v("의 두 가지 모드를 사용합니다. "),e("strong",[t._v("데이터 모드")]),t._v("에 있을 때 원하는 것을 목록에 넣을 수 있습니다. 그런데 컴파일러는 먼저 "),e("strong",[t._v("코드 모드")]),t._v("에서 "),e("strong",[t._v("코드")]),t._v("를 읽기 시작합니다. "),e("strong",[t._v("코드 모드")]),t._v("에서는 목록이 **양식(Form)**이라는 특수한 유형의 목록이어야 합니다.")]),t._v(" "),e("p",[e("img",{attrs:{src:a(282),alt:"리스프 양식"}})]),t._v(" "),e("p",[t._v("A form is a list where the first symbol in the list has to be a special word that the compiler can understand - usually the name of a function. In this case, the compiler will send the other items of the list to the function as parameters. When it reads the text for these parameters, it will usually assume that they are also in Code Mode, unless you tell it to flip into Data Mode.")]),t._v(" "),e("p",[t._v("양식은 목록의 첫 번째 기호가 컴파일러가 이해할 수 있는 특수 단어(일반적으로 함수 이름)이여야 하는 목록입니다. 이 경우 컴파일러는 목록의 다른 항목을 매개 변수로 함수에 보냅니다. 이 매개 변수에 대한 텍스트를 읽을 때 "),e("strong",[t._v("데이터 모드")]),t._v("로 전환하도록 지시하지 않는 한 일반적으로 해당 매개 변수도 "),e("em",[t._v("또한")]),t._v(" "),e("strong",[t._v("코드 모드")]),t._v("에 있다고 가정합니다.")])])}),[],!1,null,null,null);e.default=o.exports}}]);