(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{391:function(e,t,a){"use strict";a.r(t);var o=a(14),n=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"클로저-인-액션-clojure-in-action"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#클로저-인-액션-clojure-in-action"}},[e._v("#")]),e._v(" 클로저 인 액션(Clojure In Action)")]),e._v(" "),t("p",[e._v("함수형 스타일을 사용해야 하는 몇 가지 이유에 대해 살펴봤으니 이제 이러한 아이디어를 실제로 클로저에 적용하는 방법을 살펴봅시다.")]),e._v(" "),t("p",[e._v("Now that we've discussed some of the reasons to start using the functional style, let's see how to apply these ideas in practice with Clojure.")]),e._v(" "),t("h2",{attrs:{id:"핵심-the-core"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#핵심-the-core"}},[e._v("#")]),e._v(" 핵심(The Core)")]),e._v(" "),t("h3",{attrs:{id:"데이터-타입-data-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#데이터-타입-data-types"}},[e._v("#")]),e._v(" 데이터 타입(Data Types)")]),e._v(" "),t("p",[e._v("클로저는 여러 가지 표준 데이터 유형을 제공하며, 대부분은 익숙하게 보일 것입니다:")]),e._v(" "),t("p",[e._v("Clojure provides a number of standard data types, most of which should look familiar:")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("변수는 변경 가능한 저장 위치를 제공합니다. 스레드 단위로 바인딩 및 리바운드할 수 있습니다.")])]),e._v(" "),t("li",[t("p",[e._v("부울은 참 또는 거짓 값을 가질 수 있으며, nil 값도 거짓으로 취급됩니다.")])]),e._v(" "),t("li",[t("p",[e._v("숫자는 정수, 복소수, 부동 소수점, 분수일 수 있습니다.")])]),e._v(" "),t("li",[t("p",[e._v("기호는 변수의 식별자로 사용됩니다.")])]),e._v(" "),t("li",[t("p",[e._v("키워드는 자신을 참조하는 기호로 콜론으로 표시되며 맵에서 키로 사용되는 경우가 많습니다.")])]),e._v(" "),t("li",[t("p",[e._v("문자열은 큰따옴표로 표시되며 여러 줄에 걸쳐 있을 수 있습니다.")])]),e._v(" "),t("li",[t("p",[e._v("문자는 앞에 백슬래시로 표시됩니다.")])]),e._v(" "),t("li",[t("p",[e._v("정규식은 해시 기호가 앞에 붙은 문자열입니다.")])]),e._v(" "),t("li",[t("p",[e._v("Vars provide mutable storage locations. These can be bound and rebound on a per-thread basis.")])]),e._v(" "),t("li",[t("p",[e._v("Booleans can have a value of true or false; nil values are also treated as false.")])]),e._v(" "),t("li",[t("p",[e._v("Numbers can be integers, doubles, floats, and fractions.")])]),e._v(" "),t("li",[t("p",[e._v("Symbols are used as identifiers for variables.")])]),e._v(" "),t("li",[t("p",[e._v("Keywords are symbols that reference themselves and are denoted by a colon; these are often used as keys in maps.")])]),e._v(" "),t("li",[t("p",[e._v("Strings are denoted by double quotes and can span multiple lines.")])]),e._v(" "),t("li",[t("p",[e._v("Characters are denoted by a preceding backslash.")])]),e._v(" "),t("li",[t("p",[e._v("Regular expressions are strings prefixed with a hash symbol.")])])]),e._v(" "),t("p",[e._v("데이터 유형 외에도 목록, 벡터, 맵, 집합과 같은 일반적인 컬렉션 유형에 대한 리터럴 표기법을 Clojure에서 제공합니다:")]),e._v(" "),t("p",[e._v("In addition to the data types, Clojure provides us with a literal notation for common collection types such as lists, vectors, maps, and sets:")]),e._v(" "),t("ul",[t("li",[e._v("리스트(List): "),t("code",[e._v("'(1 2 3)")])]),e._v(" "),t("li",[e._v("벡터(Vector): "),t("code",[e._v("[1 2 3]")])]),e._v(" "),t("li",[e._v("맵(Map): "),t("code",[e._v('{:foo "a" :bar "b"}')])]),e._v(" "),t("li",[e._v("집합(Set): "),t("code",[e._v('#{"a" "b" "c"}')])])]),e._v(" "),t("p",[e._v("흥미롭게도 클로저 로직은 데이터 구조를 사용하여 작성됩니다. 데이터와 로직 모두에 동일한 구문을 사용하면 강력한 메타프로그래밍 기능을 사용할 수 있습니다. 다른 데이터 구조와 마찬가지로 Clojure 코드의 모든 부분을 조작할 수 있습니다. 이 기능을 사용하면 문제 도메인에서 반복되는 패턴에 대한 코드를 템플릿으로 쉽게 만들 수 있습니다. Clojure에서는 코드가 곧 데이터이고 데이터가 곧 코드입니다.")]),e._v(" "),t("p",[e._v("Interestingly, Clojure logic is written using its data structures. Using the same syntax for both data and logic allows for powerful metaprogramming features. We can manipulate any piece of Clojure code just like we would any other data structure. This feature makes it trivial to template the code for recurring patterns in your problem domain. In Clojure, code is data and data is code.")]),e._v(" "),t("h3",{attrs:{id:"특별한-양식-special-forms"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#특별한-양식-special-forms"}},[e._v("#")]),e._v(" 특별한 양식(Special Forms)")]),e._v(" "),t("p",[e._v("특수 형식은 핵심 구문을 정의하는 if 조건문과 같은 작은 기본 요소 집합을 제공합니다. 이는 다른 언어에서 볼 수 있는 예약 키워드와 유사합니다. 그러나 대부분의 언어와 달리 클로저는 최소한의 예약 구문을 사용하며 언어의 대부분은 표준 라이브러리의 함수와 매크로를 사용하여 구현됩니다.")]),e._v(" "),t("p",[e._v("Special forms provide a small set of primitives, such as the "),t("code",[e._v("if")]),e._v(" conditional, that define the core syntax. These are akin to reserved keywords found in other languages. However, unlike most languages, Clojure uses a minimal amount of reserved syntax and majority of the language is implemented using functions and macros in the standard library.")]),e._v(" "),t("h2",{attrs:{id:"함수-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#함수-functions"}},[e._v("#")]),e._v(" 함수(Functions)")]),e._v(" "),t("p",[e._v("클로저의 함수 호출은 다른 주류 언어와 동일하게 작동합니다. 가장 큰 차이점은 클로저 버전에서는 함수 이름이 부모 뒤에 온다는 점입니다.")]),e._v(" "),t("p",[e._v("Function calls in Clojure work the same as any mainstream languages. The main difference being that the function name comes after the paren in the Clojure version.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("functionName(param1, param2)\n\n\n(function-name param1 param2)\n")])])]),t("p",[e._v("이 차이에는 아주 간단한 이유가 있습니다. 함수 호출은 단순히 함수 이름과 해당 매개변수가 포함된 목록입니다. 클로저에서 목록은 호출 가능한 표현식을 만들기 위해 예약된 특수한 유형의 데이터 구조입니다. 목록 데이터 구조를 만들려면 목록 함수를 호출해야 합니다:")]),e._v(" "),t("p",[e._v("There is a very simple reason for this difference. The function call is simply a list containing the function name and its parameters. In Clojure, a list is a special type of data structure reserved for creating callable expressions. To create a list data structure we'd have to call the list function:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(list 1 2 3)\n")])])]),t("h3",{attrs:{id:"익명-함수-anonymous-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#익명-함수-anonymous-functions"}},[e._v("#")]),e._v(" 익명 함수 Anonymous Functions")]),e._v(" "),t("p",[e._v("이름에서 알 수 있듯이 익명 함수는 단순히 이름에 바인딩되지 않은 함수입니다. 단일 인수를 받아 출력하는 다음 함수를 살펴보겠습니다:")]),e._v(" "),t("p",[e._v("As the name implies, anonymous functions are simply functions that aren't bound to a name. Let's take a look at the following function that accepts a single argument and prints it:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(fn [arg] (println arg))\n")])])]),t("p",[e._v("함수는 "),t("code",[e._v("fn")]),e._v(" 형식 뒤에 인수가 포함된 벡터와 본문을 사용하여 정의됩니다. 위 함수를 목록의 첫 번째 항목으로 설정하고 인수를 두 번째 항목으로 설정하여 호출할 수 있습니다:")]),e._v(" "),t("p",[e._v("The function is defined by using the "),t("code",[e._v("fn")]),e._v(" form followed by the vector containing its argument and the body. We could call the above function by setting it as a first item in a list and its argument as the second:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('((fn [arg] (println arg)) "hello")\n=>"hello"\n')])])]),t("p",[e._v("클로저는 "),t("code",[e._v("#")]),e._v(" 표기법을 사용하여 익명 함수를 정의하기 위한 구문 설탕을 제공합니다. 이를 사용하면 함수를 다음과 같이 더 간결하게 재작성할 수 있습니다:")]),e._v(" "),t("p",[e._v("Clojure provides syntactic sugar for defining anonymous functions using the "),t("code",[e._v("#")]),e._v(" notation. With it we can rewrite our function more concisely as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("#(println %)\n")])])]),t("p",[e._v("여기서 % 기호는 이름이 지정되지 않은 인수를 나타냅니다. 여러 개의 인자 뒤에는 각각 아래와 같이 위치를 나타내는 숫자가 붙습니다:")]),e._v(" "),t("p",[e._v("Here, the "),t("code",[e._v("%")]),e._v(" symbol indicates an unnamed argument. Multiple arguments would each be followed by a number indicating its position as seen below:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("#(println %1 %2 %3)\n")])])]),t("p",[e._v("이러한 유형의 함수는 명명된 함수를 정의할 필요가 없는 일회성 계산을 수행해야 할 때 유용합니다. 이들은 일반적으로 잠시 후에 보게 될 고차 함수와 함께 사용됩니다.")]),e._v(" "),t("p",[e._v("This type of function is useful when you need to perform a one-off computations that don't warrant defining a named function. They are commonly used in conjunction with the higher-order functions that we'll see in a moment.")]),e._v(" "),t("h3",{attrs:{id:"이름있는-함수-named-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#이름있는-함수-named-functions"}},[e._v("#")]),e._v(" 이름있는 함수(Named Functions)")]),e._v(" "),t("p",[e._v("명명된 함수는 식별자로 사용되는 기호에 바인딩된 단순한 익명 함수입니다. 클로저는 전역 변수를 생성하는 데 사용되는 'def'라는 특수 형식을 제공합니다. 이 형식은 이름과 할당할 본문을 받습니다. 다음과 같이 "),t("code",[e._v("def")]),e._v(" 형식을 사용하여 명명된 함수를 만들 수 있습니다:")]),e._v(" "),t("p",[e._v("Named functions are simply anonymous functions bound to a symbol used as an identifier. Clojure provides a special form called "),t("code",[e._v("def")]),e._v(" that's used for creating global variables. It accepts a name and the body to be assigned to it. We can create a named function using the "),t("code",[e._v("def")]),e._v(" form as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(def double\n  (fn [x] (* 2 x)))\n")])])]),t("p",[e._v("이 작업은 매우 일반적인 작업이기 때문에 클로저는 이 작업을 대신 수행하는 "),t("code",[e._v("defn")]),e._v("이라는 형식을 제공합니다:")]),e._v(" "),t("p",[e._v("Since this is such a common operation, Clojure provides a form called "),t("code",[e._v("defn")]),e._v(" that does it for us:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(defn square [x]\n  (* x x))\n")])])]),t("p",[t("code",[e._v("defn")]),e._v(" 형식은 첫 번째 인수가 함수의 이름이라는 점을 제외하면 위에서 살펴본 "),t("code",[e._v("fn")]),e._v(" 형식과 동일하게 동작합니다. 함수의 본문은 여러 표현식으로 구성될 수 있습니다:")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("defn")]),e._v(" form behaves the same as the "),t("code",[e._v("fn")]),e._v(" form we saw above, except that its first argument is the name of the function. The body of the function can consist of multiple expressions:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn bmi [height weight]\n  (println "height:" height)\n  (println "weight:" weight)\n  (/ weight (* height height)))\n')])])]),t("p",[e._v("여기서는 키와 몸무게 매개변수를 사용하여 BMI를 계산하는 함수를 정의합니다. 본문은 두 개의 인쇄 문과 몸무게를 키의 제곱으로 나누는 호출로 구성됩니다. 모든 표현식은 안쪽에서 바깥쪽으로 값을 평가합니다. 마지막 문에서 "),t("code",[e._v("(* height height)")]),e._v("가 평가된 다음 무게를 결과로 나누어 반환합니다. 클로저에서 "),t("code",[e._v("/")]),e._v(" 및 "),t("code",[e._v("*")]),e._v("와 같은 수학 연산자는 일반 함수이므로 다른 함수에서와 마찬가지로 접두사 표기법을 사용하여 호출합니다.")]),e._v(" "),t("p",[e._v("Here we define a function to calculate the BMI using the height and weight parameters. The body consists of two print statements and a call to divide the weight by the square of the height. All the expressions are evaluated from the inside out. In the last statement, "),t("code",[e._v("(* height height)")]),e._v(" is evaluated, then the weight is divided by the result and returned. In Clojure, mathematical operators, such as "),t("code",[e._v("/")]),e._v(" and "),t("code",[e._v("*")]),e._v(", are regular functions and so we call them using the prefix notation as we would with any other function.")]),e._v(" "),t("p",[e._v("마지막 표현식의 결과만 함수에서 반환되고 다른 모든 표현식의 결과는 버려집니다. 따라서 중간 표현식은 위의 "),t("code",[e._v("println")]),e._v(" 호출의 경우처럼 부작용이 발생할 수 있으므로 엄격하게 사용해야 합니다.")]),e._v(" "),t("p",[e._v("Note that only the result from the last expression is returned from the function, the results of all the other expressions are discarded. Therefore, any intermediate expressions should strictly be used for side effects as is the case with the "),t("code",[e._v("println")]),e._v(" calls above.")]),e._v(" "),t("p",[e._v("한 가지 주의해야 할 점은 클로저는 단일 패스 컴파일러를 사용한다는 것입니다. 따라서 함수를 사용하기 전에 반드시 선언해야 합니다. 함수가 선언되기 전에 함수를 참조해야 하는 경우, 정방향 선언을 제공하기 위해 "),t("code",[e._v("declare")]),e._v(" 매크로를 사용해야 합니다.")]),e._v(" "),t("p",[e._v("One thing to note is that Clojure uses a single pass compiler. For this reason, the functions must be declared before they are used. In a case when we need to refer to a function before it's been declared, we must use the "),t("code",[e._v("declare")]),e._v(" macro in order to provide a forward declaration.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(declare down)\n\n(defn up [n]\n  (if (< n 10)\n    (down (+ 2 n)) n))\n\n(defn down [n]\n  (up (dec n)))\n")])])]),t("p",[e._v("예리한 독자라면 코드가 트리 구조로 되어 있다는 것을 눈치챘을 것입니다. 이 트리를 추상 구문 트리 또는 줄여서 AST라고 합니다. AST를 직접 볼 수 있으면 논리 조각 간의 관계를 시각적으로 살펴볼 수 있습니다.")]),e._v(" "),t("p",[e._v("A keen reader will have noticed that the code is structured as a tree. This tree is called the abstract syntax tree, or AST for short. By being able to see the AST directly, we can examine the relationships between pieces of logic visually.")]),e._v(" "),t("p",[e._v("데이터로 코드를 작성하기 때문에 대부분의 언어에 비해 구문 힌트가 적습니다. 예를 들어, 명시적인 반환 문이 없고 함수 본문의 마지막 표현식이 암시적으로 반환됩니다.")]),e._v(" "),t("p",[e._v("Since we write our code in terms of data, there are fewer syntactic hints than in most languages. For example, there is no explicit return statement and the last expression of the function body is returned implicitly.")]),e._v(" "),t("p",[e._v("코드에서 많은 주석을 보는 데 익숙한 사용자라면 익숙해지는 데 시간이 조금 걸릴 수 있습니다. 가독성을 높이기 위해 함수는 종종 짧게 유지되고 들여쓰기와 간격은 시각적으로 코드를 그룹화하는 데 사용됩니다.")]),e._v(" "),t("p",[e._v("This might take a little getting used to if you're accustomed to seeing a lot of annotations in your code. To aid readability, functions are often kept short while indentation and spacing are used for grouping code visually.")]),e._v(" "),t("p",[e._v("클로저에서는 함수와 변수를 구분하지 않습니다. 레이블에 함수를 할당하거나, 매개변수로 전달하거나, 다른 함수에서 함수를 반환할 수 있습니다. 데이터로 취급할 수 있는 함수는 추가적인 제한이 없기 때문에 일류라고 합니다.")]),e._v(" "),t("p",[e._v("In Clojure, there is no distinction between functions and variables. You can assign a function to a label, pass it as a parameter, or return a function from another function. Functions that can be treated as data are referred to as being first-class because they don't have any additional restrictions attached to them.")]),e._v(" "),t("h3",{attrs:{id:"고차-함수-higher-order-functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#고차-함수-higher-order-functions"}},[e._v("#")]),e._v(" 고차 함수 (Higher-Order Functions)")]),e._v(" "),t("p",[e._v("다른 함수를 매개변수로 받는 함수를 고차 함수라고 합니다. 이러한 함수의 한 가지 예로 "),t("code",[e._v("map")]),e._v("이 있습니다:")]),e._v(" "),t("p",[e._v("Functions that take other functions as parameters are called higher-order functions. One example of such a function is "),t("code",[e._v("map")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(map #(* % %) [1 2 3 4 5]) => (1 4 9 16 25)\n")])])]),t("p",[e._v("이 함수는 두 개의 매개변수를 받는데, 첫 번째 매개변수는 인수를 제곱하는 익명 함수이고 두 번째 매개변수는 숫자 컬렉션입니다. 지도 함수는 컬렉션의 각 항목을 방문하여 제곱합니다.")]),e._v(" "),t("p",[e._v("This function accepts two parameters where the first is an anonymous function that squares its argument and the second is a collection of numbers. The map function will visit each item in the collection and square it.")]),e._v(" "),t("p",[e._v("고차 함수를 사용할 때 얻을 수 있는 가장 큰 장점은 사용되는 함수에서 코드의 의도를 유추할 수 있다는 것입니다. 위의 예제를 명령형 루프와 대조해 보겠습니다:")]),e._v(" "),t("p",[e._v("One major advantage of using a higher order function is that we can infer the intent of the code from the function being used. Let's contrast the above example to an imperative style loop:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(loop [[n & numbers] [1 2 3 4 5]\n       result []]\n  (let [result (conj result (* n n))]\n    (if numbers\n      (recur numbers result)\n      result)))\n")])])]),t("p",[e._v("루핑 접근 방식은 결국 더 많은 노이즈가 발생하므로 코드가 무엇을 하는지 파악하기 위해 코드를 더 주의 깊게 읽어야 합니다. 또 다른 문제는 코드가 모놀리식이 되어 어떤 부분도 개별적으로 사용할 수 없다는 것입니다.")]),e._v(" "),t("p",[e._v("The looping approach ends up having a lot more noise and thus we have to read through the code more carefully to tell what it's doing. The other problem is that the code becomes monolithic and no part of it can be used individually.")]),e._v(" "),t("p",[e._v("고차 함수의 또 다른 예는 '필터(filter)'입니다. 이 함수는 컬렉션을 통과하여 지정된 술어와 일치하는 항목만 유지합니다.")]),e._v(" "),t("p",[e._v("Another example of a higher-order function is "),t("code",[e._v("filter")]),e._v(". This function goes through a collection and keeps only the items matching the specified predicate.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(filter even? [1 2 3 4 5]) => (2 4)\n")])])]),t("p",[e._v("고차 함수를 쉽게 연결하여 복잡한 변환을 만들 수 있습니다:")]),e._v(" "),t("p",[e._v("Higher order functions can be easily chained together to create complex transformations:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(filter even?\n  (map #(* 3 %) [1 2 3 4 5]))\n\n=>(6 12)\n")])])]),t("p",[e._v("여기서는 각 항목에 3을 곱한 다음 'filter'를 사용하여 결과 시퀀스에서 짝수 항목만 유지합니다. 고차 함수를 사용하면 루프나 명시적 재귀를 작성할 필요가 거의 없습니다. 컬렉션을 반복할 때는 "),t("code",[e._v("map")]),e._v("이나 "),t("code",[e._v("filter")]),e._v("와 같은 함수를 대신 사용하세요. 클로저에는 풍부한 표준 라이브러리가 있기 때문에 라이브러리에 있는 함수를 조합하면 거의 모든 데이터 변환을 쉽게 수행할 수 있습니다. "),t("a",{attrs:{href:"https://github.com/mythz/clojure-linq-examples",target:"_blank",rel:"noopener noreferrer"}},[e._v("여기"),t("OutboundLink")],1),e._v("에서 이 접근 방식의 몇 가지 예시를 참조하세요.")]),e._v(" "),t("p",[e._v("Here we multiply each item by 3, then we use "),t("code",[e._v("filter")]),e._v(" to only keep the even items from the resulting sequence. Having higher-order functions means that you should rarely have to write loops or explicit recursion. When iterating a collection, use a function such as "),t("code",[e._v("map")]),e._v(" or "),t("code",[e._v("filter")]),e._v(" instead. Since Clojure has a rich standard library, practically any data transformation can be easily achieved by combining functions found there. See "),t("a",{attrs:{href:"https://github.com/mythz/clojure-linq-examples",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v(" for some examples of this approach in action.")]),e._v(" "),t("p",[e._v("데이터 변환을 특정 함수와 연관시키는 방법을 배우면 이러한 함수를 특정 순서로 조합하는 것만으로도 많은 문제를 해결할 수 있습니다.")]),e._v(" "),t("p",[e._v("Once you learn to associate data transformations with specific functions, many problems can be solved by simply putting these functions together in a specific order.")]),e._v(" "),t("p",[e._v("이 아이디어를 간단한 실제 문제에 사용하는 방법을 살펴보겠습니다. 주소를 나타내는 필드가 지정된 형식의 주소를 표시하고 싶습니다. 일반적으로 주소에는 단위 번호, 거리, 도시, 우편 번호 및 국가가 있습니다. 이러한 각 필드를 검사하여 'nil'과 비어 있는 필드를 제거하고 그 사이에 구분 기호를 삽입해야 합니다. 다음 필드가 포함된 테이블이 주어집니다:")]),e._v(" "),t("p",[e._v("Let's take a look at using this idea for a simple real world problem. We'd like to display a formatted address given the fields representing it. Commonly an address has a unit number, a street, a city, a postal code, and a country. We'll have to examine each of these fields, remove the "),t("code",[e._v("nil")]),e._v(" and empty ones, and insert a separator between them. Given a table containing the following fields:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('unit      | street          | city      | postal_code | country\n""        | "1 Main street" | "Toronto" | nil         | "Canada"\n')])])]),t("p",[e._v("테이블의 문자열을 사용하여 다음과 같은 형식의 문자열을 출력하려고 합니다:")]),e._v(" "),t("p",[e._v("We would like to output the following formatted string using the strings in the table:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('"1 Main street, Toronto, Canada"\n')])])]),t("p",[e._v("빈 필드를 제거하고, 구분 기호를 삽입하고, 결과를 문자열로 연결하는 작업을 위한 함수를 찾기만 하면 됩니다:")]),e._v(" "),t("p",[e._v("All we have to do is find the functions for the tasks of removing empty fields, interposing the separator, and concatenating the result into a string:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn concat-fields [& fields]\n  (clojure.string/join ", " (remove empty? fields)))\n\n(concat-fields "" "1 Main street" "Toronto" nil "Canada")\n=> "1 Main street, Toronto, Canada"\n')])])]),t("p",[e._v("코드를 작성할 때 작업 수행 방법을 지정할 필요가 없다는 점에 주목하세요. 대부분의 경우 수행하고자 하는 작업을 나타내는 함수를 구성하여 수행하고자 하는 작업을 간단히 설명하기만 하면 됩니다. 결과 코드는 모든 일반적인 에지 케이스도 처리합니다:")]),e._v(" "),t("p",[e._v("Notice that we didn't have to specify how to do any of the tasks when writing our code. Most of the time we simply say what we're doing by composing the functions representing the operations we wish to carry out. The resulting code also handles all the common edge cases:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(concat-fields) => ""\n(concat-fields nil) => ""\n(concat-fields "") => ""\n')])])]),t("p",[e._v("클로저에서는 코드가 모든 입력에 대해 즉시 올바르게 작동하는 것이 일반적입니다.")]),e._v(" "),t("p",[e._v("In Clojure, it's common for the code to work correctly for all inputs out of the box.")]),e._v(" "),t("h3",{attrs:{id:"클로저-closures"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#클로저-closures"}},[e._v("#")]),e._v(" 클로저(Closures)")]),e._v(" "),t("ul",[t("li",[e._v("[참고] "),t("a",{attrs:{href:"https://poiemaweb.com/js-closure",target:"_blank",rel:"noopener noreferrer"}},[e._v("클로저(closure)의 개념"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("이제 함수를 선언하고 이름을 지정하고 다른 함수에 매개변수로 전달하는 방법을 살펴봤습니다. 마지막으로 할 수 있는 것은 다른 함수를 결과로 반환하는 함수를 작성하는 것입니다. 이러한 함수의 한 가지 용도는 객체 지향 언어의 생성자가 제공하는 기능을 제공하는 것입니다.")]),e._v(" "),t("p",[e._v("We've now seen how we can declare functions, name them, and pass them as parameters to other functions. One last thing we can do is write functions that return other functions as their result. One use for such functions is to provide the functionality facilitated by constructors in object-oriented languages.")]),e._v(" "),t("p",[e._v("손님에게 따뜻한 인사말을 건네고 싶다고 가정해 봅시다. 인사말 문자열을 매개변수로 받아들이고 게스트의 이름을 받아 해당 게스트에 대한 사용자 지정 인사말을 인쇄하는 함수를 반환하는 함수를 작성할 수 있습니다:")]),e._v(" "),t("p",[e._v("Let's say we wish to greet our guests with a warm greeting. We can write a function that will accept the greeting string as its parameter and return a function that takes the name of the guest and prints a customized greeting for that guest:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn greeting [greeting-string]\n  (fn [guest]\n    (println greeting-string guest)))\n\n(let [greet (greeting "Welcome to the wonderful world of Clojure")]\n  (greet "Jane")\n  (greet "John"))\n')])])]),t("p",[t("code",[e._v("greeting")]),e._v("의 내부 함수는 값이 외부 범위에 정의되어 있으므로 "),t("code",[e._v("greeting-string")]),e._v(" 값에 액세스할 수 있습니다. "),t("code",[e._v("greeting")]),e._v(" 함수는 매개변수(여기서는 "),t("code",[e._v("greeting-string")]),e._v(")를 닫고 반환하는 함수에서 사용할 수 있도록 하기 때문에 클로저라고 합니다.")]),e._v(" "),t("p",[e._v("The inner function in the "),t("code",[e._v("greeting")]),e._v(" has access to the "),t("code",[e._v("greeting-string")]),e._v(" value since the value is defined in its outer scope. The "),t("code",[e._v("greeting")]),e._v(" function is called a closure because it closes over its parameters, in our case the "),t("code",[e._v("greeting-string")]),e._v(", and makes them available to the function that it returns.")]),e._v(" "),t("p",[e._v("또한 "),t("code",[e._v("let")]),e._v("이라는 형식을 사용하여 "),t("code",[e._v("greet")]),e._v(" 기호를 바인딩하고 그 안에 있는 모든 표현식에서 사용할 수 있도록 하고 있다는 것을 알 수 있습니다. let` 형식은 명령형 언어에서 변수를 선언하는 것과 같은 용도로 사용됩니다.")]),e._v(" "),t("p",[e._v("You'll also notice that we're using a form called "),t("code",[e._v("let")]),e._v(" to bind the "),t("code",[e._v("greet")]),e._v(" symbol and make it available to any expressions inside it. The "),t("code",[e._v("let")]),e._v(" form serves the same purpose as declaring variables in imperative languages.")]),e._v(" "),t("h3",{attrs:{id:"표현식을-연결시키기-threading-expressions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#표현식을-연결시키기-threading-expressions"}},[e._v("#")]),e._v(" 표현식을 연결시키기(Threading Expressions)")]),e._v(" "),t("p",[e._v("이쯤 되면 중첩된 표현식이 읽기 어려울 수 있다는 것을 눈치채셨을 것입니다. 다행히도 클로저는 이 문제를 해결하기 위한 몇 가지 도우미 형식을 제공합니다. 숫자 범위가 있고 각 숫자를 증가시키고 그 사이에 숫자 5를 삽입한 다음 결과를 합산하고 싶다고 가정해 보겠습니다. 이를 위해 다음 코드를 작성할 수 있습니다:")]),e._v(" "),t("p",[e._v("By this point you're probably noticing that nested expressions can get difficult to read. Fortunately, Clojure provides a couple of helper forms to deal with this problem. Let's say we have a range of numbers, and we want to increment each number, interpose the number 5 between them, then sum the result. We could write the following code to do that:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(reduce + (interpose 5 (map inc (range 10))))\n")])])]),t("p",[e._v("위에서 무슨 일이 일어나고 있는지 한눈에 파악하기는 조금 어렵습니다. 체인에 단계가 몇 개 더 있으면 정말 길을 잃을 것입니다. 게다가 증분하기 전에 5를 끼워 넣는 등 단계를 재배열하려면 모든 표현식을 다시 작성해야 합니다. 위의 표현식을 작성하는 다른 방법은 "),t("code",[e._v("->>")]),e._v(" 형식을 사용하는 것입니다:")]),e._v(" "),t("p",[e._v("It's a little difficult to tell what's happening above at a glance. With a few more steps in the chain we'd be really lost. On top of that, if we wanted to rearrange any of the steps, such as interposing 5 before incrementing, then we'd have to renest all our expressions. An alternative way to write the above expression is to use the "),t("code",[e._v("->>")]),e._v(" form:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(->> (range 10) (map inc) (interpose 5) (reduce +))\n")])])]),t("p",[e._v("여기서는 "),t("code",[e._v("->>")]),e._v("를 사용하여 연산을 하나에서 다음 연산으로 스레딩합니다. 즉, 각 표현식의 결과를 다음 표현식의 마지막 인수로 암시적으로 전달합니다. 첫 번째 인수로 전달하려면 대신 "),t("code",[e._v("->")]),e._v(" 형식을 사용합니다.")]),e._v(" "),t("p",[e._v("Here, we use "),t("code",[e._v("->>")]),e._v(" to thread the operations from one to the next. This means that we implicitly pass the result of each expression as the last argument of the next expression. To pass it as the first argument we'd use the "),t("code",[e._v("->")]),e._v(" form instead.")]),e._v(" "),t("h3",{attrs:{id:"게으름-laziness"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#게으름-laziness"}},[e._v("#")]),e._v(" 게으름 (Laziness)")]),e._v(" "),t("p",[e._v("많은 클로저 알고리즘은 결과를 실제로 평가할 필요가 없는 한 연산을 수행하지 않는 지연 평가를 사용합니다. 지연은 많은 알고리즘을 효율적으로 작동시키는 데 매우 중요합니다. 예를 들어, 앞의 예는 범위를 만들고, 매핑하고, 숫자를 삽입하고, 결과를 줄이기 위해 매번 시퀀스를 반복해야 하므로 매우 비효율적이라고 생각할 수 있습니다.")]),e._v(" "),t("p",[e._v("Many Clojure algorithms use lazy evaluation where the operations aren't performed unless their result actually needs to be evaluated. Laziness is crucial for making many algorithms work efficiently. For example, you might think the preceding example is very inefficient since we have to iterate our sequence each time to create the range, map across it, interpose the numbers, and reduce the result.")]),e._v(" "),t("p",[e._v("하지만 실제로는 그렇지 않습니다. 각 표현식의 평가는 필요에 따라 이루어집니다. 범위의 첫 번째 값이 생성되어 나머지 함수에 전달되고, 다음 값이 전달되는 식으로 시퀀스가 소진될 때까지 반복됩니다. 이는 Python과 같은 언어가 반복자 메커니즘에서 취하는 접근 방식과 유사합니다.")]),e._v(" "),t("p",[e._v("However, this is not actually the case. The evaluation of each expression happens on demand. The first value in the range is generated and passed to the rest of the functions, then the next, and so on, until the sequence is exhausted. This is a similar approach that languages like Python take with their iterator mechanics.")]),e._v(" "),t("h2",{attrs:{id:"코드-구조-code-structure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#코드-구조-code-structure"}},[e._v("#")]),e._v(" 코드 구조 (Code Structure)")]),e._v(" "),t("p",[e._v("클로저와 명령형 언어의 사소하지 않은 차이점 중 하나는 코드가 구조화되는 방식입니다. 명령형 스타일에서는 공유 가변 변수를 선언하고 다른 함수를 전달하여 변수를 수정하는 것이 일반적인 패턴입니다. 메모리 위치에 액세스할 때마다 이전에 해당 메모리 위치에서 작업한 코드의 결과를 볼 수 있습니다. 예를 들어 정수 목록이 있고 각 정수를 제곱한 다음 짝수만 인쇄하려는 경우 다음 Python 코드가 완벽하게 유효합니다:")]),e._v(" "),t("p",[e._v("One nontrivial difference between Clojure and imperative languages is the way the code is structured. In imperative style, it's a common pattern to declare a shared mutable variable and modify it by passing it different functions. Each time we access the memory location we see the result of the code that previously worked with it. For example, if we have a list of integers and we wish to square each one then print the even ones, the following Python code would be perfectly valid:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("l = range(1, 6)\n\nfor i, val in enumerate(l) :\n  l[i] = val * val\n\nfor i in l :\n  if i % 2 == 0 :\n    print i\n")])])]),t("p",[e._v("클로저에서는 이러한 상호 작용이 명시적으로 이루어져야 합니다. 공유 메모리 위치를 생성한 다음 여러 함수가 순차적으로 액세스하는 대신, 함수를 서로 연결하고 입력을 파이프로 전달합")]),e._v(" "),t("p",[e._v("In Clojure this interaction has to be made explicit. Instead of creating a shared memory location and then having different functions access it sequentially, we chain functions together and pipe the input through them:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(println\n  (filter #(= (mod % 2) 0)\n    (map #(* % %) (range 1 6))))\n")])])]),t("p",[e._v("앞서 소개한 "),t("code",[e._v("->>")]),e._v(" 매크로를 사용하여 단계를 평탄화할 수도 있습니다:")]),e._v(" "),t("p",[e._v("We could also flatten out the steps using the "),t("code",[e._v("->>")]),e._v(" macro introduced earlier:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(->> (range 1 6)\n     (map #(* % %))\n     (filter #(= (mod % 2) 0))\n     (println))\n")])])]),t("p",[e._v("각 함수는 기존 데이터를 수정하는 대신 새로운 값을 반환합니다. 이렇게 하면 비용이 많이 들 수 있으며, 변경할 때마다 데이터 전체를 복사하는 순진한 구현 방식이라고 생각할 수 있습니다.")]),e._v(" "),t("p",[e._v("Each function returns a new value instead of modifying the existing data in place. You might think that this can get very expensive, and it would be with a naïve implementation where the entirety of the data is copied with every change.")]),e._v(" "),t("p",[e._v("실제로 Clojure는 데이터의 인메모리 수정본을 생성하는 영구 데이터 구조로 뒷받침됩니다. 변경이 이루어질 때마다 변경 크기에 비례하여 새로운 수정본이 생성됩니다. 이 접근 방식을 사용하면 변경 사항이 로컬라이즈되도록 보장하면서 이전 구조와 새 구조 간의 차이에 대한 대가만 지불하면 됩니다.")]),e._v(" "),t("p",[e._v("In reality, Clojure is backed by persistent data structures that create in-memory revisions of the data. Each time a change is made a new revision is created proportional to the size of the change. With this approach we only pay the price of the difference between the old and the new structures while ensuring that any changes are localized.")]),e._v(" "),t("h3",{attrs:{id:"구조-쪼개기-destructuring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#구조-쪼개기-destructuring"}},[e._v("#")]),e._v(" 구조 쪼개기(Destructuring)")]),e._v(" "),t("p",[e._v("클로저에는 데이터 구조의 값에 선언적으로 액세스하기 위한 강력한 메커니즘인 디스트럭처링이 있습니다. 이 기술은 데이터에 쉽게 액세스하고 함수에 대한 매개변수를 문서화하는 역할을 합니다. 몇 가지 예제를 통해 어떻게 작동하는지 살펴봅시다.")]),e._v(" "),t("p",[e._v("Clojure has a powerful mechanism called destructuring for declaratively accessing values in data structures. This technique provides easy access to the data and serves to document the parameters to a function. Let's look at some examples to see how it works.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(let [[smaller bigger] (split-with #(< % 5) (range 10))]\n    (println smaller bigger))\n\n=>(0 1 2 3 4) (5 6 7 8 9)\n")])])]),t("p",[e._v("위에서는 "),t("code",[e._v("split-with")]),e._v(" 함수를 사용하여 10개의 숫자 범위를 5보다 작은 숫자와 5보다 크거나 같은 숫자라는 두 가지 요소를 포함하는 시퀀스로 분할했습니다. 결과의 형식을 알고 있으므로 "),t("code",[e._v("let")]),e._v(" 바인딩에서 "),t("code",[e._v("[작은 더 큰]")]),e._v("과 같이 리터럴 형식으로 작성할 수 있습니다. 디스트럭처링은 "),t("code",[e._v("let")]),e._v(" 형식에 국한되지 않으며 함수 인자와 같은 모든 유형의 바인딩에 적용됩니다.")]),e._v(" "),t("p",[e._v("Above, we use "),t("code",[e._v("split-with")]),e._v(" function to split a range of ten numbers into a sequence containing two elements: numbers less than 5 and numbers greater than or equal to 5. Since we know the format of the result, we can write it in a literal form as "),t("code",[e._v("[smaller bigger]")]),e._v(" in the "),t("code",[e._v("let")]),e._v(" binding. Destructuring is not limited to the "),t("code",[e._v("let")]),e._v(" form and works for all types of bindings such as function arguments.")]),e._v(" "),t("p",[e._v("세 개의 요소가 있는 벡터를 받아 각각 "),t("code",[e._v("name")]),e._v(", "),t("code",[e._v("address")]),e._v(", "),t("code",[e._v("phone")]),e._v("에 바인딩하는 "),t("code",[e._v("print-user")]),e._v("라는 다른 함수를 살펴보겠습니다:")]),e._v(" "),t("p",[e._v("Let's look at another function called "),t("code",[e._v("print-user")]),e._v(" that accepts a vector with three elements and binds them to "),t("code",[e._v("name")]),e._v(", "),t("code",[e._v("address")]),e._v(", and "),t("code",[e._v("phone")]),e._v(", respectively:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn print-user [[name address phone]]\n  (println name "-" address phone))\n\n(print-user ["John" "397 King street, Toronto" "416-936-3218"])\n=> "John - 397 King street, Toronto 416-936-3218"\n')])])]),t("p",[e._v("변수 인수를 시퀀스로 지정할 수도 있습니다. 이 경우 "),t("code",[e._v("&")]),e._v(" 뒤에 나머지 인수가 포함된 목록의 이름을 사용하면 됩니다:")]),e._v(" "),t("p",[e._v("We can also specify variable arguments as a sequence. This is done by using "),t("code",[e._v("&")]),e._v(" followed by the name of the list containing the remaining arguments:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn print-args [& args]\n  (println args))\n\n(print-args "a" "b" "c") => (a b c)\n')])])]),t("p",[e._v("변수 인수는 시퀀스에 저장되므로 다른 인자와 마찬가지로 파괴할 수 있습니")]),e._v(" "),t("p",[e._v("Since the variable arguments are stored in a sequence, it can be destructured like any other:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn print-args [arg1 & [arg2]]\n  (println\n    (if arg2\n      "got two arguments"\n      "got one argument")))\n\n(print-args "bar")\n=>"got one argument"\n\n(print-args "bar" "baz")\n=>"got two arguments"\n')])])]),t("p",[e._v("디스트럭처링은 맵에도 적용할 수 있습니다. 맵을 디스트럭처링할 때는 원래 맵의 키를 가리키는 로컬 바인딩의 이름을 제공하는 새 맵을 만듭니다:")]),e._v(" "),t("p",[e._v("Destructuring can also be applied to maps. When destructuring a map, we create a new map where we supply the names for the local bindings pointing to the keys from the original map:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(let [{foo :foo bar :bar} {:foo "foo" :bar "bar"}]\n  (println foo bar))\n')])])]),t("p",[e._v("중첩된 데이터 구조를 파괴하는 것도 가능합니다. 전달되는 데이터의 구조만 알고 있다면 간단히 작성할 수 있습니다:")]),e._v(" "),t("p",[e._v("It's also possible to destructure a nested data structure. As long as you know the structure of the data being passed in, you can simply write it out:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(let [{[a b c] :items id :id} {:id "foo" :items [1 2 3]}]\n  (println id "->" a b c))\n=> "foo -> 1 2 3"\n')])])]),t("p",[e._v("마지막으로, 맵에서 키를 추출하는 것은 매우 일반적인 작업이므로 Clojure는 이 작업을 위한 구문 설탕을 제공합니다:")]),e._v(" "),t("p",[e._v("Finally, since extracting keys from maps is a very common operation, Clojure provides syntactic sugar for this task:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn login [{:keys [user pass]}]\n (and (= user "bob") (= pass "secret")))\n\n(login {:user "bob" :pass "secret"})\n')])])]),t("p",[e._v("또 다른 유용한 디스트럭처링 옵션을 사용하면 원본 맵을 보존하면서 일부 키를 추출할 수 있습니다:")]),e._v(" "),t("p",[e._v("Another useful destructuring option allows us to extract some keys while preserving the original map:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn register [{:keys [id pass repeat-pass] :as user}]\n  (cond\n    (nil? id) "user id is required"\n    (not= pass repeat-pass) "re-entered password doesn\'t match"\n    :else user))\n')])])]),t("h3",{attrs:{id:"네임스페이스-namespaces"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#네임스페이스-namespaces"}},[e._v("#")]),e._v(" 네임스페이스(Namespaces)")]),e._v(" "),t("p",[e._v("실제 애플리케이션을 작성할 때는 코드를 별도의 구성 요소로 구성할 수 있는 도구가 필요합니다. 객체 지향 언어는 이를 위해 클래스를 제공합니다. 관련 메서드는 모두 같은 클래스에 정의됩니다. 클로저에서는 함수를 네임스페이스로 그룹화합니다. 네임스페이스가 어떻게 정의되는지 살펴봅시다.")]),e._v(" "),t("p",[e._v("When writing real-world applications we need tools to organize our code into separate components. Object-oriented languages provide classes for this purpose. The related methods will all be defined in the same class. In Clojure, we group our functions into namespaces instead. Let's look at how a namespace is defined.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns colors)\n\n(defn hex->rgb [[_ & rgb]]\n    (map #(->> % (apply str "0x") (Long/decode))\n         (partition 2 rgb)))\n\n(defn hex-str [n]\n  (-> (format "%2s" (Integer/toString n 16))\n      (clojure.string/replace " " "0")))\n\n(defn rgb->hex [color]\n  (apply str "#" (map hex-str color)))\n')])])]),t("p",[e._v("위에는 "),t("code",[e._v("hex->rgb")]),e._v(", "),t("code",[e._v("hex-str")]),e._v(", "),t("code",[e._v("rgb->hex")]),e._v("라는 세 가지 함수가 포함된 "),t("code",[e._v("colors")]),e._v("라는 네임스페이스가 있습니다. 같은 네임스페이스에 있는 함수는 서로를 직접 호출할 수 있습니다. 그러나 다른 네임스페이스에서 이러한 함수를 호출하려면 먼저 "),t("code",[e._v("colors")]),e._v(" 네임스페이스를 참조해야 합니다.")]),e._v(" "),t("p",[e._v("Above, we have a namespace called "),t("code",[e._v("colors")]),e._v(" containing three functions called "),t("code",[e._v("hex->rgb")]),e._v(", "),t("code",[e._v("hex-str")]),e._v(", and "),t("code",[e._v("rgb->hex")]),e._v(". The functions in the same namespace can call each other directly. However, if we wanted to call these functions from a different namespace we would have to reference the "),t("code",[e._v("colors")]),e._v(" namespace there first.")]),e._v(" "),t("p",[e._v("클로저는 이를 위해 두 가지 방법을 제공하는데, "),t("code",[e._v(":use")]),e._v(" 또는 "),t("code",[e._v(":require")]),e._v(" 키워드를 사용할 수 있습니다. 사용`으로 네임스페이스를 참조하면 해당 네임스페이스를 참조하는 네임스페이스에 정의된 것처럼 모든 변수를 암시적으로 사용할 수 있게 됩니다.")]),e._v(" "),t("p",[e._v("Clojure provides two ways to do this, we can either use the "),t("code",[e._v(":use")]),e._v(" or the "),t("code",[e._v(":require")]),e._v(" keywords. When we reference a namespace with "),t("code",[e._v(":use")]),e._v(", all its Vars become implicitly available as if they were defined in the namespace that references it.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns myns\n  (:use colors))\n\n(hex->rgb "#33d24f")\n')])])]),t("p",[e._v("이 접근 방식에는 두 가지 단점이 있습니다. 함수가 원래 어디에 정의되었는지 알 수 없어 코드를 탐색하기 어렵고, 함수에 동일한 이름을 사용하는 두 개의 네임스페이스를 참조하면 오류가 발생합니다.")]),e._v(" "),t("p",[e._v("There are two downsides to this approach. We don't know where the function was originally defined, making it difficult to navigate the code, and if we reference two namespaces that use the same name for a function, we'll get an error.")]),e._v(" "),t("p",[e._v("첫 번째 문제는 "),t("code",[e._v(":use")]),e._v(" 선언에서 "),t("code",[e._v(":only")]),e._v(" 키워드를 사용하여 명시적으로 사용하려는 함수를 선택함으로써 해결할 수 있습니다.")]),e._v(" "),t("p",[e._v("We can address the first problem by selecting the functions we wish to use explicitly using the "),t("code",[e._v(":only")]),e._v(" keyword in our "),t("code",[e._v(":use")]),e._v(" declaration.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns myns\n  (:use [colors :only [rgb->hex]]))\n\n(defn hex-str [c]\n  (println "I don\'t do much yet"))\n')])])]),t("p",[e._v("이렇게 하면 "),t("code",[e._v("rgb->hex")]),e._v("의 출처를 문서화할 수 있고, "),t("code",[e._v("myns")]),e._v(" 네임스페이스에서 충돌 없이 자체 "),t("code",[e._v("hex-str")]),e._v(" 함수를 선언할 수 있습니다. rgb->hex"),t("code",[e._v("는 여전히")]),e._v("colors"),t("code",[e._v("네임스페이스에 정의된")]),e._v("hex-str` 함수를 사용한다는 점에 유의하세요.")]),e._v(" "),t("p",[e._v("This way we document where "),t("code",[e._v("rgb->hex")]),e._v(" comes from, and we're able to declare our own "),t("code",[e._v("hex-str")]),e._v(" function in the "),t("code",[e._v("myns")]),e._v(" namespace without conflicts. Note that "),t("code",[e._v("rgb->hex")]),e._v(" will still use the "),t("code",[e._v("hex-str")]),e._v(" function defined in the "),t("code",[e._v("colors")]),e._v(" namespace.")]),e._v(" "),t("p",[e._v("네임스페이스를 참조하기 위해 "),t("code",[e._v(":require")]),e._v(" 키워드를 사용하는 접근 방식은 보다 유연한 옵션을 제공합니다. 각각을 살펴보겠습니다.")]),e._v(" "),t("p",[e._v("The approach of using the "),t("code",[e._v(":require")]),e._v(" keyword to reference the namespace provides us with more flexible options. Let's look at each of these.")]),e._v(" "),t("p",[e._v("추가 지시어를 제공하지 않고 네임스페이스를 요구할 수 있습니다. 이 경우, 네임스페이스 내부의 Vars에 대한 모든 호출은 그 출처를 나타내는 네임스페이스 선언을 앞에 붙여야 합니다.")]),e._v(" "),t("p",[e._v("We can require a namespace without providing any further directives. In this case, any calls to Vars inside it must be prefixed with the namespace declaration indicating their origin.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns myns (:require colors))\n\n(colors/hex->rgb "#324a9b")\n')])])]),t("p",[e._v("이 접근 방식은 참조되는 Vars의 출처를 명시하고 여러 네임스페이스를 참조할 때 충돌이 발생하지 않도록 보장합니다. 한 가지 문제점은 네임스페이스 선언이 길면 그 안에 선언된 함수를 사용하고자 할 때마다 입력해야 하는 번거로움이 있다는 것입니다. 이 문제를 해결하기 위해 "),t("code",[e._v(":require")]),e._v(" 문은 "),t("code",[e._v(":as")]),e._v(" 지시문을 제공하여 네임스페이스의 별칭을 생성할 수 있도록 합니다.")]),e._v(" "),t("p",[e._v("This approach is explicit about the origin of the Vars being referenced and ensures that we won't have conflicts when referencing multiple namespaces. One problem is that when our namespace declaration is long, it gets tedious to have to type it out any time we wish to use a function declared inside it. To address this problem, the "),t("code",[e._v(":require")]),e._v(" statement provides the "),t("code",[e._v(":as")]),e._v(" directive, allowing us to create an alias for the namespace.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(ns myotherns\n  (:require [colors :as c]))\n\n(c/hex->rgb "#324a9b")\n')])])]),t("p",[e._v("참조"),t("code",[e._v("키워드를 사용하여 네임스페이스에서 함수를 요구할 수도 있습니다. 이는 앞서 살펴본")]),e._v(":use` 표기법과 동의어입니다. 다른 네임스페이스의 모든 함수를 요구하려면 다음과 같이 작성하면 됩니다:")]),e._v(" "),t("p",[e._v("We can also require functions from a namespace by using the "),t("code",[e._v(":refer")]),e._v(" keyword. This is synonymous with the "),t("code",[e._v(":use")]),e._v(" notation we saw earlier. To require all the functions from another namespace, we can write the following:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(ns myns\n  (:require [colors :refer :all]))\n")])])]),t("p",[e._v("이름별로 필요한 함수를 선택하려면 대신 다음과 같이 작성하면 됩니다:")]),e._v(" "),t("p",[e._v("If we wish to select what functions to require by name, we can instead write:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(ns myns\n  (:require [colors :refer [rgb->hex]))\n")])])]),t("p",[e._v("보시다시피 다른 네임스페이스에 선언된 Vars를 참조하는 데 사용할 수 있는 옵션은 여러 가지가 있습니다. 어떤 옵션을 선택해야 할지 잘 모르겠다면 이름 또는 별칭으로 네임스페이스를 요청하는 것이 가장 안전한 방법입니다.")]),e._v(" "),t("p",[e._v("As you can see, there's a number of options available for referencing Vars declared in other namespaces. If you're not sure what option to pick, then requiring the namespace by name or alias is the safest route.")]),e._v(" "),t("h3",{attrs:{id:"동적-변수-dynamic-variables"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#동적-변수-dynamic-variables"}},[e._v("#")]),e._v(" 동적 변수 Dynamic Variables")]),e._v(" "),t("p",[e._v("클로저는 특정 범위 내에서 값을 변경할 수 있는 동적 변수를 선언하는 기능을 지원합니다. 이것이 어떻게 작동하는지 살펴봅시다.")]),e._v(" "),t("p",[e._v("Clojure provides support for declaring dynamic variables that can have their value changed within a particular scope. Let's look at how this works.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(declare ^{:dynamic true} *foo*)\n\n(println *foo*)\n=>#<Unbound Unbound: #'bar/*foo*>\n")])])]),t("p",[e._v("여기서는 "),t("code",[e._v("*foo*")]),e._v("를 동적 변수로 선언하고 값을 제공하지 않았습니다. "),t("code",[e._v("*foo*")]),e._v("를 출력하려고 하면 이 변수가 어떤 값에도 바인딩되지 않았음을 나타내는 오류가 발생합니다. 바인딩을 사용하여 "),t("code",[e._v("*foo*")]),e._v("에 값을 할당하는 방법을 살펴봅시다.")]),e._v(" "),t("p",[e._v("Here we declared "),t("code",[e._v("*foo*")]),e._v(" as a dynamic Var and didn't provide any value for it. When we try to print "),t("code",[e._v("*foo*")]),e._v(" we get an error indicating that this Var has not been bound to any value. Let's look at how we can assign a value to "),t("code",[e._v("*foo*")]),e._v(" using a binding.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defn with-foo [f]\n  (binding [*foo* "I exist!"]\n    (f)))\n\n(with-foo #(println *foo*)) =>"I exist!"\n')])])]),t("p",[t("code",[e._v("with-foo")]),e._v(" 함수 내에서 "),t("code",[e._v("*foo*")]),e._v('를 "I exist!"라는 값을 가진 문자열로 설정합니다. 익명 함수가 with-foo 안에서 호출되면 값을 출력하려고 할 때 더 이상 오류가 발생하지 않습니다.')]),e._v(" "),t("p",[e._v("We set "),t("code",[e._v("*foo*")]),e._v(' to a string with value "I exist!" inside the '),t("code",[e._v("with-foo")]),e._v(" function. When our anonymous function is called inside with-foo we no longer get an error when trying to print its value.")]),e._v(" "),t("p",[e._v("이 기법은 파일 스트림, 데이터베이스 연결 또는 범위가 지정된 변수와 같은 리소스를 다룰 때 유용할 수 있습니다. 일반적으로 동적 변수는 코드를 더 불투명하게 만들고 추론하기 어렵게 만들기 때문에 사용하지 않는 것이 좋습니다. 하지만 동적 변수를 합법적으로 사용할 수 있는 경우도 있으므로 작동 원리를 알아두는 것이 좋습니다.")]),e._v(" "),t("p",[e._v("This technique can be useful when dealing with resources such as file streams, database connections, or scoped variables. In general, the use of dynamic variables is discouraged since they make code more opaque and difficult to reason about. However, there are legitimate uses for them, and it's worth knowing how they work.")]),e._v(" "),t("h2",{attrs:{id:"폴리모피즘-polymorphism"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#폴리모피즘-polymorphism"}},[e._v("#")]),e._v(" 폴리모피즘(Polymorphism)")]),e._v(" "),t("p",[e._v("객체 지향의 유용한 측면 중 하나는 다형성이지만, 다형성이 해당 스타일과 연관되어 있기는 하지만 결코 배타적이지 않습니다. 클로저는 런타임 다형성을 달성하는 두 가지 일반적인 방법을 제공합니다. 각각을 차례로 살펴보겠습니다.")]),e._v(" "),t("p",[e._v("One useful aspect of object-orientation is polymorphism, while it happens to be associated with that style it's in no way exclusive to it. Clojure provides two common ways to achieve runtime polymorphism. Let's look at each of these in turn.")]),e._v(" "),t("h3",{attrs:{id:"멀티메소드-multimethods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#멀티메소드-multimethods"}},[e._v("#")]),e._v(" 멀티메소드(Multimethods)")]),e._v(" "),t("p",[e._v("다중 메서드는 하나 이상의 메서드와 연결된 선택자 함수를 사용하여 매우 유연한 디스패치 메커니즘을 제공합니다. 다중 메서드는 "),t("code",[e._v("defmulti")]),e._v("를 사용하여 정의되며, 그 메서드는 각각 "),t("code",[e._v("defmethod")]),e._v("를 사용하여 정의됩니다. 예를 들어 서로 다른 도형이 있고 면적을 계산하는 다중 메서드를 작성하고자 한다면 다음과 같이 할 수 있습니다:")]),e._v(" "),t("p",[e._v("Multimethods provide an extremely flexible dispatching mechanism using a selector function associated with one or more methods. The multimethod is defined using "),t("code",[e._v("defmulti")]),e._v(" and its methods are each defined using "),t("code",[e._v("defmethod")]),e._v(". For example, if we had different shapes and we wanted to write a multimethod to calculate the area we could do the following:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defmulti area :shape)\n\n(defmethod area :circle [{:keys [r]}]\n  (* Math/PI r r))\n\n(defmethod area :rectangle [{:keys [l w]}]\n  (* l w))\n\n(defmethod area :default [shape]\n  (throw (Exception. (str "unrecognized shape: " shape))))\n\n(area {:shape :circle :r 10})\n=> 314.1592653589793\n\n(area {:shape :rectangle :l 5 :w 10})\n=> 50\n')])])]),t("p",[e._v("위의 dispatch 함수는 키워드를 사용하여 각 맵 유형을 처리하는 데 적합한 방법을 선택합니다. 키워드가 함수처럼 작동하고 지도가 전달되면 키워드와 연관된 값을 반환하기 때문에 이 함수가 작동합니다. 하지만 디스패치 함수는 원하는 만큼 정교하게 만들 수 있습니다:")]),e._v(" "),t("p",[e._v("Above, the dispatch function uses a keyword to select the appropriate method to handle each type of map. This works because keywords act as functions and when passed a map will return the value associated with them. The dispatch function can be as sophisticated as we like however:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(defmulti encounter\n  (fn [x y] [(:role x) (:role y)]))\n\n(defmethod encounter [:manager :boss] [x y]\n  :promise-unrealistic-deadlines)\n\n(defmethod encounter [:manager :developer] [x y]\n  :demand-overtime)\n\n(defmethod encounter [:developer :developer] [x y]\n  :complain-about-poor-management)\n\n(encounter {:role :manager} {:role :boss})\n=> :promise-unrealistic-deadlines\n")])])]),t("h3",{attrs:{id:"프로토콜-protocols"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#프로토콜-protocols"}},[e._v("#")]),e._v(" 프로토콜(Protocols)")]),e._v(" "),t("p",[e._v("프로토콜을 사용하면 구체적인 유형으로 구현할 수 있는 추상적인 함수 집합을 정의할 수 있습니다. 프로토콜의 예를 살펴보겠습니다:")]),e._v(" "),t("p",[e._v("Protocols allow defining an abstract set of functions that can be implemented by a concrete type. Let's look at an example protocol:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defprotocol Foo\n  "Foo doc string"\n  (bar [this b] "bar doc string")\n  (baz [this] [this b] "baz doc string"))\n')])])]),t("p",[e._v("보시다시피, "),t("code",[e._v("Foo")]),e._v(" 프로토콜은 "),t("code",[e._v("bar")]),e._v("와 "),t("code",[e._v("baz")]),e._v("라는 두 가지 메서드를 지정합니다. 메서드의 첫 번째 인자는 타입 인스턴스이고 그 뒤에 매개변수가 있습니다. 바즈` 메서드에는 여러 개의 어리티가 있다는 점에 유의하세요. 이제 deftype 매크로를 사용해 Foo 프로토콜을 구현하는 타입을 만들 수 있습니다:")]),e._v(" "),t("p",[e._v("As you can see, the "),t("code",[e._v("Foo")]),e._v(" protocol specifies two methods, "),t("code",[e._v("bar")]),e._v(" and "),t("code",[e._v("baz")]),e._v(". The first argument to the method will be the type instance followed by its parameters. Note that the "),t("code",[e._v("baz")]),e._v(" method has multiple arity. We can now create a type that implements the Foo protocol using the deftype macro:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(deftype Bar [data] Foo\n  (bar [this param]\n    (println data param))\n  (baz [this]\n    (println (class this)))\n  (baz [this param]\n    (println param)))\n")])])]),t("p",[e._v("여기서는 프로토콜 "),t("code",[e._v("Foo")]),e._v("를 구현하는 "),t("code",[e._v("Bar")]),e._v(" 타입을 생성합니다. 이 타입의 각 메서드는 전달된 매개변수 중 일부를 출력합니다. Bar`의 인스턴스를 생성하고 그 메서드를 호출하면 어떤 모습인지 살펴봅시다:")]),e._v(" "),t("p",[e._v("Here we create type "),t("code",[e._v("Bar")]),e._v(" that implements protocol "),t("code",[e._v("Foo")]),e._v(". Each of its methods will print out some of the parameters passed to it. Let's see what it looks like when we create an instance of "),t("code",[e._v("Bar")]),e._v(" and call its methods:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(let [b (Bar. "some data")]\n  (.bar b "param")\n  (.baz b)\n  (.baz b "baz with param"))\n\n\nsome data param\nBar\nbaz with param\n')])])]),t("p",[e._v("첫 번째 메서드 호출은 "),t("code",[e._v("Bar")]),e._v("가 초기화된 데이터와 전달된 파라미터를 출력합니다. 두 번째 메서드 호출은 객체의 클래스를 출력하고, 마지막 메서드 호출은 baz의 다른 기능을 보여줍니다.")]),e._v(" "),t("p",[e._v("The first method call prints out the data "),t("code",[e._v("Bar")]),e._v(" was initialized with and the parameter that was passed in. The second method call prints out the object's class, while the last method call demonstrates the other arity of baz.")]),e._v(" "),t("p",[e._v("프로토콜을 사용하여 기존 Java 클래스를 포함한 기존 유형의 기능을 확장할 수도 있습니다. 예를 들어 extend-protocol을 사용하여 "),t("code",[e._v("java.lang.String")]),e._v(" 클래스를 "),t("code",[e._v("Foo")]),e._v(" 프로토콜로 확장할 수 있습니다:")]),e._v(" "),t("p",[e._v("We can also use protocols to extend the functionality of existing types, including existing Java classes. For example, we can use extend-protocol to extend the "),t("code",[e._v("java.lang.String")]),e._v(" class with the "),t("code",[e._v("Foo")]),e._v(" protocol:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(extend-protocol Foo String\n  (bar [this param] (println this param)))\n\n(bar "hello" "world")\n=>"hello world"\n')])])]),t("p",[e._v("위의 예시는 프로토콜을 사용해 다형성 코드를 작성하는 방법의 기본 원칙을 보여줍니다. 하지만 프로토콜은 다른 용도로도 많이 사용되므로 직접 찾아보시기를 권장합니다.")]),e._v(" "),t("p",[e._v("The above examples illustrate the basic principles of how protocols can be used to write polymorphic code. However, there are many other uses for protocols as well and I encourage you to discover these on your own.")]),e._v(" "),t("h2",{attrs:{id:"글로벌-상태-처리-dealing-with-global-state"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#글로벌-상태-처리-dealing-with-global-state"}},[e._v("#")]),e._v(" 글로벌 상태 처리(Dealing With Global State)")]),e._v(" "),t("p",[e._v("주로 불변성이지만, 클로저는 표준 라이브러리의 STM 함수를 통해 공유 가변 데이터에 대한 지원을 제공합니다. STM은 공유 가변 변수에 대한 모든 업데이트가 원자 단위로 이루어지도록 하는 데 사용됩니다.")]),e._v(" "),t("p",[e._v("While predominantly immutable, Clojure provides support for shared mutable data via its STM functions in the standard library. The STM is used to ensure that all updates to shared mutable variables are done atomically.")]),e._v(" "),t("p",[e._v("가변 변수는 크게 두 가지 유형이 있습니다: "),t("code",[e._v("atom")]),e._v("과 "),t("code",[e._v("ref")]),e._v(". "),t("code",[e._v("atom")]),e._v("(원자)는 조정되지 않은 업데이트를 수행해야 하는 경우에 사용되며, "),t("code",[e._v("참조")]),e._v("는 트랜잭션으로 여러 번 업데이트해야 할 때 사용됩니다. "),t("code",[e._v("atom")]),e._v("를 정의하고 사용하는 예를 살펴봅시다.")]),e._v(" "),t("p",[e._v("There are two primary mutable types: the "),t("code",[e._v("atom")]),e._v(" and the "),t("code",[e._v("ref")]),e._v(". The "),t("code",[e._v("atom")]),e._v(" is used in cases where we need to do uncoordinated updates and the "),t("code",[e._v("ref")]),e._v(" is used when we might need to do multiple updates as a transaction. Let's look at an example of defining an "),t("code",[e._v("atom")]),e._v(" and using it.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(def global-val (atom nil))\n")])])]),t("p",[e._v("위에서 'global-val'이라는 'atom'(원자)를 만들었고 현재 값은 'nil'입니다. 이제 현재 값을 반환하는 "),t("code",[e._v("deref")]),e._v(" 함수를 사용하여 그 값을 읽을 수 있습니다.")]),e._v(" "),t("p",[e._v("Above, we created an "),t("code",[e._v("atom")]),e._v(" called "),t("code",[e._v("global-val")]),e._v(" and its current value is "),t("code",[e._v("nil")]),e._v(". We can now read its value by using the "),t("code",[e._v("deref")]),e._v(" function, which returns the current value.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(println (deref global-val)) => nil\n")])])]),t("p",[e._v("이 작업은 일반적인 작업이므로 "),t("code",[e._v("deref")]),e._v("의 약어인 "),t("code",[e._v("@")]),e._v(" 기호가 있습니다:")]),e._v(" "),t("p",[e._v("Since this is a common operation, there is a shorthand for "),t("code",[e._v("deref")]),e._v(": the "),t("code",[e._v("@")]),e._v(" symbol:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(println @global-val)\n")])])]),t("p",[e._v("위의 코드는 앞의 예제와 동일합니다.")]),e._v(" "),t("p",[e._v("The above code is equivalent to the preceding example.")]),e._v(" "),t("p",[e._v("원자"),t("code",[e._v("에 새 값을 설정하는 두 가지 방법을 살펴봅시다. reset!")]),e._v("을 사용해 새 값을 전달하거나, "),t("code",[e._v("swap!")]),e._v("을 사용해 현재 값을 업데이트하는 데 사용할 함수를 전달할 수 있습니다.")]),e._v(" "),t("p",[e._v("Let's look at two ways of setting a new value for our "),t("code",[e._v("atom")]),e._v(". We can either use "),t("code",[e._v("reset!")]),e._v(" and pass in the new value, or we can use "),t("code",[e._v("swap!")]),e._v(" and pass in a function that will be used to update the current value.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(reset! global-val 10) (println @global-val) =>10\n\n(swap! global-val inc) (println @global-val) =>11\n")])])]),t("p",[t("code",[e._v("swap!")]),e._v("과 "),t("code",[e._v("reset!")]),e._v(" 모두 느낌표 "),t("code",[e._v("!")]),e._v("로 끝나는데, 이는 이 함수가 변경 가능한 데이터를 수정한다는 것을 나타내기 위한 규칙입니다.")]),e._v(" "),t("p",[e._v("Note that both "),t("code",[e._v("swap!")]),e._v(" and "),t("code",[e._v("reset!")]),e._v(" end in an exclamation point "),t("code",[e._v("!")]),e._v("; this is a convention to indicate that these functions modify mutable data.")]),e._v(" "),t("p",[e._v("참조를 정의하는 방식은 원자를 정의하는 방식과 같지만, 이 둘은 다소 다르게 사용됩니다. 아래에서 어떻게 작동하는지 간단히 살펴보겠습니다.")]),e._v(" "),t("p",[e._v("We define refs the same way we define atoms, but the two are used rather differently. Let's take a quick look at how they work below.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(def names (ref []))\n\n(dosync\n  (ref-set names ["John"])\n  (alter names #(if (not-empty %)\n                  (conj % "Jane") %)))\n')])])]),t("p",[e._v("이 코드에서는 "),t("code",[e._v("names")]),e._v("라는 "),t("code",[e._v("ref")]),e._v("를 정의한 다음 "),t("code",[e._v("dosync")]),e._v(" 문을 사용하여 트랜잭션을 엽니다. 트랜잭션 내에서 "),t("code",[e._v("names")]),e._v("를 "),t("code",[e._v('"John"')]),e._v(" 값을 가진 벡터로 설정합니다. 다음으로 "),t("code",[e._v("alter")]),e._v("를 호출하여 "),t("code",[e._v("names")]),e._v("가 비어 있지 않은지 확인하고, 비어 있으면 "),t("code",[e._v('"Jane"')]),e._v("을 이름 벡터에 추가합니다.")]),e._v(" "),t("p",[e._v("In this code, we define a "),t("code",[e._v("ref")]),e._v(" called "),t("code",[e._v("names")]),e._v(", then open a transaction using the "),t("code",[e._v("dosync")]),e._v(" statement. Inside the transaction we set "),t("code",[e._v("names")]),e._v(" to a vector with the value "),t("code",[e._v('"John"')]),e._v(". Next, we call "),t("code",[e._v("alter")]),e._v(" to check if "),t("code",[e._v("names")]),e._v(" is not empty and add "),t("code",[e._v('"Jane"')]),e._v(" to the vector of the names if that's the case.")]),e._v(" "),t("p",[e._v("이 작업은 트랜잭션 내부에서 이루어지므로 비어 있는지 확인하는 것은 기존 상태와 동일한 트랜잭션 내에 구축된 모든 상태에 따라 달라진다는 점에 유의하세요. 다른 트랜잭션에서 이름을 추가하거나 제거하려고 하면 우리 트랜잭션에는 아무런 영향을 미치지 않습니다. 충돌이 발생하면 트랜잭션 중 하나가 다시 시도됩니다.")]),e._v(" "),t("p",[e._v("Note that since this is happening inside a transaction, the check for emptiness depends on the existing state along with any state built up within the same transaction. If we tried to add or remove a name in a different transaction, it would have no visible effect on ours. In case of a collision, one of the transactions would end up being retried.")]),e._v(" "),t("h2",{attrs:{id:"코드를-작성하는-코드-작성-writing-code-that-writes-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#코드를-작성하는-코드-작성-writing-code-that-writes-code"}},[e._v("#")]),e._v(" 코드를 작성하는 코드 작성(Writing Code That Writes Code)")]),e._v(" "),t("p",[e._v("Lisp와 마찬가지로 Clojure는 강력한 매크로 시스템을 제공합니다. 매크로를 사용하면 반복적인 코드 블록을 템플릿화하고 평가를 연기하는 등 다양한 용도로 사용할 수 있습니다. 매크로는 코드를 평가하는 대신 데이터로 취급하는 방식으로 작동합니다. 따라서 다른 데이터 구조와 마찬가지로 코드 트리를 조작할 수 있습니다.")]),e._v(" "),t("p",[e._v("Clojure, being a Lisp, provides a powerful macro system. Macros allow templating repetitive blocks of code and deferring evaluation, among numerous other uses. A macro works by treating code as data instead of evaluating it. This allows us to manipulate the code tree just like any other data structure.")]),e._v(" "),t("p",[e._v("매크로는 평가 시간 전에 실행되며 평가자는 매크로 실행 결과를 볼 수 있습니다. 이러한 수준의 간접성 때문에 매크로는 추론하기 어려울 수 있으므로 함수가 작업을 수행할 때는 매크로를 사용하지 않는 것이 가장 좋습니다.")]),e._v(" "),t("p",[e._v("Macros execute before evaluation time and the evaluator sees the result of macro execution. Because of this level of indirection, macros can be difficult to reason about, and thus it's best not to use them when a function will do the job.")]),e._v(" "),t("p",[e._v("매크로의 구체적인 예를 통해 앞서 살펴본 일반 코드와 매크로가 어떻게 다른지 살펴보겠습니다. 사용자를 포함할 수 있는 세션 아톰이 있는 웹 애플리케이션이 있다고 가정해 보겠습니다. 사용자가 세션에 있을 때만 특정 콘텐츠를 로드하고 그렇지 않은 경우에는 로드하지 않으려 할 수 있습니다.")]),e._v(" "),t("p",[e._v("Let's look at a concrete example of a macro and see how it differs from the regular code we saw previously. Imagine that we have a web application with a session atom that might contain a user. We might want to load certain content only if a user is present in the session and not otherwise.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(def session (atom {:user "Bob"}))\n\n(defn load-content []\n  (if (:user @session)\n    "Welcome back!"\n    "please log in"))\n')])])]),t("p",[e._v("이 방법은 작동하지만 매번 "),t("code",[e._v("if")]),e._v(" 문을 작성하는 것은 지루하고 오류가 발생하기 쉽습니다. 조건의 로직은 동일하게 유지되므로 이 함수를 다음과 같이 템플릿화할 수 있습니다:")]),e._v(" "),t("p",[e._v("This will work, but it's tedious and error-prone to write out the "),t("code",[e._v("if")]),e._v(" statement every single time. Since our condition's logic stays the same, we can template this function as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defmacro defprivate [name args & body]\n  `(defn ~(symbol name) ~args\n     (if (:user @session)\n       (do ~@body)\n       "please log in")))\n')])])]),t("p",[e._v("매크로는 "),t("code",[e._v("defmacro")]),e._v(" 특수 형식을 사용하여 정의됩니다. "),t("code",[e._v("defn")]),e._v("과 "),t("code",[e._v("defmacro")]),e._v("의 가장 큰 차이점은 "),t("code",[e._v("defmacro")]),e._v("에 전달된 매개변수는 기본적으로 평가되지 않는다는 것입니다.")]),e._v(" "),t("p",[e._v("The macros are defined using the "),t("code",[e._v("defmacro")]),e._v(" special form. The major difference between "),t("code",[e._v("defn")]),e._v(" and "),t("code",[e._v("defmacro")]),e._v(" is that the parameters passed to "),t("code",[e._v("defmacro")]),e._v(" are not evaluated by default.")]),e._v(" "),t("p",[e._v("매개변수를 평가하려면 "),t("code",[e._v("~(기호 이름)")]),e._v("에서와 같이 "),t("code",[e._v("~")]),e._v("를 사용합니다. '~` 표기법을 사용하면 이름이 참조하는 값으로 이름을 바꾸고 싶다는 것을 나타냅니다. 이를 인용 취소라고 합니다.")]),e._v(" "),t("p",[e._v("To evaluate the parameter we use the "),t("code",[e._v("~")]),e._v(", as we're doing with "),t("code",[e._v("~(symbol name)")]),e._v(". Using the "),t("code",[e._v("~")]),e._v(" notation indicates that we'd like to replace the name with the value it refers to. This is called unquoting.")]),e._v(" "),t("p",[t("code",[e._v("(do ~@body)")]),e._v("에서 사용되는 "),t("code",[e._v("~@")]),e._v(" 표기법을 따옴표 제거라고 합니다. 이 표기법은 시퀀스를 다룰 때 사용됩니다. 시퀀스의 내용은 접합하는 동안 외부 형태로 병합됩니다. 이 경우 본문은 함수의 본문을 나타내는 목록으로 구성됩니다. "),t("code",[e._v("if")]),e._v(" 문은 인수가 3개 이하여야 하므로 본문은 "),t("code",[e._v("do")]),e._v(" 블록으로 감싸야 합니다.")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("~@")]),e._v(" notation used in "),t("code",[e._v("(do ~@body)")]),e._v(" is called unquote splicing. This notation is used when we're dealing with a sequence. The contents of the sequence will be merged into the outer form during the splicing. In this case the body consists of a list representing the function's body. The body must be wrapped in a "),t("code",[e._v("do")]),e._v(" block because the "),t("code",[e._v("if")]),e._v(" statement requires having no more than three arguments.")]),e._v(" "),t("p",[t("code",[e._v("`")]),e._v(" 기호는 다음 목록을 실행하는 대신 데이터로 취급한다는 의미입니다. 이것은 인용 해제와 반대되는 것으로 구문 인용이라고 합니다.")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("`")]),e._v(" sign means that we wish to treat the following list as data instead of executing it. This is the opposite of unquoting, and it's referred to as syntax-quoting.")]),e._v(" "),t("p",[e._v("앞서 언급했듯이 매크로는 평가 시간 전에 실행됩니다. 평가자가 매크로를 볼 때 매크로가 어떻게 재작성되는지 확인하려면 "),t("code",[e._v("macroexpand-1")]),e._v("을 호출하면 됩니다.")]),e._v(" "),t("p",[e._v("앞서 언급했듯이 매크로는 평가 시간 전에 실행됩니다. 평가자가 매크로를 볼 때 매크로가 어떻게 재작성되는지 확인하려면 "),t("code",[e._v("macroexpand-1")]),e._v("을 호출하면 됩니다.")]),e._v(" "),t("p",[e._v("As I mentioned earlier, the macros are executed before evaluation time. To see what the macro will be rewritten as when the evaluator sees it, we can call "),t("code",[e._v("macroexpand-1")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(macroexpand-1 \'(defprivate foo [greeting] (println greeting)))\n\n(clojure.core/defn foo [greeting]\n  (if (:user (clojure.core/deref session))\n    (do (println greeting))\n    "please log in"))\n')])])]),t("p",[t("code",[e._v('(defprivate foo (println "bar"))')]),e._v("가 내부에 "),t("code",[e._v("if")]),e._v(" 문이 포함된 함수 정의로 재작성되는 것을 볼 수 있습니다. 이 결과 코드는 평가자에게 표시되는 코드이며, 그렇지 않으면 우리가 직접 작성해야 하는 코드와 동일합니다. 이제 매크로를 사용하여 비공개 함수를 간단히 정의할 수 있으며, 매크로가 자동으로 검사를 수행합니다.")]),e._v(" "),t("p",[e._v("We can see that "),t("code",[e._v('(defprivate foo (println "bar"))')]),e._v(" gets rewritten with a function definition that has the "),t("code",[e._v("if")]),e._v(" statement inside. This resulting code is what the evaluator will see, and it's equivalent to what we would have to write by hand otherwise. Now we can simply define a private function using our macro, and it will do the check for us automatically.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(defprivate foo [message] (println message))\n\n(foo "this message is private")\n')])])]),t("p",[e._v("앞의 예는 다소 인위적으로 보일 수 있지만, 코드에서 반복을 쉽게 템플릿화할 수 있다는 것이 얼마나 강력한지 보여줍니다. 이를 통해 문제 도메인을 자연스러운 언어를 사용하여 표현하는 표기법을 만들 수 있습니다.")]),e._v(" "),t("p",[e._v("The preceding example might seem a little contrived, but it demonstrates the power of being able to easily template repetitions in code. This allows creating a notation that expresses your problem domain using the language that is natural to it.")]),e._v(" "),t("h2",{attrs:{id:"읽기-평가-출력-루프-the-read-evaluate-print-loop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#읽기-평가-출력-루프-the-read-evaluate-print-loop"}},[e._v("#")]),e._v(" 읽기-평가-출력 루프(The Read-Evaluate-Print Loop)")]),e._v(" "),t("p",[e._v("Clojure에서 작업할 때 가장 중요한 또 다른 측면은 읽기-평가-출력 루프(REPL)입니다. 많은 언어에서는 코드를 작성한 다음 전체 프로그램을 실행하여 어떤 동작을 하는지 확인합니다. Clojure에서는 대부분의 개발이 REPL을 사용하여 대화형으로 이루어집니다. 이 모드에서는 작성한 각 코드가 작성되는 즉시 작동하는 것을 볼 수 있습니다.")]),e._v(" "),t("p",[e._v("Another big aspect of working in Clojure is the read-evaluate-print loop (REPL). In many languages you write the code, then run the entire program to see what it does. In Clojure, most development is done interactively using the REPL. In this mode we can see each piece of code we write in action as soon as it's written.")]),e._v(" "),t("p",[e._v("중요하지 않은 애플리케이션에서는 더 많은 기능을 추가하기 전에 특정 상태를 구축해야 하는 경우가 많습니다. 예를 들어 사용자가 로그인하여 데이터베이스에서 일부 데이터를 쿼리한 다음 이 데이터의 형식을 지정하고 표시하는 함수를 작성해야 하는 경우입니다. REPL을 사용하면 애플리케이션을 변경할 때마다 애플리케이션을 다시 로드하고 상태를 빌드할 필요 없이 데이터가 로드되는 상태로 애플리케이션을 가져온 다음 대화형으로 표시 로직을 작성할 수 있습니다.")]),e._v(" "),t("p",[e._v("In nontrivial applications it's often necessary to build up a particular state before you can add more functionality. For example, a user has to log in and query some data from the database, then you need to write functions to format and display this data. With a REPL you can get the application to the state where the data is loaded and then write the display logic interactively without having to reload the application and build up the state every time you make a change.")]),e._v(" "),t("p",[e._v("이 개발 방법은 변경 시 즉각적인 피드백을 확인할 수 있어 특히 만족도가 높습니다. 쉽게 시도해보고 해결하려는 문제에 어떤 접근 방식이 가장 적합한지 확인할 수 있습니다. 이를 통해 실험을 계속하고 코드를 리팩터링할 수 있으므로 더 깔끔한 코드를 작성하는 데 도움이 됩니다.")]),e._v(" "),t("p",[e._v("This method of development is particularly satisfying because you see immediate feedback when making changes. You can easily try things out and see what approach works best for the problem you're solving. This encourages experimentation and refactoring code as you go, which in turn helps you to write better and cleaner code.")]),e._v(" "),t("h2",{attrs:{id:"java로-호출하기-calling-out-to-java"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java로-호출하기-calling-out-to-java"}},[e._v("#")]),e._v(" Java로 호출하기 (Calling Out to Java)")]),e._v(" "),t("p",[e._v("One last thing that we'll cover is how Clojure embraces its host platform to benefit from the rich ecosystem of existing Java libraries. In some cases we may wish to call a Java library to accomplish a particular task that doesn't have a native Clojure implementation. Calling Java classes is very simple, and follows the standard Clojure syntax fairly closely.")]),e._v(" "),t("h3",{attrs:{id:"클래스-가져오기-importing-classes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#클래스-가져오기-importing-classes"}},[e._v("#")]),e._v(" 클래스 가져오기 (Importing Classes)")]),e._v(" "),t("p",[e._v("마지막으로 다룰 마지막 내용은 기존 Java 라이브러리의 풍부한 에코시스템의 이점을 활용하기 위해 Clojure가 호스트 플랫폼을 수용하는 방법입니다. 어떤 경우에는 네이티브 Clojure 구현이 없는 특정 작업을 수행하기 위해 Java 라이브러리를 호출해야 할 수도 있습니다. Java 클래스를 호출하는 것은 매우 간단하며 표준 Clojure 구문을 매우 가깝게 따릅니다.")]),e._v(" "),t("p",[e._v("When we wish to use a Clojure namespace, we employ either the "),t("code",[e._v(":use")]),e._v(" or the "),t("code",[e._v(":require")]),e._v(" statements discussed above. However, when we wish to import a Java class, we have to use the "),t("code",[e._v(":import")]),e._v(" statement instead:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(ns myns\n  (:import java.io.File))\n")])])]),t("p",[e._v("또한 다음과 같이 한 번의 임포트에서 동일한 패키지의 여러 클래스를 그룹화할 수도 있습니다:")]),e._v(" "),t("p",[e._v("We can also group multiple classes from the same package in a single import, as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("(ns myns\n  (:import [java.io File FileInputStream FileOutputStream]))\n")])])]),t("h3",{attrs:{id:"클래스-인스턴스화-instantiating-classes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#클래스-인스턴스화-instantiating-classes"}},[e._v("#")]),e._v(" 클래스 인스턴스화(Instantiating Classes)")]),e._v(" "),t("p",[e._v("클래스의 인스턴스를 생성하려면 Java에서와 마찬가지로 new를 호출하면 됩니다:")]),e._v(" "),t("p",[e._v("To create an instance of a class, we can call new just as we would in Java:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(new File ".")\n')])])]),t("p",[e._v("객체를 인스턴스화할 때 일반적으로 사용되는 속기도 있습니다:")]),e._v(" "),t("p",[e._v("There is also a commonly used shorthand for instantiating objects:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(File. ".")\n')])])]),t("h3",{attrs:{id:"메소드-호출하기-calling-methods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#메소드-호출하기-calling-methods"}},[e._v("#")]),e._v(" 메소드 호출하기(Calling Methods)")]),e._v(" "),t("p",[e._v("클래스의 인스턴스가 생기면 메서드 호출을 시작할 수 있습니다. 표기법은 일반 함수 호출과 비슷합니다. 메서드를 호출할 때 첫 번째 매개변수로 객체를 전달한 다음 메서드가 허용하는 다른 매개변수를 전달합니다.")]),e._v(" "),t("p",[e._v("Once we have an instance of a class, we can start calling methods on it. The notation is similar to making a regular function call. When we call a method, we pass the object as its first parameter followed by any other parameters that the method accepts.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(let [f (File. ".")]\n  (println (.getAbsolutePath f)))\n')])])]),t("p",[e._v("위에서는 새 파일 객체 "),t("code",[e._v("f")]),e._v("를 생성한 다음 그 위에 "),t("code",[e._v(".getAbsolutePath")]),e._v(" 메서드를 호출했습니다. 메서드 앞에 마침표 "),t("code",[e._v(".")]),e._v("가 붙어서 일반 클로저 함수와 구분되는 것을 알 수 있습니다. 클래스의 정적 메서드나 변수를 참조하려면 대신 "),t("code",[e._v("/")]),e._v(" 표기법을 사용합니다:")]),e._v(" "),t("p",[e._v("Above, we created a new file object "),t("code",[e._v("f")]),e._v(", and then called the "),t("code",[e._v(".getAbsolutePath")]),e._v(" method on it. Notice that methods have a period "),t("code",[e._v(".")]),e._v(" in front of them to differentiate them from a regular Clojure function. If we wanted to reference a static method or a variable in a class, we would use the "),t("code",[e._v("/")]),e._v(" notation instead:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(str File/separator "foo" File/separator "bar")\n\n(Math/sqrt 256)\n')])])]),t("p",[e._v("'..` 표기법을 사용하여 여러 메서드 호출을 함께 연결하는 속기법도 있습니다. 파일 경로를 나타내는 문자열을 가져온 다음 해당 바이트를 가져오고 싶다고 가정하면, 두 가지 방법으로 코드를 작성할 수 있습니다.")]),e._v(" "),t("p",[e._v("There's also a shorthand for chaining multiple method calls together using the "),t("code",[e._v("..")]),e._v(" notation. Say we wanted to get the string indicating the file path and then get its bytes; we could write the code for that in two ways.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('(.getBytes (.getAbsolutePath (File. ".")))\n\n(.. (File. ".") getAbsolutePath getBytes)\n')])])]),t("h2",{attrs:{id:"추가-읽기-further-reading"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#추가-읽기-further-reading"}},[e._v("#")]),e._v(" 추가 읽기 (Further Reading)")]),e._v(" "),t("p",[e._v("이것으로 클로저 기초에 대한 설명을 마쳤습니다. 전체 언어의 일부분만 다루었지만, 이 가이드를 통해 관용적인 Clojure 코드가 어떻게 작성되는지에 대한 약간의 통찰력을 얻으셨기를 바랍니다. 다음은 언어에 대한 보다 심층적인 문서에 대한 몇 가지 유용한 링크입니다.")]),e._v(" "),t("p",[e._v("This concludes our tour of Clojure basics. While we only touched on only a small portion of the overall language, I hope that the guide has provided you with a bit of insight into how idiomatic Clojure code is written. Below are some useful links for more in-depth documentation about the language.")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://clojure.org/guides/getting_started",target:"_blank",rel:"noopener noreferrer"}},[e._v("Official Clojure documentation"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://www.braveclojure.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure for the Brave and True"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://aphyr.com/posts/301-clojure-from-the-ground-up-welcome",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure from the ground up"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://clojure-doc.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Community Clojure documentation site"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://grimoire.arrdem.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure API documentation"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://clojure.org/cheatsheet",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure cheatsheet"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/bbatsov/clojure-style-guide",target:"_blank",rel:"noopener noreferrer"}},[e._v("Clojure style guide"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("Copyright © 2023 Dmitri Sotnikov")]),e._v(" "),t("p",[e._v("번역: damulhan@gmail.com, 파파고 등")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://yogthos.net/ClojureDistilled.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("원문: Dmitri Sotnikov 블로그"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);