(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{297:function(e,t,a){e.exports=a.p+"assets/img/00.00.00.70bf7b0f.jpg"},298:function(e,t,a){e.exports=a.p+"assets/img/00.01.13.e1dfe658.jpg"},299:function(e,t,a){e.exports=a.p+"assets/img/00.02.11.b9593834.jpg"},300:function(e,t,a){e.exports=a.p+"assets/img/00.03.32.ee52bd6e.jpg"},301:function(e,t,a){e.exports=a.p+"assets/img/00.04.12.300356b2.jpg"},302:function(e,t,a){e.exports=a.p+"assets/img/00.06.37.777a4c15.jpg"},303:function(e,t,a){e.exports=a.p+"assets/img/00.07.35.98a3d12e.jpg"},304:function(e,t,a){e.exports=a.p+"assets/img/00.09.05.575b17ea.jpg"},305:function(e,t,a){e.exports=a.p+"assets/img/00.10.47.1eb61d80.jpg"},306:function(e,t,a){e.exports=a.p+"assets/img/00.11.36.b9182d33.jpg"},307:function(e,t,a){e.exports=a.p+"assets/img/00.13.24.0ae13c0e.jpg"},308:function(e,t,a){e.exports=a.p+"assets/img/00.15.52.067c71a2.jpg"},309:function(e,t,a){e.exports=a.p+"assets/img/00.17.20.ef116c0d.jpg"},310:function(e,t,a){e.exports=a.p+"assets/img/00.19.15.f5cff654.jpg"},311:function(e,t,a){e.exports=a.p+"assets/img/00.20.09.fc0694e3.jpg"},312:function(e,t,a){e.exports=a.p+"assets/img/00.22.00.c60df3e8.jpg"},313:function(e,t,a){e.exports=a.p+"assets/img/00.23.49.e4ebe8a2.jpg"},314:function(e,t,a){e.exports=a.p+"assets/img/00.26.57.011b0e5f.jpg"},315:function(e,t,a){e.exports=a.p+"assets/img/00.30.06.5cec0e6e.jpg"},316:function(e,t,a){e.exports=a.p+"assets/img/00.30.48.269ce4c9.jpg"},317:function(e,t,a){e.exports=a.p+"assets/img/00.32.40.4ef4b73b.jpg"},318:function(e,t,a){e.exports=a.p+"assets/img/00.34.05.4ed1309b.jpg"},319:function(e,t,a){e.exports=a.p+"assets/img/00.34.53.b4c6505e.jpg"},320:function(e,t,a){e.exports=a.p+"assets/img/00.35.57.e257741a.jpg"},321:function(e,t,a){e.exports=a.p+"assets/img/00.40.17.f774760c.jpg"},322:function(e,t,a){e.exports=a.p+"assets/img/00.41.45.054ba22c.jpg"},323:function(e,t,a){e.exports=a.p+"assets/img/00.42.25.2240ff29.jpg"},324:function(e,t,a){e.exports=a.p+"assets/img/00.43.18.e50390b6.jpg"},325:function(e,t,a){e.exports=a.p+"assets/img/00.44.15.e59e44af.jpg"},326:function(e,t,a){e.exports=a.p+"assets/img/00.46.24.468e9aab.jpg"},327:function(e,t,a){e.exports=a.p+"assets/img/00.47.40.f534911a.jpg"},328:function(e,t,a){e.exports=a.p+"assets/img/00.49.33.b5c6f8a3.jpg"},329:function(e,t,a){e.exports=a.p+"assets/img/00.50.38.2e317003.jpg"},330:function(e,t,a){e.exports=a.p+"assets/img/00.51.40.80aa7547.jpg"},331:function(e,t,a){e.exports=a.p+"assets/img/00.52.27.55d42647.jpg"},332:function(e,t,a){e.exports=a.p+"assets/img/00.54.08.17d4d053.jpg"},333:function(e,t,a){e.exports=a.p+"assets/img/00.54.22.10b3d859.jpg"},334:function(e,t,a){e.exports=a.p+"assets/img/00.54.57.e1fd4dd5.jpg"},335:function(e,t,a){e.exports=a.p+"assets/img/00.55.51.e2aeacc9.jpg"},646:function(e,t,a){"use strict";a.r(t);var n=a(14),o=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"영구-데이터-구조-및-관리되는-참조-persistent-data-structures-and-managed-references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#영구-데이터-구조-및-관리되는-참조-persistent-data-structures-and-managed-references"}},[e._v("#")]),e._v(" 영구 데이터 구조 및 관리되는 참조 (Persistent Data Structures and Managed References)")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Speaker: Rich Hickey")])]),e._v(" "),t("li",[t("strong",[e._v("Conference: "),t("a",{attrs:{href:""}},[e._v("QCon")]),e._v(" - Oct 2009")])]),e._v(" "),t("li",[t("strong",[e._v("Video: "),t("a",{attrs:{href:"http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey"),t("OutboundLink")],1)])])]),e._v(" "),t("blockquote",[t("p",[e._v('[Google Bard 요약] Rich Hickey는 2009년 10월 1일 "Persistent Data Structures"라는 제목의 강연을 했습니다. 이 강연에서 Hickey는 영구 데이터 구조의 개념과 장점에 대해 설명했습니다. 영구 데이터 구조는 변경할 수 없는 데이터 구조로, 변경할 때마다 새 데이터 구조를 생성합니다. 이로 인해 영구 데이터 구조는 변경할 수 있는 데이터 구조보다 효율적이고 안전합니다. Hickey는 또한 영구 데이터 구조를 구현하는 데 사용할 수 있는 몇 가지 도구와 라이브러리에 대해 설명했습니다.')]),e._v(" "),t("p",[e._v("다음은 Hickey의 강연에서 다룬 주요 내용입니다.")]),e._v(" "),t("ul",[t("li",[e._v("영구 데이터 구조는 변경할 수 없는 데이터 구조입니다.")]),e._v(" "),t("li",[e._v("영구 데이터 구조는 변경할 수 있는 데이터 구조보다 효율적이고 안전합니다.")]),e._v(" "),t("li",[e._v("영구 데이터 구조를 구현하는 데 사용할 수 있는 몇 가지 도구와 라이브러리가 있습니다.")])])]),e._v(" "),t("p",[e._v("[Time 0:00:00]")]),e._v(" "),t("p",[t("img",{attrs:{src:a(297),alt:"00.00.00 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("함수형 프로그래밍 언어로 프로그래밍하는 사람이 몇 명이나 될까요? 좋아요, 회심자에게 반쯤 설교를 한 셈이군요. 함수형 프로그래밍 언어가 아니라면요? 함수형 프로그래밍 언어가 아니라면요? 여전히 많이 있습니다.")]),e._v(" "),t("p",[e._v("저는 이것이 두 청중 모두에게 유용할 것이라고 생각합니다. 특히 함수형 프로그래밍 언어가 아닌 경우, 사실 상태 표현 방식에 대한 완전한 스토리를 가지고 있는 Erlang이 아닌 경우, 다른 모든 함수형 프로그래밍 언어에는 두 가지 측면이 있습니다. 이 기능적인 부분이 있고... 그리고... 그리고.")]),e._v(" "),t("p",[e._v("하스켈은 타입 시스템이 이 부분을 순수하게 유지하는 아름다운 측면이 있습니다. 그리고 또 다른 측면은 '이렇게 해라, 저렇게 해라'와 같이 명령적인 부분이 있습니다. 그리고 그 쪽에 상태가 필요할 때를 대비해 기능을 제공하는 구조체가 많이 있습니다.")]),e._v(" "),t("p",[e._v('마찬가지로 스칼라나 F#과 같은 "하이브리드" 함수형 언어도 많이 있는데, 여기서 질문해야 할 부분이 있다고 생각합니다: 여기까지가 순수한 부분인데, 다른 부분은 어떤 이야기일까요?')]),e._v(" "),t("p",[e._v("How many people program in a functional programming language?  OK, so halfway preaching to the converted.  And not in a functional programming language?  A non-functional programming language?  So still a lot of that.")]),e._v(" "),t("p",[e._v("I think this will be useful to both audiences.  In particular if you\nare not in a functional programming language, in fact if you are not\nin Erlang, which I think has a complete story for how they do state,\nall the other functional programming languages have two aspects.  They\nhave this functional part, and then ... and then.")]),e._v(" "),t("p",[e._v("Haskell has this beautiful side where the type system keeps this part\npure.  And then there is the other part which is kind of imperative:\ndo this, do that.  And then they have a bunch of constructs to provide\nfacilities for when you need state on that side.")]),e._v(" "),t("p",[e._v('Similarly there are a lot of "hybrid" functional languages, like Scala\nand F#, where I think there are questions to be asked about: OK here\nis the pure part, what is the story about the other part?')]),e._v(" "),t("p",[e._v("[Time 0:01:13]")]),e._v(" "),t("h2",{attrs:{id:"agenda"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#agenda"}},[e._v("#")]),e._v(" Agenda")]),e._v(" "),t("p",[t("img",{attrs:{src:a(298),alt:"00.01.13 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그래서 오늘 제가 하고 싶은 이야기는 기능과 프로세스에 대해 이야기하고 이 둘을 구분하는 것입니다. 사실 이 강연의 핵심 개념은 아이덴티티, 상태, 값이 의미하는 바를 분석하고 이러한 개념을 분리하는 것입니다. 그리고 값으로 프로그래밍하는 것이 프로그램의 기능적인 부분에서는 매우 중요한 부분이지만, 실제로 상태를 관리하고 상황이 변화하는 것처럼 동작해야 하는 비기능적인 부분에서는 어떻게 중요한 부분이 되는지 살펴봅니다.")]),e._v(" "),t("p",[e._v("여기에는 두 가지 요소가 있습니다. 하나는 복합 객체를 값으로 어떻게 표현할 것인가입니다. 함수형 프로그래밍을 처음 접하는 많은 사람들이 효율성과 표현 문제에 대해 궁금해하는데, 이에 대해 이야기하겠습니다. 그리고 마지막으로 프로그램에서 상태와 변화를 다루는 한 가지 접근 방식에 대해 이야기할 것인데, 이는 제가 시작하려는 약간의 철학과 호환되는 클로저에서 사용하는 접근 방식입니다.")]),e._v(" "),t("p",[e._v("So what I want to do today is to talk about functions and processes,\nand to distinguish the two.  In fact, the core concept in this talk is\nto try to parse out what we mean by identity, state, and values; try\nto separate those concepts.  And see how programming with values,\nwhile a really important part of the functional part of your program,\nends up being a critical part of the non-functional part of your\nprogram, the part that actually has to manage state and behave as if\nthings are changing.")]),e._v(" "),t("p",[e._v("And there are two components to that.  One is: how do you represent\ncomposite objects as values?  A lot of people who are new to\nfunctional programming wonder about the efficiency and representation\nissues there, and I will talk about that.  And finally I will talk\nabout one approach to dealing with state and change in a program, the\none that Clojure uses, which is compatible with a little bit of\nphilosophy that I am going to start with.")]),e._v(" "),t("p",[e._v("[Time 0:02:11]")]),e._v(" "),t("h2",{attrs:{id:"clojure-fundamentals"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clojure-fundamentals"}},[e._v("#")]),e._v(" Clojure Fundamentals")]),e._v(" "),t("p",[t("img",{attrs:{src:a(299),alt:"00.02.11 PersistentDataStructure"}}),e._v("\n저는 클로저에 대해 별로 이야기하지 않으려고 합니다. 어제 제 강연에 몇 명이 참석했나요? 좋아요, 클로저에 대해 모르는 사람이 몇 명이나 있었나요? 좋아요. 이번 강연은 클로저에 관한 강연이 아닙니다. 나중에 코드가 좀 나올 겁니다. 너무 위협적이지 않아야 합니다. 이 한 장의 슬라이드로 클로저가 무엇인지 간단히 요약해 보겠습니다.")]),e._v(" "),t("p",[e._v("클로저는 동적 프로그래밍 언어입니다. 동적으로 입력됩니다. 기능적입니다. 특히 고차 함수를 지원하는 것뿐만 아니라 불변성을 강조하는 데 기능적입니다. 클로저의 모든 데이터 타입은 불변입니다.")]),e._v(" "),t("p",[e._v("동시성을 지원합니다. 이것은 두 부분으로 나뉩니다. 하나는 불변성과 순수 함수를 잘 지원해야 한다는 것입니다. 다른 하나는 한 번에 여러 가지 일이 일어나고 인식할 수 있는 변화가 있을 때를 대비한 스토리가 있어야 하는데, 클로저는 이를 지원합니다. 사실 기능적이라고 주장하는 언어에서 비기능적 부분에 대한 스토리를 갖는 것은 중요한 부분이라고 생각합니다.")]),e._v(" "),t("p",[e._v("클로저는 특별히 객체 지향적이지 않습니다. 이 강연을 듣고 나면 왜 그렇지 않은지 알 수 있는데, 현재 구현된 많은 객체 기술이 동시성과 함수형 프로그래밍에 직면했을 때 큰 문제를 가지고 있다고 생각하기 때문입니다. 그리고 앞서 말했듯이 개념적인 관점에서 볼 때 클로저에만 국한된 것은 아무것도 없습니다.")]),e._v(" "),t("p",[e._v("I am not really going to talk about Clojure very much.  How many\npeople were at my talk yesterday?  OK, how many people who were not\nknow something about Clojure?  OK.  This is not really a Clojure\nspecific talk.  There will be some code later.  It should not be too\nthreatening.  I am just going to summarize quickly with this one slide\nwhat Clojure is about.")]),e._v(" "),t("p",[e._v("It is a dynamic programming language.  It is dynamically typed.  It is\nfunctional.  In particular, it is functional in emphasizing\nimmutability, not just in supporting higher order functions.  All the\ndata types in Clojure are immutable.")]),e._v(" "),t("p",[e._v("It supports concurrency.  It is a two part story.  One is: you have to\nhave good support for immutability and pure functions.  The other part\nis: you have to have a story for when multiple things are happening at\na time and you are going to have some perceptible change, and Clojure\ndoes.  In fact, I think it is an important part of a language that\npurports to be functional to have a story about the non-functional\nparts.")]),e._v(" "),t("p",[e._v("Clojure is not particularly object oriented.  It may be clear after\nlistening to this talk why not, because I think as currently\nimplemented, a lot of object technologies have big problems when they\nface concurrency and functional programming.  And as I said, from a\nconceptual standpoint, nothing about this is really Clojure specific.")]),e._v(" "),t("p",[e._v("[Time 0:03:32]")]),e._v(" "),t("h2",{attrs:{id:"functions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[e._v("#")]),e._v(" Functions")]),e._v(" "),t("p",[t("img",{attrs:{src:a(300),alt:"00.03.32 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v('그렇다면 함수는 무엇을 의미할까요? "함수는 호출하는 것"이라고 아주 쉽게 말할 수 있지만, 여기서 말하는 함수는 그런 것이 아닙니다. 여기서 말하는 함수는 값을 인자로 받아 반환값으로 값을 생성하는 함수를 호출하는 매우 정확한 개념입니다. 동일한 인수가 주어지면 항상 동일한 값을 생성합니다.')]),e._v(" "),t("p",[e._v("외부 세계에 의존하지 않습니다. 나머지 세계에 영향을 주지 않습니다. 클래스의 많은 메서드가 이 정의에 따라 함수가 아니지만, 특히 순수 함수인 함수는 시간 개념이 없다는 사실을 강조하고 싶습니다. 이 강연을 통해 시간은 중요한 개념이 될 것입니다.")]),e._v(" "),t("p",[e._v('So what do we mean by functions?  I think that there is a really easy\nway to say, "Oh, a function is something that you call", and that is\n'),t("em",[e._v("not")]),e._v(" what we are talking about here.  We are talking about a very\nprecise notion of a function, which is something that you call that\ntakes values as arguments and produces a value as a return.  When it\nis given the same arguments, it always produces the same value.")]),e._v(" "),t("p",[e._v("It does not depend on the outside world.  It does not affect the rest\nof the world.  So many methods in your classes are not functions by\nthis definition, but in particular too, I want to highlight the fact\nthat function, pure functions, have no notion of time.  Time is going\nto be a critical notion through this talk.")]),e._v(" "),t("p",[e._v("[Time 0:04:12]")]),e._v(" "),t("h2",{attrs:{id:"functional-programming"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#functional-programming"}},[e._v("#")]),e._v(" Functional Programming")]),e._v(" "),t("p",[t("img",{attrs:{src:a(301),alt:"00.04.12 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그렇다면 함수형 프로그래밍이란 무엇일까요? 이 질문에는 많은 답이 있으며, 타입 시스템에 관심이 있는 사람들은 함수형 프로그래밍을 구성하는 요소에 대해 더 강력한 주장을 주장할 것이라고 생각합니다. 하지만 여기서는 함수를 사용한 프로그래밍을 강조하는 프로그래밍으로 정의를 제한하겠습니다. 따라서 가능한 한 많은 프로그램을 순수 함수로 작성하려고 노력해야 합니다. 그렇게 하면 많은 이점을 얻을 수 있습니다. 다른 강연에서도 다뤘던 내용입니다. 동시성이 없어도 프로그램이 더 이해하기 쉽고, 더 추론하기 쉽고, 더 테스트하기 쉽고, 더 모듈화된다는 것 외에는 이 강연의 초점이 아닙니다. 이 모든 것은 함수를 사용한 프로그래밍에서 가능한 한 많이 벗어날 수 있습니다.")]),e._v(" "),t("p",[e._v("반면에 한 발 물러서서 전체 프로그램을 살펴보면 전체적으로 함수로 된 프로그램은 거의 없습니다. 하나의 입력을 받아 생각하고 하나의 출력을 생성하는 프로그램은 거의 없습니다. 일부 컴파일러나 정리 증명기는 그런 식으로 작동할지 모르지만, 제가 작업해본 대부분의 실제 프로그램, 그리고 현실 세계의 대부분의 실제 프로그램은 그런 식으로 작동하지 않는다고 생각합니다.")]),e._v(" "),t("p",[e._v("특히, 프로그램이 완전히 작동한다고 주장하더라도 출력을 생성하는 경우 그렇지 않습니다. 그렇지 않으면 기계를 예열 할 뿐이기 때문입니다. 그러나 대부분 기능적이라 할지라도 순전히 기능적인 프로그램이 실행되면 관찰 가능한 효과가 있습니다. 컴퓨터에서 실행 중입니다. 컴퓨터에서 실행되는 즉시 더 이상 수학이 아닙니다. 컴퓨터에서 실행되는 프로그램입니다. 메모리를 소비하고 있습니다. 시계 주기를 소비하고 있습니다. 그것은 시간이 지남에 따라 관찰 가능하게 무언가를하고 있습니다. 따라서 모든 프로그램은 시간이 지남에 따라 작업을 수행합니다.")]),e._v(" "),t("p",[e._v("그러나 제가 말했듯이 대부분의 실제 프로그램은 실제로 컴퓨터에서 실행되고 있다는 사실뿐만 아니라 작업을 수행하는 관찰 가능한 동작을 가지고 있습니다. 그들은 외부 세계와 상호 작용하고 있습니다. 그들은 소켓을 통해 이야기하고 있습니다. 화면에 무언가를 넣고 있습니다. 데이터베이스에 무언가를 넣거나 뺍니다.")]),e._v(" "),t("p",[e._v('특히 상태를 정의하는 방법에 대해 한 가지 중요한 척도를 사용하겠습니다. 즉, 같은 질문을 두 번 했는데 다른 대답이 나오면 상태가 있는 것입니다. 어디에 넣어도 상관없습니다. 프로세스에 넣을 수도 있고 에이전트, 원자, 변수에 넣을 수도 있습니다. 데이터베이스에서는 중요하지 않습니다. 같은 질문을 두 번 하고 다른 시간에 다른 답을 얻는다면 상태가 있는 것입니다. 그래서 다시 "시간"이라는 단어가 다시 등장했습니다.')]),e._v(" "),t("p",[e._v("So what is functional programming?  There are lots of answers to this\nquestion, and I think people who are into type systems will claim a\nstronger argument for what constitutes functional programming.  But I\nam going to limit the definition here to programming that emphasizes\nprogramming with functions.  So you want to try to write as much of\nyour program as you can with pure functions.  When you do that you get\na ton of benefits.  They have been talked about in other talks.  It is\nnot really the focus of this talk other than to say, even without\nconcurrency, your program will be easier to understand, easier to\nreason about, easier to test, more modular, and so forth.  That all\nfalls out of programming with functions to as great an extent as\npossible.")]),e._v(" "),t("p",[e._v("On the other hand, when you step back and look at your entire program,\nvery few programs, on the whole, are functions.  You know, that take a\nsingle input, think about it, and produce a single output.  Maybe some\ncompilers or theorem provers work that way, but most real world\nprograms that I have worked on, and I think most real world programs\nin the real world do not work that way.")]),e._v(" "),t("p",[e._v("In particular, even if you claimed your program was completely\nfunctional, if it is going to produce any output, it is not, because\notherwise it will just warm up the machine.  But even if it is mostly\nfunctional, there are still observable effects of a purely functional\nprogram running.  It is running on a computer.  As soon as it is\nrunning on a computer it is not math any more.  It is a program\nrunning on a computer.  It is consuming memory.  It is consuming clock\ncycles.  It is observably doing something over time.  So "),t("em",[e._v("all")]),e._v("\nprograms do things over time.")]),e._v(" "),t("p",[e._v("But most real programs, as I say, actually have observable behavior\nthat is not just the fact that they are running on a computer, but\nthat they are doing things.  They are interacting with the outside\nworld.  They are talking over sockets.  They are putting stuff on the\nscreen.  They are putting things in or out of the database.")]),e._v(" "),t("p",[e._v('In particular though, we will use one critical measure about how to\ndefine state, which is: if you ask the same question twice, and you\nget different answers, then there is state.  I do not care where you\nput it.  You can put it in a process, you put it in an agent, an atom,\nin a variable.  It does not matter, in a database.  If you ask the\nsame question twice and get different answers at different times, you\nhave state.  So again, the word "time" just came up again there.')]),e._v(" "),t("p",[e._v("[Time 0:06:37]")]),e._v(" "),t("h2",{attrs:{id:"processes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#processes"}},[e._v("#")]),e._v(" Processes")]),e._v(" "),t("p",[t("img",{attrs:{src:a(302),alt:"00.06.37 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("따라서 대부분의 프로그램은 프로세스라고 생각하기 때문에 순수하게 기능적일 수 없는 부분, 즉 시간에 따라 다른 답을 만들어내야 하는 부분에 대해 이야기해야 합니다. 어떻게 하면 반짝이는 순수한 부분으로 만든 것을 완전히 엉망으로 만들지 않고 그렇게 할 수 있을까요?")]),e._v(" "),t("p",[e._v("특히 저는 이 강연이 지역적 맥락에서 국가와 시간의 개념에 관한 것이라는 점을 강조하고 싶습니다. 저는 동일한 프로세스에 대해 이야기하고 있습니다. 분산 프로그램에는 완전히 다른 요구 사항과 특성이 있으며, 동일한 프로세스에서 할 수있는 것과 동일한 작업을 수행 할 수 없습니다. 그래서 저는 동일한 프로세스 동시성 및 상태에 대해서만 이야기하고 있습니다.")]),e._v(" "),t("p",[e._v("So I think most programs are processes, which means we need to talk\nabout the part of your program that cannot be purely functional, the\npart that is going to have to produce a different answer at different\ntimes.  How do you do that, and not make a complete mess out of what\nyou created with the shiny pure part?")]),e._v(" "),t("p",[e._v("In particular, though, I want to highlight the fact that this talk is\nstrictly about the notion of state and time in a local context.  I am\ntalking about in the same process.  There are a completely different\nset of requirements and characteristics of distributed programs, where\nyou cannot do the same things that you can do in the same process.  So\nI am talking "),t("em",[e._v("only")]),e._v(" about same-process concurrency and state.")]),e._v(" "),t("p",[e._v("[Time 0:07:35]")]),e._v(" "),t("h2",{attrs:{id:"state"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[e._v("#")]),e._v(" State")]),e._v(" "),t("p",[t("img",{attrs:{src:a(303),alt:"00.07.35 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그래서 저는 정체성, 국가, 가치, 이런 것들을 말할 때 제가 의미하는 바에 대해 좀 더 정확하게 말하고 싶습니다. 특히 상태에 대해 두 번 이야기하고 싶습니다. 하나는 일종의 일반적인 설명입니다. 상태는 한 번에 정체성의 가치입니다.")]),e._v(" "),t("p",[e._v('어쩌면 말이 안 될 수도 있습니다. 어쩌면 전통적인 프로그래밍 언어의 변수처럼 들릴 수도 있습니다. 전통적인 프로그래밍 언어를 사용하는 사람에게 "상태가 있나요?"라고 물어본다면 아마 이렇게 대답할 것입니다. 그들은 "네, 변수가 몇 개 있고 변수를 변경합니다"라고 대답할 것입니다. 이는 상태를 구성하는 요소에 대한 올바른 정의가 아닙니다.')]),e._v(" "),t("p",[e._v("그렇다면 변수는 상태일까요? 변수가 이런 일을 하나요? 시간이 지남에 따라 아이덴티티의 가치를 관리할 수 있을까요? 변수 i를 0으로 설정할 수도 있고, 42로 설정할 수도 있고, 한 변수를 다른 변수에 할당할 수도 있습니다. j는 42일까요? 상황에 따라 다릅니다. 순차적 프로그램에서는 아마도 그렇겠죠.")]),e._v(" "),t("p",[e._v('스레드가 있는 프로그램에서 무엇이 잘못될 수 있을까요? 이런 일이 어떤 순서로 일어났는지, 어떤 스레드에서 일어났는지는 말하지 않았습니다. 예를 들어 별도의 스레드에서 j가 i와 같다고 설정했다면 어떤 나쁜 일이 일어날 수 있을까요? 반드시 42라고 나올까요? 아니요, 절대 아닙니다. 해당 메모리가 다른 스레드의 캐시로 플러시되지 않았을 수도 있기 때문입니다. 반드시 "i"라는 휘발성이 있는 것은 아닙니다.')]),e._v(" "),t("p",[e._v("또 어떤 일이 일어날 수 있을까요? i가 길거나, 프로그래밍 언어에서 길이를 설정하는 것이 원자적이지 않을 수도 있습니다. 나쁩니다.")]),e._v(" "),t("p",[e._v("So I want to be a little bit more precise about what I mean when I say\nidentity, state, and value, and these kinds of things.  And in\nparticular I want to talk about state and I will talk about it twice.\nOne is just sort of a generic statement: state is the value of an\nidentity at a time.")]),e._v(" "),t("p",[e._v('Maybe none of that makes sense.  Maybe it sounds like a variable from\na traditional programming language.  Because I think if you ask\nsomebody who is using a traditional programming language, "Do you have\nstate?"  They will be like, "Yeah I have some variables, and I change\nthem".  And that is not a good sound definition of what constitutes\nstate.')]),e._v(" "),t("p",[e._v("So are variables state?  Do they do this job?  Do they manage the\nvalue of an identity over time?  We can have a variable i, we can set\nit to zero, we can set it to 42, we can assign one variable to\nanother.  Is j 42?  That depends.  In a sequential program, probably,\nkinda, sorta.")]),e._v(" "),t("p",[e._v('In a program that had threads, what could go wrong?  Well I did not\nsay what order these things happened in, or what threads they happened\nin.  For instances if you set j equals i in a separate thread, what\nbad thing could have happened to you?  Would it say 42 necessarily?\nNo, definitely not.  Because that memory may not have been flushed\nthrough to the other thread\'s cache.  It is not volatile, necessarily,\n"i".')]),e._v(" "),t("p",[e._v("What else could happen that is bad?  Maybe i is a long, maybe setting\na long is not atomic in your programming language.  Bad.")]),e._v(" "),t("p",[e._v("[Time 0:09:05]")]),e._v(" "),t("h2",{attrs:{id:"variables"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#variables"}},[e._v("#")]),e._v(" Variables")]),e._v(" "),t("p",[t("img",{attrs:{src:a(304),alt:"00.09.05 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v('따라서 변수는 상태 관리 작업을 수행하기에 충분하지 않습니다. 변수는 단일 제어 스레드를 전제로 합니다. 그렇지 않으면 실제로는 전혀 작동하지 않습니다. 동시성에 의해 끔찍하게 망가집니다. "이 메모리 조각이 있다"는 개념 자체가 작동하지 않습니다. 스택에 있는 변수든, 객체의 필드든, 우리 프로그램은 대부분 이 메모리를 기반으로 만들어졌기 때문에 동일한 문제가 발생합니다. 메모리 조각은 불충분한 추상화입니다.')]),e._v(" "),t("p",[e._v("그래서 우리는 긴 쓰기의 비원자성 문제가 있습니다. 이는 많은 언어에서 발생하는 문제로, 원자적이지 않다는 것입니다. 따라서 다른 스레드에서 보면 숫자의 절반을 얻을 수 있습니다. 쓰기 가시성과 메모리 펜스는 진정한 동시 상자에서 여러 개의 스레드가 제어하는 경우 고려해야 합니다.")]),e._v(" "),t("p",[e._v('만약 어떤 객체가 있고, 그 객체의 상태를 구성하는 이런 것들이 한데 모여 있다면, 이제 복합 연산을 구성해야 하는 문제가 생깁니다. 다른 유효한 상태로 만들려면 이러한 여러 가지 가변적인 것들을 건드려야 하기 때문에 이제 "내 언어가 작성할 때 그렇게 생각했으므로 제어 스레드가 하나만 있는 것처럼 보이게 하려면 내게서 떨어져 있어라"라는 잠금이나 일종의 동기화를 적용하거나 복사한 언어가 작성할 때 그렇게 생각한 것처럼 보이게 할 수 있습니다.')]),e._v(" "),t("p",[e._v("이 모든 것이 같은 문제의 예입니다. 우리는 시간 부족으로 인한 모델 부재를 해결해야 합니다. 시간이 없다면 변수가 있어도 소용이 없으니까요. 잠시만 생각해 보세요. 시간 개념이 없다면 변수가 왜 필요할까요? 나중에 다시 돌아가서 다른 것을 볼 수 없다면 그게 무슨 변수가 될까요?")]),e._v(" "),t("p",[e._v('So variables are not going to be good enough to do the job of managing\nstate.  They are predicated on a single thread of control.  They\nactually do not work at all, otherwise.  They are horribly broken by\nconcurrency.  The whole notion of, "there is this piece of memory",\ndoes not work.  And our programs are built substantially on this,\nwhether it is a variable sitting on the stack, or fields in your\nobject, same problems.  Pieces of memory are insufficient\nabstractions.')]),e._v(" "),t("p",[e._v("So we have the problem of non-atomicity of long writes.  That is a\nproblem in a lot of languages, that it is just not atomic.  So you\ncould get half of a number if you look at it from another thread.\nWrite visibility and memory fences have to be accounted for once you\nhave multiple threads of control on a true concurrent box.")]),e._v(" "),t("p",[e._v('If you have an object, and it has a bunch of these things collected\ntogether that constitute its state, now you have the problem of\ncomposing a composite operation.  Because making it into another valid\nstate requires touching several of these variable things, which now\nmakes you impose locks or some sort of synchronization that say, "Stay\naway from me, so I can pretend there is only one thread of control,\nbecause that is what my language thought when they wrote it", or the\nlanguage they copied thought when they wrote '),t("em",[e._v("it")]),e._v(".")]),e._v(" "),t("p",[e._v("All of these things are examples of the same problem.  We are having\nto work around the lack of a model for time.  Because there is no\npoint to having variables if you do not have time.  And just think\nabout that for a second.  If there is no time notion, why would you\nneed a variable?  If you cannot go back to it later and see something\ndifferent, how is it a variable?")]),e._v(" "),t("p",[e._v("[Time 0:10:47]")]),e._v(" "),t("h2",{attrs:{id:"time"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#time"}},[e._v("#")]),e._v(" Time")]),e._v(" "),t("p",[t("img",{attrs:{src:a(305),alt:"00.10.47 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v('따라서 시간에 대해 더 명확히 알고 싶다면 물리학이 아닌 강의에서는 다루지 않을 것입니다. "시간이라고 하면 어떤 것을 떠올리시나요?"라고 물어보겠습니다. 여러분은 어떤 일이 다른 일의 이전 또는 이후라고 생각합니다. 나중에 일어나는 일을 생각합니다. 동시에 일어나는 일, 두 가지 일이 동시에 일어나는 것을 생각합니다. 지금 일어나고 있는 일을 생각하는데, 이는 일종의 자기 상대적인 시간 관점입니다.')]),e._v(" "),t("p",[e._v("하지만 이 모든 개념은 본질적으로 상대적이라는 점에서 중요합니다. 시간에 대해 생각할 때, 시간이나 이름이 붙은 특정 순간에 대한 시간은 많지 않습니다. 우리가 생각하는 시간의 개념은 대부분 상대적인 시간, 즉 두 개의 개별적인 것 사이의 순서와 관련이 있습니다.")]),e._v(" "),t("p",[e._v('So if we want to be clearer about time, which we are not going to be\nin a non-physics lecture.  We are just going to say, "What are some\nthings you think of when you think of time?"  You think of things\nbeing before or after other things.  You think of something happening\nlater.  You think of something happening at the same time, two things\nhappening at the same time.  You think of something happening right\nnow, which is sort of a self-relative perspective of time.')]),e._v(" "),t("p",[e._v("But all of these concepts are important in that they are "),t("em",[e._v("inherently")]),e._v("\nrelative.  When you think about time, there is not a lot about time\nthat are hours, or this particular moment with a name on it.  Most of\nour notions of time have to do with relative time, the ordering\nbetween two discrete things.")]),e._v(" "),t("p",[e._v("[Time 0:11:36]")]),e._v(" "),t("h2",{attrs:{id:"value"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#value"}},[e._v("#")]),e._v(" Value")]),e._v(" "),t("p",[t("img",{attrs:{src:a(306),alt:"00.11.36 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v('따라서 시간에 대해 더 명확히 알고 싶다면 물리학이 아닌 강의에서는 다루지 않을 것입니다. "시간이라고 하면 어떤 것을 떠올리시나요?"라고 물어보겠습니다. 여러분은 어떤 일이 다른 일의 이전 또는 이후라고 생각합니다. 나중에 일어나는 일을 생각합니다. 동시에 일어나는 일, 두 가지 일이 동시에 일어나는 것을 생각합니다. 지금 일어나고 있는 일을 생각하는데, 이는 일종의 자기 상대적인 시간 관점입니다.')]),e._v(" "),t("p",[e._v("하지만 이 모든 개념은 본질적으로 상대적이라는 점에서 중요합니다. 시간에 대해 생각할 때, 시간이나 이름이 붙은 특정 순간에 대한 시간은 많지 않습니다. 우리가 생각하는 시간의 개념은 대부분 상대적인 시간, 즉 두 개의 개별적인 것 사이의 순서와 관련이 있습니다.")]),e._v(" "),t("p",[e._v("[Time 0:13:24]")]),e._v(" "),t("h2",{attrs:{id:"identity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#identity"}},[e._v("#")]),e._v(" Identity")]),e._v(" "),t("p",[t("img",{attrs:{src:a(307),alt:"00.13.24 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("강연의 철학 부분에서 또 하나의 개념은 정체성의 개념입니다. 이것은 아마도 가장 모호한 개념이지만 중요한 개념입니다.")]),e._v(" "),t("p",[e._v("현실 세계에서는 어떤 일이 일어날까요? 우리가 오늘, 엄마, 조 암스트롱에 대해 이야기할 때 현실 세계에서는 어떤 일이 일어날까요? 변하지 않는 단일한 것일까요? 아니면 시간이 지남에 따라 다른 가치와 연관되는 논리적 실체가 있다고 생각할 수도 있습니다. 다시 말해, 특정 순간에는 모든 것이 정지되어 있습니다. 그리고 다음 순간 우리는 다른 것을 보게 됩니다. 이것도 같은 것일까요? 글쎄요, 만약 어떤 힘이 이 사물에 작용하여 다음 사물을 만들어냈다면, 저는 그것들을 같은 것이라고 생각합니다. 그렇지 않으면 서로 관련이 없는 것입니다. 두 가지가 같은 공간을 통과할 수 있습니다. 같은 공간에 있기 때문에 같은 것이 아닙니다.")]),e._v(" "),t("p",[e._v("따라서 시간 경과에 따른 값의 집합, 그 값들이 인과적으로 관련되어 있는 값에 이름을 붙여야 합니다. 이들은 서로 다른 값입니다. 서로 다른 공간에 있을 수 있습니다. 저는 이쪽으로 걸어갈 수 있습니다. 나는 여전히 부자다. 그래서 무슨 일이 일어나고 있는 걸까요?")]),e._v(" "),t("p",[e._v("세 가지 개념이 있으면 무슨 일이 일어나고 있는지 쉽게 이해할 수 있습니다. 상태가 있습니다: 나는 바로 여기 서 있다. [한 걸음 옆으로 이동] 상태가 있습니다: 나는 여기 서 있다. 두 가지 모두 값입니다. 시간을 잠시 멈출 수 있다면 나에 대한 어떤 것도 변하지 않을 것입니다. 왜냐하면 나는 다리를 사용하여 이쪽으로 몸을 움직이고 있고, 여전히 말을 하고 있으며, 내가 여기 있는 것과 저기 있는 것 사이의 일련의 인과적 연결을 볼 수 있기 때문입니다. 그래서 당신은 말합니다 : 그게 전부 리치입니다. 그것은 두 사람이 하는 것이 아닙니다.")]),e._v(" "),t("p",[e._v("정체성은 이름과 같은 것이 아닙니다. 이 점을 분명히 하고 싶어요. 저는 어머니가 있습니다. 당신은 이제 그 개념, 이 정체성을 머릿속에 가지고 있습니다. 하지만 저는 엄마라고 부르고 여러분은 히키 부인이라고 부르시겠죠.")]),e._v(" "),t("p",[e._v("이러한 정체성은 복합적일 수 있습니다. 뉴욕 양키스나 미국인에 대해 이야기할 수 있습니다. 그것들은 세트이지만 정체성이기도 합니다. 시간이 지남에 따라 변화하지만 특정 시점에서는 가치가 있습니다. 지금 뉴욕 양키스에 있는 사람들이 바로 그런 사람들입니다. 프로세스인 모든 프로그램에는 정체성을 위한 메커니즘이 필요합니다. 이 모든 것이 함께 진행됩니다.")]),e._v(" "),t("p",[e._v("So one more concept in the philosophy portion of the talk, which is\nthe concept of identity.  This is probably the most nebulous of these\nthings, but it is an important thing.")]),e._v(" "),t("p",[e._v("What happens in the real world?  What happens in the real world when\nwe talk about today, or mom, or Joe Amstrong?  Is that a single\nunchanging thing?  Or one way to think about it is: we have a logical\nentity, that we associate with different values over time.  In other\nwords, at any particular moment, everything is frozen.  And the next\nmoment we look, we see something different.  Is that the same thing?\nWell, if some force has acted on this thing to produce that next\nthing, I consider it to be the same thing.  Otherwise, they are\nunrelated things.  Two things can pass through the same space.  They\nare not the same thing because they are in the same space.")]),e._v(" "),t("p",[e._v("So a set of values over time, where the values are causally related,\nis something we need to name.  These are different values.  They may\nbe in different spaces.  I can walk over here.  I am still Rich.  So\nwhat is happening?")]),e._v(" "),t("p",[e._v("What is happening is easy to understand if you have three notions.\nThere is a state: I am standing right here.  [moves a step sideways]\nThere is a state: I am standing over here.  They are both values.  If\nyou could stop time for a second, nothing about me would be changing.\nAnd it is me, because I am using my legs to move myself over here, and\nI am still talking, and you see a set of causal connections between me\nbeing here and being there.  So you say: that is all Rich.  That is\nnot two people doing this.")]),e._v(" "),t("p",[e._v("Identities are not the same things as names.  I just want to make that\nclear.  I have a mother.  You now have that concept in your head, this\nidentity.  But I call her mom, and you would call here Mrs. Hickey, I\nhope.")]),e._v(" "),t("p",[e._v("These identities can be composite.  We can talk about the New York\nYankees, or Americans, no problem.  Those are sets, but they are also\nidentities.  They change over time, but at any particular point in\ntime they have a value.  These are the guys who are on the Yankees\nright now.  Any program that is a process needs to have some mechanism\nfor identity.  This all goes together.")]),e._v(" "),t("p",[e._v("[Time 0:15:52]")]),e._v(" "),t("h2",{attrs:{id:"state-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#state-2"}},[e._v("#")]),e._v(" State")]),e._v(" "),t("p",[t("img",{attrs:{src:a(308),alt:"00.15.52 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이제 돌아가서 상태에 대해 이야기하겠습니다. 의미 있는 용어가 몇 가지 있습니다. 이제 상태는 한 번에 정체성의 가치라고 말할 수 있습니다. 이해가 되시길 바랍니다. 정체성은 논리적 인 것이지 반드시 장소가 아니며 기억의 조각이 아닙니다. 값은 절대 변하지 않는 것입니다. 그리고 시간은 상대적인 것입니다.")]),e._v(" "),t("p",[e._v("이제 상태에 변수를 사용할 수 없는 이유를 쉽게 알 수 있을 것입니다. 특히 변수는 불변하는 것을 참조하지 않을 수 있으므로 이미 [부저음을 내는 것]이 문제입니다. 변수를 변수를 참조하는 것으로 만들면 모래 위에 건물을 짓는 것과 같습니다. 핵심 개념은 변수 또는 우리가 시간을 관리하기 위해 무엇을 하든 값을 참조해야 한다는 것입니다.")]),e._v(" "),t("p",[e._v("우리가 전통적으로 사용하는 변수 집합은 원자 단위로 구성되지 않기 때문에 값을 구성할 수 없습니다. 값은 불변하는 것을 의미하기 때문입니다. 부품을 독립적으로 변경할 수 있다면 한 부품은 중간에 있고 다른 부품은 없는 순간이 있을 것이기 때문에 불변이 아닙니다. 지금은 유효한 값이 아닙니다. 중간에 무언가가 일어나고 있습니다.")]),e._v(" "),t("p",[e._v("변수에 대해 좀 더 글로벌하게 말하자면, 변수의 문제는 상태 전환 관리가 없다는 것입니다. 이것이 바로 시간 관리, 즉 시간에 대한 조정 모델입니다. 내가 이 상태였다가 지금은 저 상태이고, 두 상태 모두 불변의 값인 상태에서 어떻게 전환할 수 있을까요?")]),e._v(" "),t("p",[e._v("So I will go back and talk about state.  We have some terms that\nhopefully mean something.  Now we can say: a state is a value of an\nidentity at a time.  Hopefully that makes sense.  The identity is a\nlogical thing, it is not necessarily a place, it is not a piece of\nmemory.  A value is something that never changes.  And time is\nsomething that is relative.")]),e._v(" "),t("p",[e._v("Now it is easy to see, I think, why we cannot use variables for state.\nIn particular, that variable may not refer to something that is\nimmutable, so already [makes buzzer sound] that is a problem.  If you\nmake a variable refer to a variable, you are building on sand.  The\nkey concept is: variable -- or whatever we are going to do to manage\ntime -- has got to refer to values.")]),e._v(" "),t("p",[e._v("Sets of variables, as we traditionally have them, can never constitute\na value, because they are not atomically composite.  Because we are\nsaying a value is something that is immutable.  If you can change the\nparts independently, then it is not immutable, because there is going\nto be a moment when one part is halfway there and another part is not\nthere.  That is not a valid value now.  Something is happening in the\nmiddle.")]),e._v(" "),t("p",[e._v("And more globally you can say about variables, their problem is they\nhave no state transition management.  That is the management of time,\na coordination model for time.  How do you go from: I am in this\nstate, now I am in that state, both states being immutable values.")]),e._v(" "),t("p",[e._v("[Time 0:17:20]")]),e._v(" "),t("h2",{attrs:{id:"philosophy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#philosophy"}},[e._v("#")]),e._v(" Philosophy")]),e._v(" "),t("p",[t("img",{attrs:{src:a(309),alt:"00.17.20 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이것이 철학 부분의 요약입니다. 제가 생각하는 핵심 개념은 '모든 것은 제자리에서 변하지 않는다'입니다. 우리는 그렇게 생각하지만 실제로는 그렇지 않습니다. 이것이 사실임을 알 수 있는 방법은 시간을 차원으로 통합하는 것입니다. 시간이 차원이 되고, x, y, z, 시간이 생기면 그 다음이 뭔지 아세요? 바로 여기입니다. 여기서 어떤 일이 일어나고 있다면 이것도 다르지 않습니다. 상황은 제자리에서 변하지 않습니다. 시간은 계속 진행됩니다. 과거의 함수가 미래를 만듭니다. 하지만 두 가지 모두 가치입니다.")]),e._v(" "),t("p",[e._v("제가 지금부터 보여드릴 디자인에는 로컬 컨텍스트에서 시간을 모델링하려고 할 때 중요하다고 생각하는 몇 가지 측면이 있습니다. 이런 것들은 제가 포기하고 싶지 않은 것들입니다. 예를 들어 Java에서는 무차별 대입을 통해 달성할 수 있는 것들인데, Clojure에서 달성할 수 없다면 제 언어를 판매할 수 없습니다. 즉, 공동 배치된 엔티티는 협력 없이도 서로를 볼 수 있습니다. 협력이 필요한 메시징 모델이 많이 있습니다. 상대방이 어떤 사람인지 확인하려면 질문을 해야 합니다. 여러분은 그 질문을 받을 준비가 되어 있어야 합니다. 내 질문에 기꺼이 대답할 준비가 되어 있어야 합니다.")]),e._v(" "),t("p",[e._v("하지만 함께 있을 때는 그렇지 않습니다. 옆 건물에서 무슨 일이 일어나고 있는지 모르지만 여러분 모두를 볼 수 있고, 허락을 받지 않고도 여러분의 뒷모습을 확실히 볼 수 있습니다.")]),e._v(" "),t("p",[e._v("로컬 환경에서 정말 중요하다고 생각하는 또 다른 한 가지는 - 분산된 환경에서는 불가능하다고 생각해야 하지만 - 같은 프로세스에서 함께 위치한 조직과 조율된 방식으로 일을 할 수 있다는 점입니다. 우리 모두 함께 일하자, 지금 당장 이 모든 것을 해보자고 말할 수 있습니다. 분산되어 있으면 그렇게 할 수 없습니다. 그래서 제가 보여드리려는 모델은 공동 위치 엔티티의 가시성과 조정을 지원합니다.")]),e._v(" "),t("p",[e._v("So this is the summary of the philosophy portion.  A key concept I\nthink is: things do not change in place.  We think that they do, but\nthey do not.  The way you can see that this is the case is to\nincorporate time as a dimension.  Once time is a dimension, once you\nhave x, y, z, time, guess what?  That is over here.  If something is\nhappening here, this is no different.  Things do not change in place.\nTime proceeds.  Functions of the past create the future.  But both\nthings are values.")]),e._v(" "),t("p",[e._v("There are a couple of aspects, I think, to the design of the things I\nam going to show you that I think are important when you try to model\ntime in the local context.  These are things I do not want to give up.\nThese are things I know I can achieve by brute force in Java, and I\ncannot sell my language if I cannot achieve them in Clojure, for\ninstance.  Which is: co-located entities can see each other without\ncooperation.  There are a lot of messaging models that require\ncooperation.  If I want to see what you are about, I have to ask you a\nquestion.  You have to be ready to be asked that question.  You have\nto be willing to answer my question.")]),e._v(" "),t("p",[e._v("But that is not really the way things are when you are co-located.  I\ndo not know what is happening in the next building, but I can see all\nof you, and I can certainly look at the back of your head without\nasking you permission.")]),e._v(" "),t("p",[e._v("The other thing that I think is really important in a local context --\nit really should be written off as impossible in a distributed context\n-- is: you can do things in a coordinated manner with co-located\nentities in the same process.  You can say: let us all work together,\nand do this all right now.  As soon as you are distributed, you cannot\ndo that.  So the models I am going to show you support visibility of\nco-located entities and coordination.")]),e._v(" "),t("p",[e._v("[Time 0:19:15]")]),e._v(" "),t("h2",{attrs:{id:"race-walker-foul-detector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#race-walker-foul-detector"}},[e._v("#")]),e._v(" Race-walker foul detector")]),e._v(" "),t("p",[t("img",{attrs:{src:a(310),alt:"00.19.15 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("작은 예를 들어보겠습니다. 작은 경주용 반칙 감지기가 있습니다. 경보 선수는 뛰어서는 안 되고 걸어야 합니다. 한 걸음 한 걸음, 발뒤꿈치부터 내딛어야 하며 두 발이 동시에 땅에서 떨어지면 안 됩니다. 이는 반칙이며 레이스에서 퇴장당합니다.")]),e._v(" "),t("p",[e._v("그럼 어떻게 해야 할까요? 왼발 자세를 취하고 왼발이 땅에서 떨어져 있는 것을 확인하면 됩니다. 오른발 자세를 취하고 나서 '아, 땅에서 벗어났다'라고 말합니다. 그래서 달리고 있는 거죠?")]),e._v(" "),t("p",[e._v("우습게 들리지만 모든 사람이 항상 정확히 이렇게 하는 프로그램을 작성합니다. 그런데 왜 작동하지 않을까요? 우리는 그런 식으로 일할 수 없습니다. 상황이 변화하는 동안 시간과 가치를 모두 한데 묶어서 볼 수는 없습니다. 그것은 효과가 없습니다. 우리는 결정을 내릴 수 없습니다. 우리는 인간으로서 이런 식으로 결정을 내리지 않습니다.")]),e._v(" "),t("p",[e._v("So let us take a little example.  A little race-walker foul detector.\nRace walkers, they have to walk, they cannot run.  They have to walk\nstep step step, heel toe, and they cannot have both feet off the\nground at the same time.  That is a foul, and then you get kicked out\nof the race.")]),e._v(" "),t("p",[e._v("So how do we do this?  Well we go and we get the left foot position,\nand we see it is off the ground.  We go and we get the right foot\nposition and we say: oh, it is off the ground.  So they are running,\nright?")]),e._v(" "),t("p",[e._v("It sounds funny, but everybody writes programs that do exactly this\nall the time, "),t("em",[e._v("exactly")]),e._v(" this.  And you wonder: why didn't it work?  We\ncannot work that way.  We cannot have time and values all munged\ntogether where things are changing while we are trying to look at\nthem.  That does not work.  We cannot make decisions.  We do not make\ndecisions as human beings this way.")]),e._v(" "),t("p",[e._v("[Time 0:20:09]")]),e._v(" "),t("h2",{attrs:{id:"approach"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#approach"}},[e._v("#")]),e._v(" Approach")]),e._v(" "),t("p",[t("img",{attrs:{src:a(311),alt:"00.20.09 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("스냅샷과 특정 시점에 무언가를 가치로 간주하는 능력은 지각과 의사 결정에 매우 중요합니다. 그리고 이러한 기능은 인간과 마찬가지로 프로그램에서도 매우 중요합니다. 우리의 감각 시스템을 살펴보면, 감각 시스템은 우리가 완전히 대체할 수 없는 것으로 인식하는 세계를 순간적으로 엿보는 데 전적으로 초점을 맞추고 있습니다.")]),e._v(" "),t("p",[e._v("그렇다면 프로그래밍 방식으로 이를 어떻게 달성할 수 있을까요? 멀티코어에서 작동하고 멀티코어의 이점을 누릴 수 있는 프로그램을 작성하기 위해 우리가 지지해야 한다고 생각하는 것 중 하나는 바로 '레이스를 멈출 수 없다'는 것입니다. 달리는 사람을 멈출 수 없습니다. \"우와! 네가 달리고 있는지 확인하고 싶으니 잠시만 기다려줄래?\"라고 말할 수도 없습니다.")]),e._v(" "),t("p",[e._v("또한 주자의 협조를 기대할 수도 없습니다. 그냥 달리고 있는지 말해주실 수 있나요? 하지만 여기 오른쪽에 있는 이 사람처럼 주자를 하나의 가치로 간주할 수 있다면, 주자를 하나의 가치로 바라볼 수 있다는 점이 좋습니다. 이 사진에 포착된 시점이 있죠? 그것은 하나의 가치입니다. 시간이 진행되는 동안 왼쪽과 오른쪽을 독립적으로 볼 필요가 없습니다. 저는 하나의 가치를 손에 쥐고 있습니다. 한 시점에 포착된 사진입니다. 경기는 계속 진행되지만 오른쪽에 파울이 있는 선수가 보입니다. 두 발이 모두 땅에서 떨어져 있습니다. 쉬운 일이죠.")]),e._v(" "),t("p",[e._v("애플리케이션의 로직에서 이러한 종류의 용이성을 확보해야 합니다. 여러분은 값으로 작업하고 싶을 것입니다. 여러분은 가치를 검토하려고 할 때 여러분에게서 멀어지는 것들을 가지고 작업하고 싶지 않을 것입니다.")]),e._v(" "),t("p",[e._v("따라서 러너의 값을 얻을 수 있다면 이 작업을 수행하는 것은 문제가 되지 않습니다. 마찬가지로 보너스를 주거나 판매 보고서를 작성하기 위해 사람들이 영업을 하는 것을 막고 싶지 않습니다. 우리는 시간이 흐르고 우리의 논리를 수행할 수 있는 세상으로 나아가야 하며, 우리의 논리를 수행하기 위해 모든 사람을 멈출 필요는 없습니다. 이 두 가지는 독립적이어야 합니다.")]),e._v(" "),t("p",[e._v("Snapshots, and the ability to consider something as a value at a point\nin time, are "),t("em",[e._v("critical")]),e._v(" to perception and decision making.  And they\nare as critical in programs as they are to us as human beings.  If you\nlook at our sensory systems, they are completely oriented on creating\nmomentary glimpses of a world that we would otherwise just perceive to\nbe completely fungible.")]),e._v(" "),t("p",[e._v('Now how do we achieve this, programmatically?  Well one of the things\nI think we have to advocate if we want to write programs that can work\non multiple cores, and benefit from being on multiple cores, is: we\ncannot stop the race.  We cannot stop the runner.  We cannot say,\n"Whoa!  Could you just hang on a second, because I just want to see if\nyou are running."')]),e._v(" "),t("p",[e._v("Also we cannot expect the runner to cooperate.  Could you just tell me\nif you are running?  But if we could consider the runner to be a\nvalue, like this guy on the right here, it is kind of nice that we can\nlook at him as if he was a value.  There is a point in time that was\ncaptured by this photograph, right?  It is a single value.  I do not\nhave to independently look at the left and right while "),t("em",[e._v("time\nproceeds")]),e._v(".  I have got a value in hand.  It was captured at a point in\ntime.  The race kept going, but I can see that guy has got a foul on\nthe right.  He has got both his feet off the ground.  That is easy.")]),e._v(" "),t("p",[e._v("That is the kind of easiness you want to have in the logic of your\napplications.  You want to be working with values.  You do not want to\nbe working with things that are running away from you as you are\ntrying to examine them.")]),e._v(" "),t("p",[e._v("So it is not a problem to do this work if we can get the runner's\nvalue.  In a similar way, we do not want to stop people from\nconducting sales so we can give them bonuses or do sales reports.  We\nneed to move to a world in which time can proceed "),t("em",[e._v("and")]),e._v(" we can do our\nlogic, and we do not need to "),t("em",[e._v("stop everybody")]),e._v(" so we can do our logic.\nThe two things have to be independent.")]),e._v(" "),t("p",[e._v("[Time 0:22:00]")]),e._v(" "),t("h2",{attrs:{id:"approach-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#approach-2"}},[e._v("#")]),e._v(" Approach")]),e._v(" "),t("p",[t("img",{attrs:{src:a(312),alt:"00.22.00 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그렇다면 어떻게 작동할까요? 우선 값으로 프로그래밍해야 합니다. 숫자나 날짜 같은 작은 것뿐만 아니라 컬렉션, 집합 등 거의 모든 것을 표현하기 위해 값을 사용해야 합니다. 클래스로 모델링할 수 있는 것은 모두 값이어야 합니다.")]),e._v(" "),t("p",[e._v("이런 방식으로 작동하는 객체 지향 시스템이 존재할 수 없다는 말은 아닙니다. 제가 아는 한 그런 시스템은 없습니다. 하지만 전체 객체를 마치 값인 것처럼 바라봐야 합니다. 독립적으로 조작할 수 있는 조각으로 이루어져서는 안 됩니다. 그 객체의 새로운 상태를 원한다면 완전히 새로운 값을 만들어야 합니다.")]),e._v(" "),t("p",[e._v("그렇다면 시간의 문제는 무엇일까요? 그것은 훨씬 작은 문제가 됩니다. 우리가 해야 할 일은 가치의 연속을 관리할 수 있는 언어 구조나 방법을 확보하는 것뿐입니다. 아이덴티티는 시간이 지남에 따라 일련의 가치를 이어받게 됩니다. 이를 모델링할 방법만 있으면 됩니다. 우리는 순수한 함수를 가지고 있기 때문에 이전 값에서 새로운 값을 생성하는 방법을 알고 있습니다. 시간 조정 문제만 모델링하면 됩니다.")]),e._v(" "),t("p",[e._v("좋은 점은 두 가지를 분리할 때 메모리 조각으로 값을 통합하지 않으면 시간 의미론에 대한 여러 옵션이 생긴다는 것입니다. 이를 바라보는 다양한 방법이 있습니다. 메시지 전달도 있고 트랜잭션도 있습니다. 하지만 이제는 별도의 문제이기 때문에 다양한 옵션을 취할 수 있습니다. 심지어 같은 프로그램에서 여러 옵션을 사용할 수도 있습니다.")]),e._v(" "),t("p",[e._v('그래서 저는 두 가지 접근 방식이 있다고 말씀드리고 싶습니다. 한 부분은 값으로 프로그래밍하는 것이고, 다른 부분은 - 오늘 제가 이야기할 이 예제에서, 클로저의 예제에서 - "관리 참조"라는 개념으로, 변수의 모든 문제를 해결한다는 점을 제외하면 일종의 변수와 비슷하다고 생각할 수 있습니다. 즉, 조정 의미를 가진 변수이므로 이해하기 쉽습니다. 그냥 깨지지 않는 변수일 뿐입니다.')]),e._v(" "),t("p",[e._v("So, how does it work?  Well, the first thing is: we have to program\nwith values.  We have to use values to represent not just numbers, and\neven small things like dates, but pretty much everything: collections,\nsets.  Things that you would have modeled as classes should be values.")]),e._v(" "),t("p",[e._v("I am not saying there could not be an object-oriented system that\nworked this way.  I do not know of one that does.  But you should\nstart looking at your entire object as if it was a value.  It should\nnever be in pieces that you could twiddle independently.  You want a\nnew state of that object, you make an entire new value.")]),e._v(" "),t("p",[e._v("So then, what is the problem with time?  It becomes a much smaller\nproblem.  All we need to do is get some language constructs, or some\nway, to manage the succession of values.  An identity is going to take\non a succession of values over time.  We just need a way to model\nthat.  Because we have pure functions, we know how to create new\nvalues from old values.  We only need to model the time coordination\nproblem.")]),e._v(" "),t("p",[e._v("What is nice about this is: when you separate the two things, when you\nhave not unified values with pieces of memory, you end up with\nmultiple options for the time semantics.  You have a bunch of\ndifferent ways to look at it.  There is message passing, and there is\ntransactional.  But because it is now a separate problem, you can take\ndifferent options.  You can even have multiple options in the same\nprogram.")]),e._v(" "),t("p",[e._v('So I am going to say that there is a two-pronged approach.  One part\nis programming with values, the other part is -- in this example that\nI am going to be talking about today, in Clojure\'s example -- is the\nconcept called "managed references", which you can think of as, they\nare kind of like variables, except it fixes all of the problems with\nvariables.  In other words, they are variables that have coordination\nsemantics, so they are pretty easy to understand.  They are just\nvariables that are not broken.')]),e._v(" "),t("p",[e._v("[Time 0:23:49]")]),e._v(" "),t("h2",{attrs:{id:"persistent-data-structures"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#persistent-data-structures"}},[e._v("#")]),e._v(" Persistent Data Structures")]),e._v(" "),t("p",[t("img",{attrs:{src:a(313),alt:"00.23.49 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v('그래서 두 부분으로 나뉩니다. 이제 값에 대해 이야기하겠습니다. 함수형 프로그래밍 언어를 사용해 본 적이 없는 사람들이 처음에 움찔하는 것 중 하나는 "비싸게 들린다"는 것입니다. 주자가 발을 움직일 때마다 전체 주자를 복사해야한다면이 작업을 수행 할 방법이 없습니다.')]),e._v(" "),t("p",[e._v("특히 컬렉션과 같은 것에 대해 이야기하기 시작하면 사람들은 극도로 편집증에 걸립니다. 왜냐하면 그들이 알고 있는 컬렉션 클래스 라이브러리는 이 경우에는 기능이 없거나 매우 원시적인 것들이기 때문입니다. 가끔은 쓰기만 하면 전체가 복사되는 복사-온-쓰기 컬렉션도 있습니다.")]),e._v(" "),t("p",[e._v("그러나 복잡하지 않고 멋진 이름을 가진 기술이 있습니다. 이를 영구 데이터 구조라고 합니다. 이는 데이터베이스나 디스크와는 아무런 관련이 없습니다. 하지만 복합적인 객체를 값으로, 불변하는 것으로 효율적으로 표현하고 저렴한 방법으로 변경할 수 있는 방법입니다.")]),e._v(" "),t("p",[e._v("따라서 이러한 영구 데이터 구조 중 하나에 대한 변경은 실제로 따옴표로 묶여 있습니다. 변경되지 않습니다. 컬렉션이나 컴포지션의 기존 인스턴스를 가져와서 변경이 적용된 다른 인스턴스를 반환하는 함수입니다.")]),e._v(" "),t("p",[e._v("그러나 영구 데이터 구조에는 매우 특별한 의미가 있는데, 이러한 변경을 수행하려면 데이터 구조와 변경 작업이 컬렉션에서 기대하는 성능 보장을 충족해야 한다는 것입니다. 따라서 큰 O 로그 N 컬렉션이거나 상수 시간 액세스 또는 거의 상수 시간 액세스가 있는 컬렉션인 경우, 이러한 동작 특성이 이 변경 작업을 통해 충족되어야 합니다. 즉, 로그 N 동작이 예상되는 것에 대해 변경 작업을 수행하고 전체를 복사할 수 없다는 뜻입니다. 전체를 복사하는 것은 선형 동작이기 때문이죠? 그래서 이것이 중요한 것입니다.")]),e._v(" "),t("p",[e._v("영구 데이터 구조의 또 다른 중요한 측면은 때때로 라이브러리가 속임수를 쓰는 것을 볼 수 있다는 것입니다. 가장 최신 버전을 좋은 불변의 값으로 만들지만, 그 과정에서 이전 버전을 망가뜨리는 것입니다. 이 또한 지속적이지 않습니다. 이것이 바로 지속성이라는 단어의 또 다른 핵심 측면입니다. 영구 데이터 구조에서는 새 버전을 만들 때 이전 버전은 완벽하게 정상입니다. 변경되지 않습니다. 그대로 유지됩니다. 동일한 성능이 보장됩니다. 새로운 값을 생성해도 성능이 저하되지 않습니다.")]),e._v(" "),t("p",[e._v('모든 함수형 프로그래밍 언어는 이 부분을 속이려고 시도하고 결국에는 "이전 버전이 쇠퇴하거나 멀티 스레딩 관점이나 성능 관점에서 기괴한 동작이 발생하는 논리적 비용이 너무 높기 때문에 모두 불변으로 가고 성능 비용이 무엇이든 지불 할 것입니다"라고 말합니다. 그래서 제가 보여드리려는 것은 이전 값과 동일한 성능 특성을 갖는 합법적인 영구 컬렉션입니다.')]),e._v(" "),t("p",[e._v("그리고 제가 보여드릴 구체적인 예제는 클로저에 있는 예제입니다. 이것은 필 백웰이 이상적인 해시 시도라고 부르는 이상적인 해시 시도에 대해 수행한 일부 작업에서 파생된 것입니다. 그리고 정말 좋은 성능을 가진 비트 매핑 해시 시도가 있습니다. 그의 버전은 지속적이지 않았기 때문에 제가 클로저에서 한 일은 지속성을 만드는 것이었습니다.")]),e._v(" "),t("p",[e._v('So there are two parts.  We are going to talk now about the values.\nOne of the things that people cringe at initially, if they have not\nused functional programming languages before, is "that sounds\nexpensive".  If I have to copy the whole runner every time he moves\nhis foot, there is just no way I am going to do this.')]),e._v(" "),t("p",[e._v("And in particular, when you start talking about collections and things\nlike that, people get extremely paranoid.  Because what they know are\nsort of the very bad collection class libraries they have, which\neither have "),t("em",[e._v("no")]),e._v(" capabilities in this case, or some very primitive\nthings.  Sometimes there are copy-on-write collections, where every\ntime you write to it, the entire thing gets copied.")]),e._v(" "),t("p",[e._v("But there is a technology, which is not complicated, and it has a\nfancy name.  It is called a persistent data structure.  That has\nnothing to do with databases or disks.  But it is a way to efficiently\nrepresent a composite object as a value, as an immutable thing, and to\nmake changes to that in an inexpensive way.")]),e._v(" "),t("p",[e._v("So change for one of these persistent data structures is really just\nin quotes.  They do not change.  It is a function that takes an\nexisting instance of the collection or composite, and returns another\none that has the change enacted.")]),e._v(" "),t("p",[e._v("But there is a very particular meaning to Persistent Data Structures,\nwhich is that, in order to make these changes, the data structure and\nthe change operation have to meet the performance guarantees you\nexpect from the collection.  So if it is a big O log N collection, or\na collection that has constant time access, or near constant time\naccess, those behavioral characteristics have to be met by this\nchanging operation.  It means you cannot conduct the change on\nsomething that you expect to have log N behavior and copy the entire\nthing, because copying the entire thing is linear behavior, right?  So\nthat is the critical thing.")]),e._v(" "),t("p",[e._v("The other critical aspect of persistent data structure is: sometimes\nyou will see libraries try to cheat.  They will make the very most\nrecent version this good immutable value, but on the way they ruin the\nold version.  That also is not persistent.  That is another key aspect\nof the word persistent.  In a persistent data structure, when you make\nthe new version, the old version is perfectly fine.  It is immutable.\nIt is intact.  It has the same performance guarantees.  It is not\ndecaying as you produce new values.")]),e._v(" "),t("p",[e._v('Every functional programming language tries to cheat this side, and\neventually says "forget this, we are going all immutable and we are\ngoing to pay whatever the performance costs are, because the logical\ncost of having old versions decay, or have some bizarre behavior\neither from a multi-threading perspective or performance perspective,\nis too high".  So what I am going to show you are legitimate\npersistent collections where the old values have the same performance\ncharacteristics.')]),e._v(" "),t("p",[e._v("And the particular example I am going to show you is the one that is\nin Clojure.  It is derived from some work that Phil Bagwell did on\nthese ideal, he called him ideal hash tries.  And there are bit mapped\nhash tries that have really good performance.  His versions were not\npersistent, and so what I did for Clojure was I made them persistent.")]),e._v(" "),t("p",[e._v("[Time 0:26:57]")]),e._v(" "),t("h2",{attrs:{id:"bit-partitioned-hash-tries"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bit-partitioned-hash-tries"}},[e._v("#")]),e._v(" Bit-partitioned hash tries")]),e._v(" "),t("p",[t("img",{attrs:{src:a(314),alt:"00.26.57 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("모든 영구 데이터 구조의 비밀은 바로 시도라는 점입니다. 이제 알겠습니다. 이제 아시겠죠. 다양한 방법이 있으며 사람들은 B-트리와 레드-블랙 트리에 매우 익숙하다고 생각합니다. 또는 Erlang은 일반화된 균형 트리를 사용하는데, 이는 흥미롭다고 생각합니다. 그리고 밸런싱과 다른 것들을 위해 무작위화 기법을 사용하는 트리도 있습니다. 이것들은 다릅니다. 특히, 이 트리는 i가 붙은 트리이기 때문에 다른데, 어떤 사람들은 이 트리를 튀김과 운율이 맞는 트리라고 부르기도 합니다. 시도 [플리와 운율].")]),e._v(" "),t("p",[e._v("그 뒤에 숨은 아이디어는 잎으로 내려가는 경로가 고정되어 있지 않다는 것입니다. 고유한 잎 위치를 생성하는 데 필요한 만큼의 경로만 사용하게 됩니다. 일반적으로 문자열 검색에서 이러한 것을 보거나 인터넷 라우팅 테이블과 같은 것에서도 사용되는 것 같습니다.")]),e._v(" "),t("p",[e._v("여기서 모델은 매우 간단합니다. 적어도 저는 클로저에서 해시 테이블에 해당하는 것을 원했습니다. 해시 테이블에 상응하는 기능이 없다면 자바 프로그래머에게 클로저를 판매할 수 없다는 것을 알고 있습니다. 그들은 레드-블랙 트리에 대해 듣고 싶어하지 않습니다. 그들은 그것이 괜찮다는 것을 알고 있지만 그들이 익숙한 해시 테이블만큼 좋지는 않습니다. 그들은 그것보다 더 빠른 것이 필요합니다. 그리고 이것들이 있습니다.")]),e._v(" "),t("p",[e._v("작동 방식은 컬렉션에 넣으려는 값을 해시하는 것입니다. 결국 32비트 해시를 얻게 됩니다. 이 해시의 처음 5비트를 사용해 첫 번째 계층에서 고유한 위치가 있는지 확인합니다. 따라서 실제로는 이 시도에서 32방향 분기가 진행되고 있는 것입니다. 또한 각 노드에서 약간의 멋진 비트 트위들링이 진행되어 노드가 희박해집니다. 노드가 완전히 채워지지 않으므로 완전히 채워지지 않은 노드의 공간을 낭비하지 않습니다.")]),e._v(" "),t("p",[e._v('결국 인구, 비트 팝, 그리고 "해커의 기쁨"에서 복사한 몇 가지 알고리즘을 조합하여 사용하게 됩니다. 그것을 구입하세요. 아니면 그냥 Clojure를 사용할 수도 있습니다. 사실, 같은 종류의 기술인 Clojure의 벡터는 이미 팩터와 스칼라에 포팅되어 있어서 저는 괜찮습니다.')]),e._v(" "),t("p",[e._v("따라서 처음 5비트에서 고유하다면 끝입니다. 우리는 그것을 트라이의 첫 번째 레벨에 넣습니다. 그렇지 않다면 다음 5비트를 살펴보고 고유한 위치를 찾을 때까지 한 단계 더 내려가서 트라이를 진행하면 끝입니다. 우리는 거기에 가치를 넣을 것입니다.")]),e._v(" "),t("p",[e._v("여기서 중요한 것은 이 트라이가 얼마나 깊어질 수 있는가 하는 것입니다. 이 트리가 루트이므로 40억 개가 있다면 하나 둘 셋 넷 다섯 여섯으로 내려가면 됩니다. 따라서 매우 빠르게 분기되고 깊이 3에서 백만 개의 항목을 얻을 수 있습니다. 매우 얕습니다. 따라서 매우 얕고 중간 레벨의 인구 밀도가 낮은 노드를 통과하기 위해 약간의 트위들링을 사용하면 정말 빠릅니다. 이제 어떻게 하면 효율적으로 변경된 버전을 만들 수 있을지에 대한 이야기만 남았습니다.")]),e._v(" "),t("p",[e._v("The secret to all persistent data structures is that they are tries.\nThere you go.  Now you know.  There are lots of different recipes and\nI think people are very familiar with B-trees and red-black trees, or\nmaybe you know, Erlang uses some generalized balanced trees, I think,\nwhich are interesting.  And there are trees that use randomization\ntechniques for balancing and other things.  These are different.  In\nparticular, they are different because they are tries with the "),t("code",[e._v("i")]),e._v(",\nsome people call them "),t("code",[e._v("tries")]),e._v(" [rhymes with fries].  Tries [rhymes with\nflees].")]),e._v(" "),t("p",[e._v("The idea behind that is that are not going to have a fixed path down\nto a leaf.  You are going to use only as much of a path as you need to\nproduce a unique leaf position.  You usually see these things in\nstring search things, or maybe I think they are also used in Internet\nrouting tables and stuff like that.")]),e._v(" "),t("p",[e._v("Here the model is very simple.  We want -- at least I wanted for\nClojure -- something equivalent to a hash table.  I know I cannot sell\nClojure to Java programmers if it does not have something equivalent\nto a hash table.  They do not want to hear about a red-black tree.\nThey known that it is OK, but it is not as good as the hash tables\nthey are used to.  They need something faster than that.  And these\nare.")]),e._v(" "),t("p",[e._v("The way they work is that you hash the value you want to put into the\ncollection.  You end up with a 32 bit hash.  You are going to use the\nfirst 5 bits of that hash to see if there is a unique position in the\nfirst layer of your trie.  So effectively what is happening is you\nhave a 32-way branching going on in this trie.  In addition, there is\nsome fancy bit twiddling going on in each node so that those nodes are\nsparse.  They are not fully populated, so you are not wasting the\nspace of not fully populated nodes.")]),e._v(" "),t("p",[e._v("You end up using a combination of population, bit pop, and some\nalgorithms you copy out of \"Hacker's Delight\".  Buy that.  Or you can\njust use Clojure's.  In fact, Clojure's vectors, which is the same\nkind of technology, has been ported to Factor and Scala already, which\nis fine by me.")]),e._v(" "),t("p",[e._v("So if it is unique in the first 5 bits we are done.  We put it in the\nfirst level of the trie.  If it is not, we are going to look at the\nnext 5 bits and walk down one more level to the trie, until we find\nsome unique position, and then we are done.  We are going to put the\nvalue there.")]),e._v(" "),t("p",[e._v("The key thing about this is: how deep can this trie get?  So this one\nis the root so, down one two three four five six if you had, whatever,\n4 billion things.  So it branches extremely fast, and you can get a\nmillion items in depth three.  It is very very shallow.  So the\ncombination of it being very shallow, and using this bit twiddling to\nwalk through the sparsely populated nodes in the intermediate levels,\nmakes it really fast.  So that is the representation, now we only need\nto talk about: how do we make a changed version efficiently?")]),e._v(" "),t("p",[e._v("[Time 0:30:06]")]),e._v(" "),t("h2",{attrs:{id:"structural-sharing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#structural-sharing"}},[e._v("#")]),e._v(" Structural Sharing")]),e._v(" "),t("p",[t("img",{attrs:{src:a(315),alt:"00.30.06 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그리고 이 모든 것의 핵심은 구조적 공유입니다. 모든 함수형 데이터 구조는 기본적으로 재귀적으로 정의되며 구조적으로 재귀적으로 정의됩니다. 즉, 방금 만든 버전과 상당한 구조를 공유하는 새 버전을 만들 수 있습니다. 이것이 바로 효율적인 복사본 생성의 핵심입니다. 모든 것을 복사하는 것이 아닙니다. 아주 조금만 복사하는 것입니다. 얼마나 적은 양을 사용하는지 잠시 후에 그림으로 보여드리겠습니다.")]),e._v(" "),t("p",[e._v("모든 것이 불변하기 때문에 구조를 공유하는 것은 문제가 되지 않습니다. 공유하는 구조에 대해 아무것도 변경되지 않으므로 다중 스레드 사용에 안전합니다. 반복 작업에도 안전합니다. 말도 안 되는 반복을 하는 동안에는 변이가 일어나지 않습니다.")]),e._v(" "),t("p",[e._v("And the key there, as is true for all of these things, is structural\nsharing.  All functional data structures are essentially recursively\ndefined, structurally recursively defined.  Which means that you can\nmake a new version that shares substantial structure with the version\nyou just had.  And that is the key to making efficient copies.  You\nare not copying everything.  You are copying a very little bit.  I\nwill show you in a picture in a second how little a bit you use.")]),e._v(" "),t("p",[e._v("Since everything is immutable, sharing structure is no problem.\nNothing is going to change about the structure that you are sharing,\nwhich means it is safe for multi-threaded use.  It is safe for\niteration.  You get none of this mutated while iterating nonsense.")]),e._v(" "),t("p",[e._v("[Time 0:30:48]")]),e._v(" "),t("h2",{attrs:{id:"path-copying"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#path-copying"}},[e._v("#")]),e._v(" Path Copying")]),e._v(" "),t("p",[t("img",{attrs:{src:a(316),alt:"00.30.48 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그렇다면 구조를 어떻게 공유할까요? 경로 복사라는 기술을 사용합니다. 다시 말하지만, 이것은 모든 트라이 데이터 구조에 적용됩니다. 모두 똑같은 방식으로 작동하는데, 여기서 오른쪽 경로를 무시하면 이전에 보여드린 트라이가 됩니다. 잎이 15개 있습니다. 하단의 빨간색 윤곽선이 있는 보라색 친구 아래에 하나를 추가하고 싶습니다. 새 노드를 추가하고 싶습니다. 16번째 노드를 추가합니다.")]),e._v(" "),t("p",[e._v("새 자식을 추가할 것이므로 당연히 해당 노드의 복사본을 만들어야 합니다. 부모 노드의 복사본입니다. 그리고 마지막으로 루트입니다. 이 복사본에는 자식이 하나 더 추가되고 이전 버전의 나머지 구조는 공유됩니다.")]),e._v(" "),t("p",[e._v("그래서 3개 레벨에 백만 개의 항목을 저장할 수 있다고 했죠? 32 곱하기 32 곱하기 32, 제가 맞았나요? 아니요, 32,000개입니다. 엄청 많죠.")]),e._v(" "),t("p",[e._v("[청중 웃음]")]),e._v(" "),t("p",[e._v("음, 3 레벨 아래로. 루트까지 포함하면 4단계입니다. 이 마지막 레벨이 아무리 채워져 있어도 여기에 새 노드를 만들면 4개의 항목만 복사할 수 있습니다.")]),e._v(" "),t("p",[e._v("그 오래된 나무는 어때요? 여전히 괜찮아 보입니다. 건드리지 않았어요. 그리고 이것이 새 트리를 만들기 위해 복사해야 하는 경로이며, 이 추가 항목이 있는 새 트리처럼 보입니다. 이 루트를 더 이상 참조하지 않으면 더 이상 참조하지 않는 항목과 마찬가지로 가비지 컬렉션에 포함됩니다.")]),e._v(" "),t("p",[e._v("아주 기본적인 방법이지만, 많은 사람들이 이런 일이 가능하다는 사실을 잘 모르기 때문에 보여드리고 싶었습니다. 이런 종류의 데이터 구조는 특별한 이유가 없는 한 항상 사용해야 한다고 생각합니다. 이것이 바로 클로저가 이런 방식으로 작동하는 이유입니다. 모든 데이터 구조는 기본적으로 이렇게 작동합니다. 다른 것을 선택하려면 엄청난 노력을 기울여야 합니다.")]),e._v(" "),t("p",[e._v("So how do we share structure?  We use a technology called path\ncopying.  Again, this is true for all trie data structures.  They all\nwork exactly the same way, which is: if we ignore the right hand path\nhere, that is the trie I showed you before.  It has 15 leaves.  We\nwant to add one under that red outlined purple guy at the bottom.  We\nwant to add a new node.  Add a 16th guy.")]),e._v(" "),t("p",[e._v("So what needs to happen is: we need to make a copy of that node,\nobviously, because we are going to be giving him a new child.  A copy\nof his parent.  And finally, the root.  This copy gets one additional\nchild, and the rest of the structure of the old version was shared.")]),e._v(" "),t("p",[e._v("So I said 3 levels could hold a million items, right?  32 times 32\ntimes 32, did I get that right?  No, that is 32,000.  A lot.")]),e._v(" "),t("p",[e._v("[Audience laughter]")]),e._v(" "),t("p",[e._v("Well, 3 levels down.  If you count the root, it is 4 levels.  However\npopulated this last level was, making a new node here is only ever\ngoing to copy 4 items.")]),e._v(" "),t("p",[e._v("How is that old tree?  Looking good, still fine.  We did not touch it.\nAnd this is the path we need to copy to make the new one, which looks\nlike a new tree with this extra item.  If we are no longer referring\nto that root, it will get garbage collected, as will the things it was\nreferring to that are no longer referenced.")]),e._v(" "),t("p",[e._v("So it is kind of basic, but I want to show it because a lot of people\njust are not aware that this is a possible thing.  This is the kind of\ndata structure I think you should be using all the time unless you\nhave some emergency reason.  And that is why Clojure works this way.\nAll of the data structure work like this, by default.  You have to go\nthrough extraordinary efforts to pick something else.")]),e._v(" "),t("p",[e._v("[Time 0:32:40]")]),e._v(" "),t("h2",{attrs:{id:"coordination-methods"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#coordination-methods"}},[e._v("#")]),e._v(" Coordination Methods")]),e._v(" "),t("p",[t("img",{attrs:{src:a(317),alt:"00.32.40 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이것이 바로 복합 객체를 값으로 효율적으로 표현하는 방법입니다. 문제의 한 부분을 해결했습니다. 이제 조정 방법에 대해 이야기해야 합니다.")]),e._v(" "),t("p",[e._v("기존의 방식은 사실 방법이 아닙니다. 기존의 방식은 바로 여러분의 문제입니다. 스칼라 강연에서 변수가 있었는데, 휘발성 시맨틱을 가지고 있지는 않았지만 Java의 액터 라이브러리가 해당 변수의 내용이 다른 스레드에서 유효한지 확인하기 위해 메모리 펜스 효과를 발생시키는 동기화 작업을 수행하는 경우가 발생했습니다. 여러분의 프로그램에서는 이것이 걱정거리가 될 것입니다. 액터 라이브러리가 액터에서 변수를 처리하는 것은 좋은 일입니다. 하지만 그렇지 않은 프로그램의 변수는 여러분의 문제입니다.")]),e._v(" "),t("p",[e._v("일반적으로 복합 객체를 만들려면 잠금을 사용해야 합니다. 그리고 락의 문제점은 누구나 알고 있을 겁니다. 잠금의 문제점을 다들 아시나요? 자물쇠의 고통은 다들 아시나요? 자물쇠는 ... 전문가들은 자물쇠와 함께 작동하는 프로그램을 만들 수 있지만 대부분의 사람들은 그렇게 할 시간이나 에너지가 없으며 유지 관리가 정말 정말 어렵습니다. 매우 어렵습니다.")]),e._v(" "),t("p",[e._v("그래서 클로저에서 우리가 하려는 것은 그냥 약간의 간접성을 추가하는 것입니다. 메모리, 즉 변수를 직접 참조하는 대신 간접 지시를 사용할 것입니다. 그런 다음 이러한 참조에 동시성 의미를 추가할 것입니다. 어제 강연을 들으셨다면 이미 말씀드렸지만, 오늘은 좀 더 자세한 내용을 보여드리겠습니다.")]),e._v(" "),t("p",[e._v("So that is the way to efficiently represent composite objects as\nvalues.  We got one part of the problem solved.  Now we need to talk\nabout coordination methods.")]),e._v(" "),t("p",[e._v("The conventional way is not really a method.  The conventional way is:\nit is your problem.  We saw in the Scala talk, there was a var.  It\ndid not have volatile semantics, but it happened to be the case that\nthe actors library in Java conducts some synchronization thing which\ncauses a happens-before, happens-after memory fence effect, in order\nto make sure the contents of that var was valid in another thread.  In\nyour own program, that is going to be your worry.  It is nice that the\nactors library takes care of vars in actors.  But vars in your program\notherwise are your problem.")]),e._v(" "),t("p",[e._v("And typically if we are trying to do composite objects we have to use\nlocks.  And everybody knows the problems with locks, I think.\nEverybody know the problem with locks?  Everybody know the pain of\nlocks?  Locks are ...  Experts can build programs that work with\nlocks, but most people do not have the time or energy to do that well,\nand maintaining it is really really difficult.  It is "),t("em",[e._v("extremely")]),e._v("\ndifficult.")]),e._v(" "),t("p",[e._v("So in Clojure what we are going to just do is just add a level of\nindirection.  Instead of directly referring memory, those variables,\nwe are going to use indirection.  And then we are going to add\nconcurrency semantics to these references.  If you watched me talk\nyesterday I said that, but I will show you some more details today.")]),e._v(" "),t("p",[e._v("[Time 0:34:05]")]),e._v(" "),t("h2",{attrs:{id:"typical-oo-direct-references-to-mutable-objects"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#typical-oo-direct-references-to-mutable-objects"}},[e._v("#")]),e._v(" Typical OO - Direct references to Mutable Objects")]),e._v(" "),t("p",[t("img",{attrs:{src:a(318),alt:"00.34.05 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이것이 바로 많은 객체 지향 언어의 현재 세계 상태입니다. 동일한 메모리 덩어리에 대한 참조가 많이 있습니다. 기본적으로 모두에게 무료입니다. 그들은 일관된 객체를 볼 수 있고, 모든 부분이 서로 연관되어 있으며, 어떻게든 세상을 멈추지 않는 한 아무도 아무것도 만지작거리지 않는다는 것을 모릅니다.")]),e._v(" "),t("p",[e._v("하지만 이제 용어가 생겼으니 핵심 문제는 정체성과 가치를 통합하는 것이죠? 이 정체성에 대한 가치를 저장할 수 있는 유일한 장소는 동일한 메모리 조각뿐입니다. 이것이 문제입니다. 방금 새로운 가치를 만드는 방법을 살펴봤습니다. 훌륭하죠. 그럼 이제 어떻게 해야 할까요? 새로운 값을 표현할 새로운 메모리를 만들어야 합니다. 모든 값이 같은 메모리 공간에 저장되어야 한다고 하면 결코 좋은 결과를 얻을 수 없습니다. 여기에는 많은 문제가 있습니다.")]),e._v(" "),t("p",[e._v("So this, quickly, is the picture of the current state of the world in\na lot of object-oriented languages.  You have a lot of references to\nthe same chunk of memory.  Basically it is a free for all.  They do\nnot know they are going to see a consistent object, that all the parts\nare related to each other, that no one is twiddling with anything,\nunless they can somehow stop the world.")]),e._v(" "),t("p",[e._v("But the core problem here now that we have lingo for it is: this\nunifies identity and value, right?  The only place to put this value\nfor this identity is in the same piece of memory.  That is a problem.\nWe just looked at how to do new values.  It is great.  So what do we\nneed to do?  We need to create some new memory to represent that new\nvalue.  If we say all values of foo have to end up in the same chunk\nof memory space, we can never do a good job.  So that has a lot of\nproblems.")]),e._v(" "),t("p",[e._v("[Time 0:34:53]")]),e._v(" "),t("h2",{attrs:{id:"clojure-indirect-references-to-immutable-objects"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clojure-indirect-references-to-immutable-objects"}},[e._v("#")]),e._v(" Clojure - Indirect references to Immutable Objects")]),e._v(" "),t("p",[t("img",{attrs:{src:a(319),alt:"00.34.53 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이 문제를 어떻게 해결할 수 있을까요? 그냥 방향성을 사용하면 됩니다. 모든 컴퓨터 과학 문제에 대한 해결책이죠? 한 단계의 방향 전환으로 이제 옵션이 생겼습니다. 이 사람은 이제 불변이 될 수 있기 때문입니다. 이제 불변인 값과 이 작은 상자로 모델링할 아이덴티티를 분리했습니다.")]),e._v(" "),t("p",[e._v('값은 절대 변하지 않습니다. 아이덴티티의 현재 상태를 보려면 참조를 해제해야 합니다. "현재 상태를 알려주세요"라고 말해야 합니다. 그렇게 해서 얻을 수 있는 것은 변하지 않는 값입니다. 주자가 파울을 했는지 확인하기 위해 하루 종일 사진을 들여다보는 것과 마찬가지로 하루 종일 사진을 들여다볼 수 있습니다.')]),e._v(" "),t("p",[e._v("객체 지향 프로그래밍 언어의 캡슐화 기술이 이 문제에 대한 해결책이라고 생각한다면 그렇지 않다는 점을 강조하고 싶습니다. 객체 내부에 변수나 필드가 있고 해당 필드를 변경할 수 있는 메서드를 세 개 작성하고 사람들이 서로 다른 스레드에서 해당 메서드를 호출할 수 있다면 동시성 관점에서 아무것도 캡슐화하지 않은 것입니다. 문제를 분산시키고 무언가 뒤에 숨긴 것입니다.")]),e._v(" "),t("p",[e._v("How do you solve this?  You just use indirection.  It is the solution\nto all computer science problems, right?  One level of indirection,\nand now we have options.  Because this guy now can be immutable.  We\nhave separated the value, which is now immutable, and the identity,\nwhich we are going to model with these little boxes.")]),e._v(" "),t("p",[e._v('Values never change.  If you want to see the current state of an\nidentity, you have to dereference it.  You have to say "give me your\nstate".  What you get out of that is a value that cannot change.  You\ncan spend all day looking at it, just like you can spend all day\nlooking at the photo to try to see if the runner was fouled.')]),e._v(" "),t("p",[e._v("I want to emphasize, if you think your object oriented programming\nlanguage's encapsulation techniques are a solution to this problem,\nthat is "),t("em",[e._v("not")]),e._v(" true.  If you have a variable or a field inside your\nobject and you write three methods that can change that field, and\npeople can call those methods from different threads, you have not\nencapsulated "),t("em",[e._v("anything")]),e._v(" from a concurrency standpoint.  You have just\nspread the problem and hid it behind something.")]),e._v(" "),t("p",[e._v("[Time 0:35:57]")]),e._v(" "),t("h2",{attrs:{id:"clojure-references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clojure-references"}},[e._v("#")]),e._v(" Clojure references")]),e._v(" "),t("p",[t("img",{attrs:{src:a(320),alt:"00.35.57 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그래서 저는 이 상자들을 참조라고 부르겠습니다. 과부하가 걸린 용어가 너무 많습니다. 새로운 단어가 떠오르지 않습니다. 다른 것을 참조하기 때문에 참조입니다. 따라서 아이덴티티는 그 값을 참조하는 참조입니다.")]),e._v(" "),t("p",[e._v("하지만 중요한 것은 클로저에서는 자바로 넘어가서 자바를 사용하지 않는 한 이것들만 변형할 수 있다는 것입니다. 물론 클래스와 배열 등은 여전히 존재합니다. 하지만 클로저 모델을 따르고 싶다면 이러한 참조가 필요합니다. 이것들만 변경할 수 있습니다. 그리고 그들이 하는 일은 단지 시간을 관리하는 것입니다. 즉, 불변인 한 값에서 불변인 다른 값으로 원자적으로 이동할 수 있으며, 각 참조 유형은 시간에 대해 서로 다른 의미를 제공합니다.")]),e._v(" "),t("p",[e._v('그렇다면 이러한 의미론의 특징은 무엇일까요? 그 중 하나는 "내가 변경한 내용을 다른 사람들이 볼 수 있는가? 공유되는가?"입니다. 한 우주의 타임라인에는 나쁜 커크가 있고 다른 우주의 타임라인에는 좋은 커크가 있는데, 이 둘은 절대 만나지 않는 스타트렉 대체 우주 모델이 시간을 관리하는 한 가지 방법이 있기 때문입니다. 물론 이 모델의 문제점은 때때로 만나게 된다는 것입니다. 하지만 한 가지 방법은 고립입니다. 그래서 우리는 마지막 모델이 격리임을 알게 될 것입니다. 그러나 일반적으로 이러한 모델의 대부분은 프로그램의 다른 부분이 볼 수 있는 변경 사항을 만드는 것과 관련된 것이므로 공유를 사용합니다.')]),e._v(" "),t("p",[e._v("두 번째 부분은 동시성이며, 여기서는 지금이라는 의미의 동시성을 의미합니다. 지금이 호출자에게 무엇을 의미하는지. 다시 말해, 자기 관계적 관점에서 내가 요청하는 변화가 지금 일어날 것인가, 아니면 다른 시점에 나와 관련되어 일어날 것인가? 독립적인가? 그리고 우리는 이러한 차이를 동기적이라고 부를 것입니다. 만약 그것이 나와 관련하여 지금 일어난다면 그것은 동기적입니다. 나에 대해 지금 일어나지 않는다면 비동기적입니다. 미래의 어느 시점에 발생합니다. 정확히 언제라고 말할 수는 없습니다.")]),e._v(" "),t("p",[e._v("So I am going to call those boxes references.  We have too many\noverloaded terms.  I cannot think of any new words.  It is a reference\nbecause it refers to something else.  So identities are references\nthat refer to their values.")]),e._v(" "),t("p",[e._v("But the critical thing is: in Clojure these are the only things that\nyou can mutate, unless you drop to Java and use Java stuff.  Of course\nthere are still classes and arrays and all that.  But if you want to\nfollow the Clojure model, you are going to have these references.\nThey are the only things that can change.  And what they do is just\nmanage time.  In other words, you can atomically move from one value\nwhich is immutable, to another value which is immutable, and each of\nthe reference type provides different semantics for time.")]),e._v(" "),t("p",[e._v('So what are the characteristics of these semantics?  One of them is:\n"Can other people see these changes I am making?  Is it shared?"\nBecause there is one way to manage time, which is the Star Trek\nalternate universe model, where there is a bad Kirk in one universe\ntimeline, and a good Kirk in another, and they will never meet.  Of\ncourse the problem with that is that occasionally they do meet.  But\none way is isolation.  So we will see the last model is isolation.\nBut in general most of these models are around making changes that\nother parts of your program can see, so sharing.')]),e._v(" "),t("p",[e._v("The second part is synchronicity, and here we mean synchronicity in\nthe sense of now.  What now means to the caller.  In other words, from\na self-relative standpoint, is the change I am asking for going to\nhappen now, or at some other time, relative to me?  Is it independent?\nAnd we are going to call those differences synchronous.  If it happens\nnow relative to me it is synchronous.  If it does not happen now\nrelative to me it is asynchronous.  It just happens at some point in\nthe future.  We cannot say exactly when.")]),e._v(" "),t("p",[e._v("[Time 0:37:50]")]),e._v(" "),t("p",[e._v("그리고 다시 한 번 다양한 선택과 옵션이 제공되는 이러한 참조의 마지막 특징은 변경이 조정되었는지 여부입니다. 저는 독립적인 주자가 되어 혼자서 달릴 수 있고 완전히 괜찮습니다. 하지만 한 컬렉션에서 다른 컬렉션으로 무언가를 옮겨야 하는 경우가 많습니다. 두 컬렉션 모두에 있는 것은 절대 원하지 않으실 겁니다. 두 컬렉션 모두에 있는 것도 원치 않겠죠. 그러려면 조율이 필요합니다. 독립적인 자율 기관으로는 불가능합니다. 조율이 필요합니다.")]),e._v(" "),t("p",[e._v("그리고 결국 로컬의 경우 조정을 할 수 있습니다. 이런 식으로 조정을 분배하는 것은 아마도 바보 같은 심부름이지만 사람들은 계속 시도합니다. 저는 일관성 있는 분산 조정이 이루어질 것이라고 생각하지 않지만, 사람들은 이미 일관성을 기꺼이 늦추면 조정을 할 수 있다는 사실을 인식하고 있습니다. 하지만 로컬 모델에서는 조율된 변화를 얻는 것이 완벽하게 가능합니다.")]),e._v(" "),t("p",[e._v("그렇지 않으면 변화는 자율적입니다. 나 혼자서 변화합니다. 나는 당신이 무엇을 하든 상관하지 않으며, 우리 둘이 함께 무언가를 할 수 없습니다.")]),e._v(" "),t("p",[e._v("이제 우리는이 세 가지 특성을 가지고 있습니다. 클로저에는 이 3가지 영역에서 서로 다른 선택을 하는 4가지 유형의 레퍼런스가 있습니다. 참조는 공유되고, 사람들은 변경 사항을 볼 수 있으며, 동기화되고, 지금 바로 변경됩니다. 트랜잭션에서 변경되므로 동일한 트랜잭션에서 둘 이상의 참조를 변경할 수 있으며 이러한 변경 사항이 조정됩니다. 가장 어려운 문제는 바로 이 조정된 변경 문제입니다.")]),e._v(" "),t("p",[e._v("에이전트는 자율적입니다. 에이전트는 마치 배우 모델에서 배우처럼 느껴질 것입니다. 공유되고 사람들이 볼 수 있습니다. 비동기식이기 때문에 변경을 요청하면 미래의 어느 시점에 변경이 이루어질 것이지만 즉시 다시 돌아올 수 있습니다. 그리고 자율적입니다. 에이전트의 활동을 조정하지 않습니다.")]),e._v(" "),t("p",[e._v("And the final characteristic of these references, where again you get\ndifferent choices and options, is whether or not the change is\ncoordinated.  I can be an independent runner and run all by myself,\nand I am completely fine.  But a lot of times you need to move\nsomething from one collection to another collection.  You do not ever\nwant it to be in both.  You do not ever want it to be in neither.\nThat requires coordination.  That is impossible to do with independent\nautonomous entities.  You need coordination.")]),e._v(" "),t("p",[e._v("And it ends up that in the local case you can do coordination.\nDistributing coordination like this is a fool's errand probably, but\npeople keep trying.  I do not think that there is ever going to be\ndistributed coherent coordinated change, but people are already\nrecognizing the fact that if you are willing to delay consistency, you\ncan sort of have coordination.  But in the local model, it is\nperfectly possible to get coordinated change.")]),e._v(" "),t("p",[e._v("Otherwise, change is autonomous.  I change by myself.  I do not care\nwhat you are doing, and no two of us can do something together.")]),e._v(" "),t("p",[e._v("So now we have these 3 characteristics.  Clojure has 4 types of\nreferences that make different choices in these 3 areas.  Refs are\nshared, people can see the changes, they are synchronous, they change\nright now.  They change in a transaction, which means that you can\nchange more than one reference in the same transaction and those\nchanges will be coordinated.  Sort of the hardest problem is that\ncoordinated change problem.")]),e._v(" "),t("p",[e._v("Agents are autonomous.  They will feel a lot more like actors in an\nactor model.  They are shared, people can see them.  They are\nasynchronous, so you ask for a change, it is going to happen at some\npoint in the future, but you are going to immediately return.  And\nthey are autonomous.  There is no coordinating the activities of\nagents.")]),e._v(" "),t("p",[e._v("[Time 0:39:42]")]),e._v(" "),t("p",[e._v("원자는 공유됩니다. 사람들은 변화를 볼 수 있습니다. 동기적입니다. 지금 바로 일어나기 때문에 이것이 에이전트와의 차이점입니다. 또한 자율적입니다. 단일 작업 단위에서 두 개 이상의 원자를 변경할 수 없습니다.")]),e._v(" "),t("p",[e._v("마지막으로 클로저에는 변수라는 것이 있습니다. 이는 좋은 커크 나쁜 커크 대체 우주 모델을 사용하여 변경 사항을 분리합니다. 모든 ID에는 모든 스레드에 고유한 값이 있습니다. 다른 스레드에서는 변경 사항을 볼 수 없습니다. 그것에 대해 너무 많이 이야기하지는 않겠지만, 이것은 Lisps에서 파생된 일종의 특수 목적 구조입니다.")]),e._v(" "),t("p",[e._v("Atoms are shared.  People can see the changes.  They are synchronous.\nThey happen right now, so that is the difference between them and\nagents.  And they are also autonomous.  You cannot change more than\none atom in a single unit of work.")]),e._v(" "),t("p",[e._v("And finally, Clojure has something called vars.  They isolate changes\nwith the good Kirk bad Kirk alternate universe model.  For any\nidentity there is a unique value in every thread.  You cannot possibly\nsee the changes in different threads.  I am not going to talk too much\nabout that, but it is kind of a special purpose construct derived from\nLisps.")]),e._v(" "),t("p",[e._v("[Time 0:40:17]")]),e._v(" "),t("h2",{attrs:{id:"uniform-state-transition-model"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#uniform-state-transition-model"}},[e._v("#")]),e._v(" Uniform state transition model")]),e._v(" "),t("p",[t("img",{attrs:{src:a(321),alt:"00.40.17 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이러한 참조가 작동하는 방식에서 좋은 점 중 하나는 균일한 상태 전환 모델을 가지고 있다는 점입니다. 이들 모두는 상태를 변경하는, 즉 한 상태에서 다른 상태로 이동하는 서로 다른 함수를 가지고 있습니다. 그리고 서로 다른 의미를 가지고 있기 때문에 서로 다른 이름을 사용합니다. 사람들이 이것이 동기식인지 비동기식인지, 아니면 트랜잭션이 필요한 것인지 혼동하지 않았으면 합니다.")]),e._v(" "),t("p",[e._v('하지만 모델은 항상 동일합니다. 변경 함수 중 하나를 호출할 것입니다. 참조인 상자를 전달하고 "이 함수를 사용해 주세요"라고 말할 것입니다. 따라서 이러한 인수가 포함된 함수를 전달하고 상자의 현재 상태에 적용하고 반환 값을 새 상태로 사용할 수 있습니다. 따라서 함수는 원자 단위로, 트랜잭션 내에서, 어떤 식으로든 몇 가지 제약 조건에 따라 현재 상태를 전달받게 됩니다. 현재 상태가 전달됩니다. 새로운 상태를 계산할 수 있습니다. 여기서도 전달되는 것은 순수한 함수입니다. 그 새로운 상태가 참조의 새로운 값이 됩니다.')]),e._v(" "),t("p",[e._v("클로저의 참조에서는 참조를 역참조하면 항상 참조의 현재 상태를 볼 수 있습니다. 즉, 완전히 자유롭게 할 수 있기 때문에 로컬 가시성이라는 것입니다. 그리고 그렇게 할 수 있기 때문에 훨씬 더 효율적인 프로그램을 만들 수 있습니다. 컬렉션을 보고 싶을 때마다 컬렉션을 볼 수 있는 권한을 요청해야 한다면 로컬 컨텍스트에서는 작동하지 않습니다.")]),e._v(" "),t("p",[e._v("또한 이러한 것들의 다른 공통된 속성 중 하나는 사용자 잠금이 없고, 이 작업을 수행하기 위한 잠금이 없으며, 이러한 구조 중 어느 것도 교착 상태에 빠질 수 없다는 것입니다.")]),e._v(" "),t("p",[e._v("One of the things that is nice about the way these references work is:\nthey have a uniform state transition model.  All of them have\ndifferent functions that change the state, that say: move from one\nstate to another state.  And they use different names because they\nhave different semantics.  I do not want people to get all confused\nabout: is this happening synchronously or asynchronously, or do I need\na transaction?")]),e._v(" "),t("p",[e._v('But the model is always the same.  You are going to call one of the\nchanging functions.  You are going to pass the reference, the box, and\nyou are going to say, "Please use this function".  So you are going to\npass a function, maybe with these arguments, apply it to the current\nstate of the box, and use its return value as the new state.  So the\nfunction will be passed the current state, under some constraints,\neither atomically, within a transaction, some way.  It will be passed\nthe current state.  It can calculate a new state.  Again it is a pure\nfunction you are passing.  That new state becomes the new value of the\nreference.')]),e._v(" "),t("p",[e._v("In Clojure's references, you can always see the current state of a\nreference by dereferencing it.  In other words, that is the local\nvisibility, because it is completely free to do.  And it yields much\nmore efficient programs, to be able to do that.  If you have to ask\nfor permission to see collections every time you want to see them, it\ndoes not work in the local context.")]),e._v(" "),t("p",[e._v("In addition, one of the other shared attributes of these things is\nthat there is no user locking, you do not have any locking to do this\nwork, and none of these constructs can deadlock.")]),e._v(" "),t("p",[e._v("[Time 0:41:45]")]),e._v(" "),t("h2",{attrs:{id:"persistent-edit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#persistent-edit"}},[e._v("#")]),e._v(" Persistent 'Edit'")]),e._v(" "),t("p",[t("img",{attrs:{src:a(322),alt:"00.41.45 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그렇다면 이 새로운 세상에서 무언가를 편집한다는 것은 무엇을 의미할까요? 값에 대한 참조를 갖게 될 것입니다. 우리는 새로운 값을 단품으로 만들 수 있습니다. 함수를 호출하고 새로운 값을 만들어서 새로운 상태인 foo가 되게 할 것입니다.")]),e._v(" "),t("p",[e._v("새 값은 이전 값의 함수입니다. 구조를 공유할 수 있습니다. 방금 보셨죠? 이렇게 해도 foo를 읽는 사람이 방해받지 않습니다. 그들은 완전히 자유롭게 계속 읽을 수 있습니다. 우리가 새로운 버전의 foo를 알아내는 동안 멈출 필요가 없습니다.")]),e._v(" "),t("p",[e._v("또한, 사람들이 읽는 것에 방해가 되지 않습니다. 새 버전을 만들기 위해 사람들이 읽기를 멈출 때까지 기다릴 필요가 없습니다. 이것이 바로 높은 처리량의 동시성을 위해 필요한 것입니다.")]),e._v(" "),t("p",[e._v("So what does it mean to edit something in this new world?  You are\ngoing to have a reference to a value.  We can make a new value a la\ncarte, on the side.  We are going to call a function and create this\nnew value, which we intend to become the new state of foo.")]),e._v(" "),t("p",[e._v("The new values are a function of the old.  They can share structure.\nWe just saw that.  Doing this does not impede anybody who is reading\nfoo.  They are completely free to keep reading.  They do not have to\nstop while we figure out the new version of foo.")]),e._v(" "),t("p",[e._v("In addition, it is not impeded by people reading.  We do not have to\nwait for people to stop reading so we can start making a new version.\nThis is the kind of thing you are going to need for high-throughput\nconcurrency.")]),e._v(" "),t("p",[e._v("[Time 0:42:25]")]),e._v(" "),t("h2",{attrs:{id:"atomic-state-transition"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#atomic-state-transition"}},[e._v("#")]),e._v(" Atomic State Transition")]),e._v(" "),t("p",[t("img",{attrs:{src:a(323),alt:"00.42.25 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그리고 새로운 상태로 이동하는 것은 이 상자를 원자 단위로 바꿔서 새로운 불변의 값을 확인하는 것입니다. 이는 항상 조율됩니다. 이런 일이 일어나는 방식에는 항상 규칙이 있습니다. 방금 여러 의미론을 보여드렸습니다. 이 일이 발생한 후 누군가가 이 상자를 다시 참조할 때마다 새로운 값을 보게 됩니다.")]),e._v(" "),t("p",[e._v("소비자는 영향을 받지 않습니다. 이전 가치를 보고 있었다면 이런 일이 발생해도 방해받지 않습니다. 저는 그저 오래된 가치를 보고 있을 뿐입니다. 마치 달리기 선수의 사진을 보고 있는 것과 같습니다. 레이스가 끝났다는 것을 압니다. 괜찮습니다. 우리는 그렇게 행동해야 합니다.")]),e._v(" "),t("p",[e._v("저처럼 오랫동안 프로그래밍을 해왔다면 '내가 세상을 소유한다'는 생각에서 벗어나기가 정말 어렵습니다. 그리고 내가 세상을 멈춘다. 내가 가라고 하면 세상은 간다.\" 그런 생각에서 벗어나야 합니다. 그것이 미래입니다. 우리는 반드시 최신 데이터가 아닌 데이터로 작업하게 될 것이라는 점을 이해해야 합니다. 그것이 바로 우리의 미래입니다.")]),e._v(" "),t("p",[e._v("And then going to a new state is just an atomic swapping of this box\nto look at the new immutable value.  That is always coordinated.\nThere are always rules for how that happens.  I just showed you the\nmultiple semantics.  Any time somebody dereferences this after -- more\ntime words -- after this happens, they will see the new value.")]),e._v(" "),t("p",[e._v("Consumers are unaffected.  If I was looking at the old value, I do not\nget disturbed by this happening.  I am just looking at an old value.\nIt is like I am looking at a picture of the runner to see.  I know the\nrace is over.  That is OK.  We "),t("em",[e._v("need")]),e._v(" to behave that way.")]),e._v(" "),t("p",[e._v('If you have been programming for so long as I have, it is really hard\nto break from, "I own the world.  And I stop the world.  The world\ngoes when I say go."  We have to just break from that.  That is the\nfuture.  We have to understand that we are going to be working with\ndata that is not necessarily the very latest data.  That is just the\nfuture for us.')]),e._v(" "),t("p",[e._v("[Time 0:43:18]")]),e._v(" "),t("h2",{attrs:{id:"refs-and-transactions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#refs-and-transactions"}},[e._v("#")]),e._v(" Refs and Transactions")]),e._v(" "),t("p",[t("img",{attrs:{src:a(324),alt:"00.43.18 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("자, 제가 말씀드린 것처럼 하드 레퍼런스는 트랜잭션 레퍼런스입니다. 클로저에는 소프트웨어 트랜잭션 메모리 시스템이 있습니다. 저는 이 용어를 사용하는 것이 거의 싫은데, 사람들이 STM을 마치 한 가지인 것처럼 비판하는 것을 좋아하기 때문입니다. 다양한 STM이 존재합니다. 근본적으로 다른 특성을 가지고 있습니다. 클로저는 다른 것과 근본적으로 다릅니다.")]),e._v(" "),t("p",[e._v("하지만 기본적으로 데이터베이스 모델과 매우 흡사한 모델이라는 몇 가지 공통점이 있습니다. 트랜잭션 내에서만 변경할 수 있습니다. 트랜잭션 내에서 전체 참조, 참조 집합에 대한 모든 변경은 함께 일어나거나 전혀 일어나지 않습니다. 이것이 바로 원자성입니다. 트랜잭션을 실행하는 동안에는 다른 트랜잭션의 영향을 볼 수 없습니다. 그들은 여러분의 효과를 보지 못합니다. 이것이 바로 정상입니다.")]),e._v(" "),t("p",[e._v("STM 거래의 한 가지 독특한 점은 투기적이라는 것입니다. 당신은 이기지 못할 수도 있습니다. 다른 사람이 이길 수도 있습니다. 특정 한도까지 자동으로 재시도되므로 거래에 부작용이 포함될 수 없습니다.")]),e._v(" "),t("p",[e._v("OK, so the hard reference, as I said, are the transactional ones.\nClojure has a software transactional memory system.  I almost hate\nusing this term because people like to criticize STM as if it was one\nthing.  There are a whole bunch of different STMs.  They have\nradically different characteristics.  Clojure's is radically different\nfrom the other ones.")]),e._v(" "),t("p",[e._v("But they all share some things, which is basically a model that feels\na lot like a database model.  You can only change them within a\ntransaction.  All the changes you make to an entire set of references,\nrefs, inside a transaction, happen together, or none of them happen.\nThat is atomicity.  You do not see the effects of any other\ntransactions while you are running.  They do not see your effects.  It\nis the normal things.")]),e._v(" "),t("p",[e._v("The one unique thing about STM transactions is that they are\nspeculative.  You may not win.  Somebody else may win.  You will\nautomatically retry up to a certain limit, which means that your\ntransactions cannot contain side effects.")]),e._v(" "),t("p",[e._v("[Time 0:44:15]")]),e._v(" "),t("h2",{attrs:{id:"the-clojure-stm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-clojure-stm"}},[e._v("#")]),e._v(" The Clojure STM")]),e._v(" "),t("p",[t("img",{attrs:{src:a(325),alt:"00.44.15 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이것이 바로 코디를 하는 방식입니다. 이런 기술 없이는 실제로 조정을 할 수 없습니다. 독립된 개체에 시스템을 구축하고 이런 종류의 작업을 할 수는 없습니다.")]),e._v(" "),t("p",[e._v('그렇다면 실제로는 어떻게 할까요? 코드를 도싱크로 감싸면 되는데, 이는 트랜잭션이라는 의미일 뿐입니다. 제가 설명한 대로 작동하는 두 가지 함수인 alter와 commute가 있습니다. 이 두 함수는 참조와 함수, 인수를 받아 "트랜잭션의 참조에 이 값을 적용하고 반환값을 새 상태로 만듭니다."라고 말합니다.')]),e._v(" "),t("p",[e._v("내부적으로 Clojure는 다중 버전 동시성 제어(MVCC)를 사용하는데, 이는 실제 세계에서 작동하는 방식으로 STM을 수행하는 데 매우 중요한 구성 요소라고 생각합니다. 많은 STM 설계는 객체 지향 언어를 사용하여 필드를 두드리는 끔찍한 방식으로 앱을 작성하면 STM이 마술처럼 개선해줄 것이라고 생각합니다.")]),e._v(" "),t("p",[e._v("저는 전혀 그렇게 생각하지 않습니다. 클로저의 STM은 그런 종류의 작업을 위해 설계되지 않았습니다. 객체의 모든 부분을 참조로 만들면 작동하지 않을 것이며 방금 방법을 설명했기 때문에 기분이 나쁘지 않을 것입니다. 객체를 값으로 만들고 그 값을 원자 단위로 바꾸면 모든 것이 더 좋아집니다.")]),e._v(" "),t("p",[e._v('하지만 대부분의 STM이 "읽기 추적"이라는 작업을 수행하기 때문에 사람들은 STM을 보편적으로 비판할 수 있습니다. 트랜잭션이 진행되는 동안 나쁜 일이 일어나지 않도록 하기 위해 모든 쓰기뿐만 아니라 모든 읽기까지 추적합니다. 저는 또한 그것이 작동하지 않을 것이라고 믿습니다. 그래서 클로저는 읽기 추적을 하지 않습니다.')]),e._v(" "),t("p",[e._v("이를 달성하는 방법은 다중 버전 동시성 제어라는 기술을 사용하는 것인데, 이는 Oracle과 PostgreSQL이 데이터베이스로 작동하는 방식으로, 기본적으로 이전 값을 유지하여 트랜잭션에 대한 스냅샷을 제공하는 동시에 쓰기 중인 다른 트랜잭션은 계속 진행할 수 있습니다. 이는 결국 매우 효과적입니다.")]),e._v(" "),t("p",[e._v("하지만 값에 대한 참조를 사용해야 할 필요성이 없어집니다. 여러분을 위해 오래된 값을 보관하는 것은 비용이 많이 들어야 합니다. 방금 영구 데이터 구조를 사용하는 경우 비용이 얼마나 저렴한지 보여드렸습니다. 이 모든 것이 함께 진행됩니다. 이 모든 것을 함께하지 않으면 제 생각에는이 문제에 대한 답이 없습니다. 하지만 이렇게 하면 정말 좋습니다. 따라서 MVCC STM은 읽기 추적을 수행하지 않습니다.")]),e._v(" "),t("p",[e._v("This is the way you do coordination.  You cannot really do\ncoordination without some technique like this.  You cannot build a\nsystem on independent entities and do this kind of work.")]),e._v(" "),t("p",[e._v("So in practice what do you do?  You just wrap your code with "),t("code",[e._v("dosync")]),e._v(',\nwhich just means this is a transaction.  There are two functions alter\nand commute, which work like I described.  They take a reference and a\nfunction and some args and say, "apply this to the reference in the\ntransaction and make the return value the new state."')]),e._v(" "),t("p",[e._v("Internally Clojure uses multiversion concurrency control (MVCC) which\nI also think is a very critical component to doing STM in a way that\nis going to work in the real world.  A lot of STM designs are: you\njust write your app in the terrible way you were, with your object\noriented language, banging on fields, and STM is magically going to\nmake that better.")]),e._v(" "),t("p",[e._v("I do not believe in that at all.  Clojure's STM is not designed for\nthat kind of work.  If you make every part of your object a ref, it is\nnot going to work and I am not going to feel bad for you, because I\njust explained how to do it.  You make your object the value and\natomically switch that value, and everything is better.")]),e._v(" "),t("p",[e._v("But you do have this issue of, again, people would criticize STMs\nuniversally, because "),t("em",[e._v("most")]),e._v(' STMs do something called "read tracking".\nIn order to make sure that nothing bad happened while your transaction\nwas going on, they track every '),t("em",[e._v("read")]),e._v(" that you do, in addition to all\nthe writes that you do.  I also believe that that is not going to\nwork.  So Clojure does no read tracking.")]),e._v(" "),t("p",[e._v("The way it accomplishes that is with a technique called Multiversion\nConcurrency Control, which is the way Oracle and PostgreSQL work as\ndatabases, where essentially old values can be kept around in order to\nprovide a snapshot of the world for transactions, while other\ntransactions that are writing can continue.  That ends up being\nextremely effective.")]),e._v(" "),t("p",[e._v("But it falls out of this necessity to be using references to "),t("em",[e._v("values")]),e._v(".\nIt has got to be cheap for me to keep an old value around for you.  I\njust showed you how it is cheap, if you are using persistent data\nstructures.  All these things go together.  If you do not do all of\nthis stuff together, you do not have an answer to this problem, in my\nopinion.  But when you do this, it is really nice.  So MVCC STM does\nnot do read tracking.")]),e._v(" "),t("p",[e._v("[Time 0:46:24]")]),e._v(" "),t("h2",{attrs:{id:"refs-in-action"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#refs-in-action"}},[e._v("#")]),e._v(" Refs in action")]),e._v(" "),t("p",[t("img",{attrs:{src:a(326),alt:"00.46.24 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그렇다면 실제로는 어떤 모습일까요? 우리는 foo를 참조로 정의합니다. 이는 해당 맵에 대한 트랜잭션 상자입니다. foo를 역참조하면 그 안에 무엇이 있는지 확인할 수 있습니다. 안타깝게도 해시 맵이기 때문에 이름 순서가 변경되므로 반복 순서를 보장하지 않습니다.")]),e._v(" "),t("p",[e._v('이제 foo 내부의 값을 조작할 수 있습니다. "foo 안에 있는 맵을 주고, a 키를 lucy와 연결해줘"라고 말할 수 있습니다. 그러면 새로운 값이 반환됩니다. 그 어떤 것도 참조에 영향을 미치지 않습니다. 값을 제거했습니다. 다른 값을 만들었습니다. 트랜잭션 시스템 외부에서 모든 종류의 계산을 완전히 수행할 수 있습니다. 여전히 함수형 프로그래밍 언어입니다. 값을 꺼내서 함수형 프로그램을 작성하면 됩니다. 그래서 그것은 foo에 아무런 영향을 미치지 않았습니다.')]),e._v(" "),t("p",[e._v("참조를 취하고, 참조를 함수 어소시에이션으로 통근하고, 맵에 값을 추가하고, 키 a와 값 루시를 추가하는 커뮤트 함수를 사용할 수 있습니다. 트랜잭션 내부의 참조에 대해서만 이 작업을 수행할 수 있다는 참조에 대한 의미가 있기 때문에 실패합니다. 그래서 오류가 발생합니다.")]),e._v(" "),t("p",[e._v("그러나 동일한 작업을 트랜잭션 내부에 넣으면 성공합니다. 그리고 트랜잭션이 완료되면 이것이 바로 foo의 값입니다.")]),e._v(" "),t("p",[e._v("So what does it looks like in practice?  We define foo to be a ref.\nThat is a transactional box to that map.  We can dereference foo, and\nwe see what is in there.  Unfortunately the name order changes because\nthey are hash maps, so they do not guarantee any order of iteration.")]),e._v(" "),t("p",[e._v('We can go and manipulate the value inside foo.  We can say, "give me\nthe map that is inside foo, and associate the '),t("code",[e._v("a")]),e._v(" key with "),t("code",[e._v("lucy")]),e._v('".\nThat returns a new value.  Nothing about that impacted the reference.\nI took the value out.  I made another value.  We can do all kinds of\ncalculations completely outside of the transactional system.  It is\nstill a functional programming language.  Get the value out and write\nfunctional programs.  So that did not have any effect on foo.')]),e._v(" "),t("p",[e._v("We can go and we can use that "),t("code",[e._v("commute")]),e._v(" function, which actually says:\ntake a reference, commute a reference with a function "),t("code",[e._v("assoc")]),e._v(", which\nadds a value to a map, the key "),t("code",[e._v("a")]),e._v(" and the value "),t("code",[e._v("lucy")]),e._v(".  And that\nfails, because there is a semantics to those refs which is that you\ncan only do this for refs inside a transaction.  So you get an error.")]),e._v(" "),t("p",[e._v("If however you put that same work inside a transaction, it succeeds.\nAnd when the transaction is complete, that is the value of foo.")]),e._v(" "),t("p",[e._v("[Time 0:47:40]")]),e._v(" "),t("h2",{attrs:{id:"implementation-stm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#implementation-stm"}},[e._v("#")]),e._v(" Implementation - STM")]),e._v(" "),t("p",[t("img",{attrs:{src:a(327),alt:"00.47.40 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("구현 세부 사항에 대해 이야기 할 시간이 많지 않습니다. 하지만 다시 한 번 말씀드리지만, STM이 한 가지라고 생각하지 마세요. STM에 대한 논문을 하나만 읽었다면 STM에 대해 아무것도 모르는 것입니다. STM에 관한 모든 논문을 읽었다면 STM에 대해 아무것도 모르는 것이 아니라 조금 아는 것입니다. 우리 중 누구도 STM에 대해 아무것도 모릅니다. 이것은 여전히 연구 주제입니다.")]),e._v(" "),t("p",[e._v("하지만 제가 아는 것은 이것이 작동하고 정말 잘 작동하며 잠금을 사용하지 않는 프로그램을 쉽게 작성할 수 있다는 것입니다. 지금까지 제가 작성한 모든 프로그램에서 조정된 변경이 필요할 때 언제든지 이 방법을 사용할 수 있었을 것이고, 괜찮았을 것이라고 생각합니다. 사람들은 그것을 두드리고 확장성 문제 등을 밀어붙일 수 있습니다. 정확성의 관점에서 보면 이것은 신의 선물입니다.")]),e._v(" "),t("p",[e._v("하지만 내부를 들여다보면 일부 STM과 달리 Clojure의 STM은 낙관적으로 돌아가지 않습니다. 잠금을 사용합니다. 대기 알림을 사용하며 이탈하지 않습니다. 프로세스는 다른 프로세스를 기다립니다. 교착 상태 감지 기능이 있습니다. 나이 기반 바게징이 있습니다. 트랜잭션 시스템에서 공유할 수 있는 최소한의 양은 사실 타임스탬프에 대한 하나의 CAS입니다.")]),e._v(" "),t("p",[e._v("사람들은 80개의 스레드로 하나의 CAS를 계속 망치질할 수 있다는 것을 보여줬는데, 이것이 확장성의 한계에 가깝습니다. 그러나 실제로 트랜잭션에 약간의 작업이 있을 때는 문제가 되지 않습니다. 저는 600개의 코어를 가진 Azul 박스에서 작업을 실행해봤는데, 그 CAS는 문제가 되지 않았습니다.")]),e._v(" "),t("p",[e._v("제가 말했듯이 읽기 추적은 없습니다. 이 STM은 거친 방향을 위해 설계된 것이 중요합니다. 기존에 하던 일을 할 수 있는 뱀 오일 STM이 아닙니다. 이 새로운 일을 해야 합니다. 불변 값에 대한 참조를 사용해야만 제 STM을 사용할 수 있습니다. 그렇다고 해서 기존 프로그램이 좋아지지는 않습니다.")]),e._v(" "),t("p",[e._v("독자가 작가에게 방해받지 않고, 그 반대의 경우도 마찬가지입니다. 또한 출퇴근도 지원하는데, 지금은 설명할 시간이 없습니다.")]),e._v(" "),t("p",[e._v("I do not have a lot of time to talk about the implementation details.\nBut again, do not think that STM is one thing.  If you have read one\npaper on STM, you know nothing about STM.  If you have read all the\npapers about STM, you know a little bit more than nothing about STM.\nNone of us knows anything about STM.  This is still a research topic.")]),e._v(" "),t("p",[e._v("But I do know this: this works, and it works really well, and it makes\nit easy to write programs that do not use locks.  I think all the\nprograms that I have written in my career, I could have used this any\ntime I needed coordinated change, and it would have been fine.  People\ncan bang on it and try to push the scalability issues and whatnot.\nFrom a correctness standpoint, this is a godsend.")]),e._v(" "),t("p",[e._v("However, inside, unlike some STMs, Clojure's STM is not spinning\noptimistic.  It does use locks.  It uses wait notify, it does not\nchurn.  Processes will wait for other processes.  It has got deadlock\ndetection.  It has got age-based barging.  There is extreme minimum --\nin fact, I think what is actually the minimum amount -- of sharing in\na transactional system, which is one CAS, which is for the timestamps.")]),e._v(" "),t("p",[e._v("People have demonstrated you can hammer on one CAS continuously with\n80 threads, and that is about the limit of scalability.  But when you\nactually have some work in your transactions, it is no problem.  I\nhave run stuff on an Azul box with 600 cores, and that CAS is not\ngoing to be the problem.")]),e._v(" "),t("p",[e._v("As I said there is no read tracking.  It is important that this STM is\ndesigned for coarse-grained orientation.  It is not one of these\nsnake-oil STMs that you can do what you were doing.  You have to do\nthis new thing.  You have to use references to immutable values, then\nyou can use my STM.  It is not going to make your old programs good.")]),e._v(" "),t("p",[e._v("And readers do not then get impeded by writers, and vice versa.  It\nalso supports commute, which I do not really have time to explain\nright now.")]),e._v(" "),t("p",[e._v("[Time 0:49:33]")]),e._v(" "),t("h2",{attrs:{id:"agents"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#agents"}},[e._v("#")]),e._v(" Agents")]),e._v(" "),t("p",[t("img",{attrs:{src:a(328),alt:"00.49.33 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("다른 모델을 하나 보여드리고 싶은데, 매우 다르지만 매우 같다는 점에서 좋은 모델입니다. 값에서 변화를 분리했기 때문에 시간에 대해 완전히 다른 접근 방식을 취할 수 있습니다.")]),e._v(" "),t("p",[e._v('따라서 이러한 참조 셀의 또 다른 종류인 에이전트에서 각 에이전트는 완전히 독립적입니다. 각 에이전트는 고유한 상태를 가지며 다른 에이전트와 조정할 수 없습니다. 상태 변경은 액션을 통해 이루어지며, 액션은 본질적으로 보내기 또는 보내기라는 함수를 사용하여 에이전트에게 보내는 일반적인 함수일 뿐입니다. 이 함수는 즉시 반환됩니다. 예를 들어 "미래의 어느 시점에 이 인수를 사용하여 에이전트의 현재 값에 이 함수를 적용하고 함수의 반환 값을 에이전트의 새 상태로 만듭니다."라는 식으로 이 함수와 일부 데이터를 보낼 수 있습니다.')]),e._v(" "),t("p",[e._v("이는 스레드 풀의 스레드에서 비동기적으로 발생합니다. 에이전트당 한 번에 하나의 작업만 수행되므로 에이전트에는 기본적으로 일종의 입력 메일함 대기열이 있습니다. 따라서 에이전트는 모든 작업을 순차적으로 수행합니다. 이것은 에이전트의 의미론에 대한 또 다른 약속입니다.")]),e._v(" "),t("p",[e._v("I do want to show you one other model, because it is very different,\nAnd it is nice in that it is very different, yet very much the same.\nBecause we have sort of isolated change from values, you can take a\ncompletely different approach to time.")]),e._v(" "),t("p",[e._v("So in an agent, which is another kind of these reference cells, each\nagent is completely independent.  They have their own state and they\ncannot be coordinated with any other.  State change is through\nactions, which are essentially just ordinary functions that you are\ngoing to send to the agent with a function called "),t("code",[e._v("send")]),e._v(" or\n"),t("code",[e._v("send-off")]),e._v('.  That function is going to return immediately.  You are\ngoing to send this function and some data, say, "at some point in the\nfuture, apply this function to the current value of the agent with\nthese arguments, and make the return value of the function the new\nstate of the agent."')]),e._v(" "),t("p",[e._v("That happens asynchronously on a thread from a thread-pool.  Only one\naction per agent happens at a time, so agents essentially have sort of\nan input mailbox queue.  So they also do all of their work serially.\nThis is another promise of the semantics of an agent.")]),e._v(" "),t("p",[e._v("[Time 0:50:38]")]),e._v(" "),t("h2",{attrs:{id:"agents-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#agents-2"}},[e._v("#")]),e._v(" Agents")]),e._v(" "),t("p",[t("img",{attrs:{src:a(329),alt:"00.50.38 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이 함수는 어떻게 사용할 수 있을까요? 지도를 참조하는 에이전트가 되려면 def foo라고 말합니다. 참조를 해제합니다. 지도의 내용을 봅니다. 그 참조를 동일한 함수 associate :a를 루시에게 보냅니다. 저는 바로 그것을 봅니다. 아직 표시되지 않을 수도 있습니다. 어느 정도 시간이 지날 것입니다. 약속할 수는 없습니다. 그리고 나면 달라질 겁니다.")]),e._v(" "),t("p",[e._v("이것은 사물에 대한 다른 사고 방식이지만 Erlang으로 프로그래밍하는 사람들은 이런 방식으로 사물을 생각하면서 놀라운 일을 완전히 해냅니다. 비동기적일 수 있습니다. 마치 컴퓨터가 예전 Apple이고 자신과 자신의 어셈블리 언어만 있고 자신이 우주의 왕인 것처럼 계속 프로그래밍할 수는 없습니다. 이제는 모든 일이 동시에 일어납니다.")]),e._v(" "),t("p",[e._v("Again as with the other reference types, you can just dereference it\nand see what is in there.  If you do successive actions to agents\ninside the same action, they are held until the action completes, so\nthey can see the new state.")]),e._v(" "),t("p",[e._v('The agents do coordinate with transactions, which is kind of nice.  So\none of the problems is you saw, "no side effects in transactions".  So\nyou are wondering, how do I let somebody know I completed this\ntransaction successfully?  Do I need to send them a message, or do\nsomething side effect-y?  It ends up that if you send an agent action\nduring a transaction, that is held until the transaction commits.  So\nif the transaction gets retried, those messages do not go out until\nthe transaction actually succeeds.  So that coordination is a really\nnice feature.  These two things work together.')]),e._v(" "),t("p",[e._v("They are not quite actors.  The difference with an actor model is:\nthat is a distributed model.  You do not have direct access to the\nstate in an actor model, because you cannot distribute that.  Since I\nam not doing distribution, I can let you access the state directly,\nwhich means it is a suitable place to put something that you actually\nmay need to share a lot, without necessarily serializing activity.")]),e._v(" "),t("p",[e._v("[Time 0:51:40]")]),e._v(" "),t("h2",{attrs:{id:"agents-in-action"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#agents-in-action"}},[e._v("#")]),e._v(" Agents in Action")]),e._v(" "),t("p",[t("img",{attrs:{src:a(330),alt:"00.51.40 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이 함수는 어떻게 사용할 수 있을까요? 지도를 참조하는 에이전트가 되려면 def foo라고 말합니다. 참조를 해제합니다. 지도의 내용을 봅니다. 그 참조를 동일한 함수 associate :a를 루시에게 보냅니다. 저는 바로 그것을 봅니다. 아직 표시되지 않을 수도 있습니다. 어느 정도 시간이 지날 것입니다. 약속할 수는 없습니다. 그리고 나면 달라질 겁니다.")]),e._v(" "),t("p",[e._v("이것은 사물에 대한 다른 사고 방식이지만 Erlang으로 프로그래밍하는 사람들은 이런 방식으로 사물을 생각하면서 놀라운 일을 완전히 해냅니다. 비동기적일 수 있습니다. 마치 컴퓨터가 예전 Apple이고 자신과 자신의 어셈블리 언어만 있고 자신이 우주의 왕인 것처럼 계속 프로그래밍할 수는 없습니다. 이제는 모든 일이 동시에 일어납니다.")]),e._v(" "),t("p",[e._v("So what does this look like to use?  I say "),t("code",[e._v("def foo")]),e._v(" to be an "),t("code",[e._v("agent")]),e._v("\nreferring to a map.  I dereference it.  I see the contents of the map.\nI send that reference the same function "),t("code",[e._v("associate")]),e._v(" "),t("code",[e._v(":a")]),e._v(" with "),t("code",[e._v("lucy")]),e._v(".\nI look at it right away.  It may not be there yet.  Some amount of\ntime will pass.  I cannot promise you what.  And then it will be\ndifferent.")]),e._v(" "),t("p",[e._v("This is a different way of thinking about things, but people who\nprogram in Erlang completely do amazing things with thinking about\nthings this way.  Things can be asynchronous.  You cannot keep\nprogramming your computer as if it was your old Apple and there was\nonly you and your assembly language and you were king of the universe.\nThings happen at the same time now.")]),e._v(" "),t("p",[e._v("[Time 0:52:27]")]),e._v(" "),t("h2",{attrs:{id:"atoms"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#atoms"}},[e._v("#")]),e._v(" Atoms")]),e._v(" "),t("p",[t("img",{attrs:{src:a(331),alt:"00.52.27 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("원자는 에이전트와 매우 유사한 이야기입니다. 원자는 독립적입니다. 원자에 대한 변경을 조정할 수 없습니다. 상태 변경 함수에는 다른 이름이 있습니다. 스왑이라고 합니다. 다시 말하지만 이전 상태의 일반 함수를 새 상태로 가져옵니다. 변경은 이제 동기적으로 발생하므로 이것이 원자와 에이전트의 차이점입니다. 지금 바로 일어나고 있습니다.")]),e._v(" "),t("p",[e._v('이것이 비교 및 스왑 모델입니다. 비교 및 스왑 또는 비교 및 설정은 비교 및 설정 메모리를 보고 "이 메모리로 바뀌었으면 좋겠어."라고 말할 수 있는 원시적인 방식입니다. 그리고 그것이 여전히 그 상태일 때만 이것으로 바뀝니다. 그래서 당신은 그것을 봅니다. 그것이 그것임을 알 수 있습니다. 당신은 그것을 이것으로 바꾸고 싶습니다. 여전히 저것이라면 내부에서 원자적으로 "좋아, 이렇게 만들겠습니다."라고 말할 것입니다.')]),e._v(" "),t("p",[e._v("CAS 자체의 문제점은 일반적으로 값을 읽고 무언가를 수행한 다음 다시 넣기를 원한다는 것입니다. 따라서 값을 본 시점과 CAS를 수행하려고 할 때 사이에 간격이 생깁니다. 물론 이 작업을 수행한 후 다른 사람이 무언가를 수행했다면 CAS는 실패할 것입니다. 그러면 어떻게 해야 할까요? 일반적으로 CAS가 적절한 데이터 구조인 잘 작성된 CAS에는 약간의 스핀 루프가 있습니다. 여러분은 값을 CAS로 회전시킬 것입니다. 원자가 여러분을 위해 회전을 합니다. 결과적으로 함수는 두 번 이상 호출될 수 있습니다.")]),e._v(" "),t("p",[e._v("다시 말하지만, 트랜잭션과 원자 모두에서 두 번 이상 호출되어야 하기 때문에 부작용이 없는 함수로 프로그래밍해야 하는 세상에 살고 있습니다. 따라서 부작용을 피해야 하지만, 이를 통해 얻을 수 있는 가치는 성공했을 때 함수가 전달된 값에 적용된 함수를 알 수 있고, 입력된 결과에는 해당 원자에서 개입 활동이 발생하지 않았다는 것입니다. 이것이 바로 여러분이 가져야 할 강력한 구조입니다.")]),e._v(" "),t("p",[e._v("Atoms, a very similar story to agents.  They are independent.  You\ncannot coordinate change to atoms.  There is a different name for the\nstate change function.  It is called "),t("code",[e._v("swap")]),e._v(".  Again it takes an\nordinary function of the old state to the new state.  The change\nhappens "),t("em",[e._v("synchronously")]),e._v(" now, so that is the difference between atoms\nand agents.  It happens right now.")]),e._v(" "),t("p",[e._v('This is a model for compare and swap.  Compare and swap, or compare\nand set, is a primitive that is going to let you look at a piece of\ncompare and set memory and say, "I want it to turn in to this."  And\nit will turn into this only if it is still that.  So you look at it.\nYou see it is that.  You want to turn it into this.  If it is still\nthat, inside atomically it will say, OK I will make it this.')]),e._v(" "),t("p",[e._v("The problem with CAS by itself is: you usually want to read the value,\ndo something with it, and then put it back.  So you get this interval\nbetween when you looked at it, and when you try to do the CAS.  And of\ncourse when you do that, and somebody else has done something, that\nCAS is going to fail.  And then what do you do?  Typically, a well\nwritten CAS thing, where CAS is a suitable data structure, will have a\nlittle spin loop.  You are going to spin in a value into a CAS.  Atoms\ndo the spinning for you.  As a result, the function may be called more\nthan once.")]),e._v(" "),t("p",[e._v("Again, we are in this world where you should be programming with these\nside effect free functions, because they need to be called more than\nonce, both in transactions and in atoms.  So you have to avoid side\neffects, but the value you get out of this is that when you succeed,\nyou know the function you applied was applied to the value the\nfunction was passed, and the result that got put in had no intervening\nactivity occur on that atom.  That is a powerful construct you need to\nhave.")]),e._v(" "),t("p",[e._v("[Time 0:54:08]")]),e._v(" "),t("h2",{attrs:{id:"atoms-in-action"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#atoms-in-action"}},[e._v("#")]),e._v(" Atoms in Action")]),e._v(" "),t("p",[t("img",{attrs:{src:a(332),alt:"00.54.08 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("그리고 이것들을 보세요. 다른 지도와 매우 비슷해 보입니다. foo를 해당 지도를 참조하는 원자로 정의합니다. 그것을 참조 해제하면 거기에 있습니다. 교환합니다. 즉시 새로운 값을 얻습니다.")]),e._v(" "),t("p",[e._v("And look at these.  It looks a lot like the other ones.  Define "),t("code",[e._v("foo")]),e._v("\nto be an "),t("code",[e._v("atom")]),e._v(" that refers to that map.  Dereference it, it is there.\nWe swap.  Immediately we get the new value.")]),e._v(" "),t("p",[e._v("[Time 0:54:22]")]),e._v(" "),t("h2",{attrs:{id:"uniform-state-transition"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#uniform-state-transition"}},[e._v("#")]),e._v(" Uniform state transition")]),e._v(" "),t("p",[t("img",{attrs:{src:a(333),alt:"00.54.22 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("이것이 바로 균일한 상태 전환 모델입니다. 이것이 바로 참조의 모습입니다. 트랜잭션을 시작하고, 커밋하거나 변경합니다. 함수와 몇 가지 인수를 전달하는 참조입니다. 함수의 결과가 새로운 값입니다.")]),e._v(" "),t("p",[e._v("에이전트는 완전히 다른 시간 의미를 제외하고는 동일합니다. 일정 시간이 지난 후 스레드 풀에서 비동기적으로 발생합니다. 즉시 반환됩니다.")]),e._v(" "),t("p",[e._v("원자, 지금 바로 발생하지만 다른 원자들과는 독립적입니다.")]),e._v(" "),t("p",[e._v("특히 로컬 모델에서 실제 멀티 스레드 프로그램을 작성하려면 이러한 모든 것이 필요합니다. 이것들은 모두 프로그램의 로컬 부분에서 동시 프로그램을 작성하는 데 필요한 모든 것들이며, 그것들 없이는 할 수 없다고 생각합니다. 그래서 여기에 있지만 균일 한 방법입니다.")]),e._v(" "),t("p",[e._v("So this is the uniform state transition model.  That is what refs look\nlike.  Start a transaction, commute or alter.  Your ref, passing a\nfunction and some arguments.  The result of the function is your new\nvalue.")]),e._v(" "),t("p",[e._v("Agents, same thing, except completely different time semantics.  It\nhappens asynchronously in a thread-pool, some time later.  You return\nimmediately.")]),e._v(" "),t("p",[e._v("Atoms, happen right now, but are independent from the others.")]),e._v(" "),t("p",[e._v("You need all of these things to write a real multi-threaded program,\nespecially in the local model.  These are all things that I have\nneeded to do in my career writing concurrent programs in the local\npart of the program, and I do not think you can do without them.  So\nhere they are, but it is a uniform way to go.")]),e._v(" "),t("p",[e._v("[Time 0:54:57]")]),e._v(" "),t("h2",{attrs:{id:"summary"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),t("p",[t("img",{attrs:{src:a(334),alt:"00.54.57 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("요약하자면, 함수형 프로그래밍에서 불변 값은 매우 중요합니다. 하지만 결국 상태에도 매우 중요합니다. 불변 값 없이는 시간과 상태를 제대로 관리할 수 없습니다. 시간과 값이라는 두 가지가 변하도록 내버려두면 신뢰할 수 있는 어떤 것도 할 수 없습니다.")]),e._v(" "),t("p",[e._v("영구 데이터 구조를 사용하면 복합 객체를 효율적이고 불변하게 표현할 수 있습니다. 값에 대한 불변성의 제약을 받아들일 수 있다면 이러한 모든 옵션을 사용할 수 있습니다. 저는 의미가 약간 다른 다섯 번째 참조 유형을 작업하고 있습니다. 시간 관리와 가치 관리를 분리했기 때문에 쉽게 할 수 있습니다.")]),e._v(" "),t("p",[e._v("마지막으로, 이것은 사용하기 매우 쉽다고 생각합니다. 다른 모델을 보셨다면, 이것은 작동하는 변수와 매우 유사합니다.")]),e._v(" "),t("p",[e._v("So, in summary, immutable values are critical for functional\nprogramming.  But it ends up they are also critical for state.  We\ncannot really manage time and state without immutable values.  If you\nyou are going to let two things change, time and value, you cannot do\nanything that is reliable.")]),e._v(" "),t("p",[e._v("Persistent data structures let you represent composite objects\nefficiently, immutably.  Once you are able to accept this constraint\nof immutability on your values, you have all of these options.  I am\nworking on a fifth reference type with slightly different semantics.\nIt is easy to do, because I have separated time management from value\nmanagement.")]),e._v(" "),t("p",[e._v("Finally, I think this is pretty easy to use.  If you have seen some\nother models, this is a lot like variables that work.")]),e._v(" "),t("p",[e._v("[Time 0:55:51]")]),e._v(" "),t("h2",{attrs:{id:"thanks-for-listening"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#thanks-for-listening"}},[e._v("#")]),e._v(" Thanks for listening!")]),e._v(" "),t("p",[t("img",{attrs:{src:a(335),alt:"00.55.51 PersistentDataStructure"}})]),e._v(" "),t("p",[e._v("감사합니다!")]),e._v(" "),t("p",[e._v("So, thank you!")]),e._v(" "),t("p",[e._v("[Time 0:55:52]")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/PersistentDataStructure.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("원문"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=o.exports}}]);