<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>프로그래밍 인 액션</title>
    <meta name="generator" content="VuePress 1.9.9">
    <script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-FZZE483ETN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
      
        gtag('config', 'G-FZZE483ETN');      
    </script>
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.a471a02c.css" as="style"><link rel="preload" href="/assets/js/app.8eead098.js" as="script"><link rel="preload" href="/assets/js/6.5cfa5282.js" as="script"><link rel="preload" href="/assets/js/28.616b8c2f.js" as="script"><link rel="prefetch" href="/assets/js/10.1bc3d943.js"><link rel="prefetch" href="/assets/js/11.18aecc2e.js"><link rel="prefetch" href="/assets/js/12.0f6995fb.js"><link rel="prefetch" href="/assets/js/13.d1e47c85.js"><link rel="prefetch" href="/assets/js/14.04c1e3cd.js"><link rel="prefetch" href="/assets/js/15.7634eb2e.js"><link rel="prefetch" href="/assets/js/16.e7b5b12f.js"><link rel="prefetch" href="/assets/js/17.077b7aff.js"><link rel="prefetch" href="/assets/js/18.385998a5.js"><link rel="prefetch" href="/assets/js/19.edc92b47.js"><link rel="prefetch" href="/assets/js/2.540d1b33.js"><link rel="prefetch" href="/assets/js/20.c0794e87.js"><link rel="prefetch" href="/assets/js/21.c9e3ea69.js"><link rel="prefetch" href="/assets/js/22.5b54f678.js"><link rel="prefetch" href="/assets/js/23.07f6101e.js"><link rel="prefetch" href="/assets/js/24.3178700c.js"><link rel="prefetch" href="/assets/js/25.5466da51.js"><link rel="prefetch" href="/assets/js/26.d16ec0e0.js"><link rel="prefetch" href="/assets/js/27.60cbad3d.js"><link rel="prefetch" href="/assets/js/29.60eb2bb9.js"><link rel="prefetch" href="/assets/js/3.6a339483.js"><link rel="prefetch" href="/assets/js/30.926affe7.js"><link rel="prefetch" href="/assets/js/31.34de4dba.js"><link rel="prefetch" href="/assets/js/32.335f6f04.js"><link rel="prefetch" href="/assets/js/33.8fca5103.js"><link rel="prefetch" href="/assets/js/34.f2d20cdc.js"><link rel="prefetch" href="/assets/js/35.09b256f0.js"><link rel="prefetch" href="/assets/js/36.b13d6b9b.js"><link rel="prefetch" href="/assets/js/37.a1fb05ef.js"><link rel="prefetch" href="/assets/js/38.9d11e83f.js"><link rel="prefetch" href="/assets/js/39.577feb17.js"><link rel="prefetch" href="/assets/js/4.dc20e8a4.js"><link rel="prefetch" href="/assets/js/40.86023459.js"><link rel="prefetch" href="/assets/js/41.4d41e8d7.js"><link rel="prefetch" href="/assets/js/42.c4620975.js"><link rel="prefetch" href="/assets/js/43.9a1db1cd.js"><link rel="prefetch" href="/assets/js/44.bef60950.js"><link rel="prefetch" href="/assets/js/5.221d601f.js"><link rel="prefetch" href="/assets/js/7.5aa03c37.js"><link rel="prefetch" href="/assets/js/8.c5761a72.js"><link rel="prefetch" href="/assets/js/9.dba8f914.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a471a02c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">프로그래밍 인 액션</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/clojure/" class="nav-link router-link-active">
  Clojure
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/clojure/" class="nav-link router-link-active">
  Clojure
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>clojure books</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/clojure/clojure_distilled" class="sidebar-heading clickable router-link-active open"><span>Clojure 증류하기 (Clojure Distilled)</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/clojure/clojure_distilled/01-Intro.html" class="sidebar-link">서문</a></li><li><a href="/clojure/clojure_distilled/02-Immutable.html" class="sidebar-link">함수형 언어의 이점</a></li><li><a href="/clojure/clojure_distilled/11-Clojure_In_Action.html" class="sidebar-link">클로저 인 액션(Clojure In Action)</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/clojure/clojure_spells" class="sidebar-heading clickable"><span>Clojure로 주문읽기(casting spells in clojure)</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>columns &amp; lectures</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="clojure-엑기스-뽑기-clojure-distilled"><a href="#clojure-엑기스-뽑기-clojure-distilled" class="header-anchor">#</a> Clojure 엑기스 뽑기 (Clojure Distilled)</h1> <p>Clojure를 배우는 것의 어려움은 매우 간단한 구문에서 오는 것이 아니라 문제를 해결하기 위한 새로운 방법을 배워야 하는 것에서 비롯됩니다. 따라서 핵심 개념을 이해하고 이를 결합하여 문제를 함수형으로 해결하는 방법에 중점을 둘 것입니다.</p> <p>The difficulty in learning Clojure does not stem from its syntax, which happens to be extremely simple, but from having to learn new methods for solving problems. As such, we'll focus on understanding the core concepts and how they can be combined to solve problems the functional way.</p> <p>모든 주류 언어는 같은 어족에 속합니다. 일단 당신이 이 언어들 중 하나를 배우면 다른 언어를 배우는 데는 거의 노력이 필요하지 않습니다. 일반적으로, 여러분이 해야 할 일은 생산적이 되기 위해 표준 라이브러리에서 몇 가지 구문 설탕과 유용한 기능들을 배우는 것입니다. 여기저기에 새로운 개념이 있을 수도 있지만, 당신의 기존 기술 대부분은 쉽게 이전할 수 있습니다.</p> <p>All the mainstream languages belong to the same family. Once you learn one of these languages there is very little effort involved in learning another. Generally, all you have to do is learn some syntax sugar and the useful functions in the standard library to become productive. There might be a new concept here and there, but most of your existing skills are easily transferable.</p> <p>Clojure는 그렇지 않습니다. 리스프 방언이기 때문에, 그것은 다른 언어 계열에서 왔으며 효과적으로 사용하기 위해서는 새로운 개념을 배워야 합니다. 코드가 처음에 읽기 어려워 보인다면 낙담할 이유가 없습니다. 저는 이 구문이 본질적으로 이해하기 어려운 것은 아니며, 약간의 연습을 통해 여러분은 이 구문이 완전히 반대임을 알게 될 것이라고 확신합니다.</p> <p>This is not the case with Clojure. Being a Lisp dialect, it comes from a different family of languages and requires learning new concepts in order to use effectively. There is no reason to be discouraged if the code appears hard to read at first. I assure you that the syntax is not inherently difficult to understand, and that with a bit of practice you might find it to be quite the opposite.</p> <p>이 가이드의 목적은 Clojure를 사용하여 생산성을 높이는 데 필요한 핵심 개념의 개요를 제공하는 것입니다. 먼저 함수형 스타일의 주요 이점과 함수형 언어를 왜 배우려고 하는지 살펴보도록 하겠습니다.</p> <p>The goal of this guide is to provide an overview of the core concepts necessary to become productive with Clojure. Let's start by examining some of the key advantages of the functional style and why you would want to learn a functional language in the first place.</p> <h2 id="불변성-immutable"><a href="#불변성-immutable" class="header-anchor">#</a> 불변성(Immutable)</h2> <p>클로저는 함수형 언어입니다. 따라서 대규모 응용프로그램을 작성하기를 겨냥하고 있습니다. 애플리케이션이 성장함에 따라 구성 요소를 분리하여 추론할 수 있어야 합니다. 반대로, 테스트 가능하고 재사용 가능한 구성 요소로 코드를 구축하는 것은 많은 가치가 있습니다. 여기서 함수형 접근 방식이 왜 적합한지 살펴보겠습니다.</p> <p>Clojure is a functional language. This makes it extremely well positioned for writing large applications. As the application grows it's imperative to be able to reason about its constituent parts in isolation. Conversely, there is a lot of value in building code out of components that are testable and reusable by nature. Let's take a look at why the functional approach is such a good fit here.</p> <p>함수형 언어는 글로벌 상태를 피하고 불변성을 기본값으로 선호하기 때문에 대규모 응용 프로그램을 작성하는 데 이상적입니다. 불변의 공유 상태를 가지면 애플리케이션의 일부를 분리하여 안전하게 추론할 수 있습니다. 언뜻 보기에 불변의 데이터 구조를 사용한다는 생각은 불필요하게 제한적으로 들립니다. 그러나 곧 알게 되겠지만 함수형 스타일과 관련된 많은 이점은 직접적으로 발생합니다.</p> <p>Functional languages are ideal for writing large applications because they eschew global state and favor immutability as the default. Having immutable shared state allows us to safely reason about parts of the application in isolation. At first glance, the idea of using immutable data structures sounds unnecessarily restrictive. However, as we'll soon see, many of the benefits associated with the functional style stem directly from it.</p> <p>가변 데이터는 값 또는 참조를 통해 전달될 수 있습니다. 안전한 접근 방식은 데이터에 대한 변경 사항이 로컬 범위에 유지되도록 보장하기 때문에 값으로 데이터를 전달하는 것입니다. 안타깝게도 이 접근 방식은 매우 비효율적이므로 대부분의 언어가 대신 참조를 통해 데이터를 전달합니다.</p> <p>Mutable data can either be passed around by value or by reference. The safe approach would be to pass the data by value as it guarantees that any changes to the data will remain in the local scope. Unfortunately, this approach is extremely inefficient, so most languages pass data by reference instead.</p> <p>참조로 데이터를 전달하는 것은 빠르지만 코드를 추론하기 어렵게 만듭니다. 데이터를 안전하게 사용하려면 데이터가 참조될 수 있는 모든 위치를 알아야 합니다. 애플리케이션의 크기에 따라 복잡성이 증가합니다. 코드가 데이터에 더 많이 액세스할수록 더 유명한 공을 머리 속에서 저글링해야 합니다.</p> <p>Passing data by reference is fast, but it makes the code difficult to reason about. In order to safely work with the data you have to know all the places where it might be referenced. The complexity grows with the size of the application. The more code has access to a piece of data the more proverbial balls you end up having to juggle in your head.</p> <p>불변의 데이터 구조는 위의 딜레마에 대한 기발한 대안을 제공합니다. 데이터 구조를 변경할 때마다 수정본이 생성됩니다. 이제 우리는 데이터를 단순하게 복사하여 제공하는 것과 동일한 보장을 받지만, 변경 사항의 크기에 비례하는 가격만 지불합니다.</p> <p>Immutable data structures provide us with an ingenious alternative to the above dilemma. Every time a change is made to the data structure a revision is created. We now have the same guarantees offered by naive copying of the data, but we only pay the price proportional to the size of the change.</p> <p>가비지 컬렉션을 사용하면 데이터 할당 및 할당 해제를 수동으로 추적할 필요가 없는 것처럼 불변의 데이터 구조를 사용하면 데이터 참조를 수동으로 관리할 필요가 없습니다. 사용자의 관점에서 볼 때, 우리는 언제든지 데이터를 &quot;복사&quot;할 수 있습니다. 이 언어는 더 이상 사용되지 않을 때 어떤 부분을 청소할 수 있는지를 파악하는 데 도움이 됩니다.</p> <p>Just like garbage collection frees us from having to manually track data allocation and deallocation, immutable data structures free us from having to manage data references by hand. From the user perspective we simply &quot;copy&quot; the data any time we make a change. The language will take care of figuring out what parts of it can be cleaned up when they're no longer used.</p> <p>이러한 데이터 구조를 갖는 것은 순수한 기능을 쉽게 작성할 수 있습니다. 순수한 함수는 단순히 부작용이 없는 함수입니다. 이러한 기능은 입력 외부의 상태에 의존하지 않으며 실행 시 외부 상태를 수정하지 않습니다. 동일한 매개 변수가 주어지면 함수는 응용 프로그램의 전체 상태에 관계없이 항상 동일한 결과를 생성합니다.</p> <p>Having such data structures facilitates writing pure functions. A pure function is simply a function without side effects. These functions do not rely on any state outside their inputs and they do not modify any external state when they run. Given the same parameters, the function will always produce the same result, regardless of the global state of the application.</p> <p>이러한 기능은 로컬 범위만 수정할 수 있기 때문에 분리하여 안전하게 추론할 수 있습니다. 그들은 우리에게 복잡한 행동을 만들기 위해 구성될 수 있는 자체적인 구성요소를 제공합니다. 이러한 유형의 코드를 참조 투명 코드라고 합니다.</p> <p>Such functions can be safely reasoned about in isolation because we can guarantee that they're only able to modify their local scope. They provide us with self-contained components that can be composed to create complex behaviors. This type of code is referred to as being referentially transparent.</p> <h2 id="reusable"><a href="#reusable" class="header-anchor">#</a> Reusable</h2> <p>Object-oriented languages use classes for composition. The data in each class is tightly coupled to the logic associated with it. Each class represents a specific domain and the methods written in it are not easily reusable outside that domain. When we wish to reuse the existing code we often have to resort to patterns such as adapters and wrappers.</p> <p>The focus, in such a language, is primarily on modeling the state using classes. The data is seen as being incidental to the whole process. Functional programming brings data to the forefront and it encourages us to think about our problems in terms of data transformations.</p> <p>In a functional language, the logic and the data are kept separate. Clojure provides a small set of common data structures such as lists, vectors, maps, and sets. All the functions in the language operate on the same data structures allowing us to combine them without any additional ceremony. With this approach the function becomes the core reusable component.</p> <p>Each function represents a certain transformation that we wish to apply to our data. When we need to solve a problem we simply have to break it up into a sequence of transformations and map those to the appropriate functions. The functions capture how the tasks are accomplished, while their composition states what is being accomplished. Code that separates what is being done from how it is done is referred to as being declarative.</p> <p>Let's take iteration as an example. With the imperative style we would write a loop and put the logic that's invoked during each step inside it. By contrast, the functional approach is to use an iterator function and pass the logic that we want to execute during the iteration as a parameter.</p> <p>An iterator function can be written once and it encapsulates all the logic required for iteration, edge cases, and boundary checks. We can now reuse this function without having to worry about remembering to do these checks each time we need to iterate.</p> <h2 id="scalable"><a href="#scalable" class="header-anchor">#</a> Scalable</h2> <p>The focus on immutability makes it much easier to tackle the difficult problems of parallelism and concurrency. While there is no silver bullet for addressing either problem, the language can go a long way in helping us reason about them.</p> <p>As you'll recall, pure functions rely solely on their arguments and do not modify any state outside their scope. These properties make it possible to safely run them in parallel allowing us to easily take advantage of the extra cores.</p> <p>An example of this is mapping a function over the items in a collection. We can start by using the <code>map</code> function. This function will iterate over a collection and apply a transformer function to each element inside it. Should we discover that each operation takes a significant amount of time, we can then simply switch to using the <code>pmap</code> function to run these operations in parallel.</p> <p>Finally, it turns out that the immutable data structures are also an excellent tool for managing shared mutable state. Clojure provides a Software Transactional Memory (STM) library based on these data structures. With transactional memory we no longer have to worry about manual locking when dealing with threads. Better still, shared state backed by immutable data only needs to be locked for writing since the current revision can be safely read while the new revision is being generated.</p> <h1 id="clojure-in-action"><a href="#clojure-in-action" class="header-anchor">#</a> Clojure In Action</h1> <p>Now that we've discussed some of the reasons to start using the functional style, let's see how to apply these ideas in practice with Clojure.</p> <h2 id="the-core"><a href="#the-core" class="header-anchor">#</a> The Core</h2> <h3 id="data-types"><a href="#data-types" class="header-anchor">#</a> Data Types</h3> <p>Clojure provides a number of standard data types, most of which should look familiar:</p> <ul><li>Vars provide mutable storage locations. These can be bound and rebound on a per-thread basis.</li> <li>Booleans can have a value of true or false; nil values are also treated as false.</li> <li>Numbers can be integers, doubles, floats, and fractions.</li> <li>Symbols are used as identifiers for variables.</li> <li>Keywords are symbols that reference themselves and are denoted by a colon; these are often used as keys in maps.</li> <li>Strings are denoted by double quotes and can span multiple lines.</li> <li>Characters are denoted by a preceding backslash.</li> <li>Regular expressions are strings prefixed with a hash symbol.</li></ul> <p>In addition to the data types, Clojure provides us with a literal notation for common collection types such as lists, vectors, maps, and sets:</p> <ul><li>List: <code>'(1 2 3)</code></li> <li>Vector: <code>[1 2 3]</code></li> <li>Map: <code>{:foo &quot;a&quot; :bar &quot;b&quot;}</code></li> <li>Set: <code>#{&quot;a&quot; &quot;b&quot; &quot;c&quot;}</code></li></ul> <p>Interestingly, Clojure logic is written using its data structures. Using the same syntax for both data and logic allows for powerful metaprogramming features. We can manipulate any piece of Clojure code just like we would any other data structure. This feature makes it trivial to template the code for recurring patterns in your problem domain. In Clojure, code is data and data is code.</p> <h3 id="special-forms"><a href="#special-forms" class="header-anchor">#</a> Special Forms</h3> <p>Special forms provide a small set of primitives, such as the <code>if</code> conditional, that define the core syntax. These are akin to reserved keywords found in other languages. However, unlike most languages, Clojure uses a minimal amount of reserved syntax and majority of the language is implemented using functions and macros in the standard library.</p> <h2 id="functions"><a href="#functions" class="header-anchor">#</a> Functions</h2> <p>Function calls in Clojure work the same as any mainstream languages. The main difference being that the function name comes after the paren in the Clojure version.</p> <div class="language- extra-class"><pre><code>functionName(param1, param2)


(function-name param1 param2)
</code></pre></div><p>There is a very simple reason for this difference. The function call is simply a list containing the function name and its parameters. In Clojure, a list is a special type of data structure reserved for creating callable expressions. To create a list data structure we'd have to call the list function:</p> <div class="language- extra-class"><pre><code>(list 1 2 3)
</code></pre></div><h3 id="anonymous-functions"><a href="#anonymous-functions" class="header-anchor">#</a> Anonymous Functions</h3> <p>As the name implies, anonymous functions are simply functions that aren't bound to a name. Let's take a look at the following function that accepts a single argument and prints it:</p> <div class="language- extra-class"><pre><code>(fn [arg] (println arg))
</code></pre></div><p>The function is defined by using the <code>fn</code> form followed by the vector containing its argument and the body. We could call the above function by setting it as a first item in a list and its argument as the second:</p> <div class="language- extra-class"><pre><code>((fn [arg] (println arg)) &quot;hello&quot;)
=&gt;&quot;hello&quot;
</code></pre></div><p>Clojure provides syntactic sugar for defining anonymous functions using the <code>#</code> notation. With it we can rewrite our function more concisely as follows:</p> <div class="language- extra-class"><pre><code>#(println %)
</code></pre></div><p>Here, the <code>%</code> symbol indicates an unnamed argument. Multiple arguments would each be followed by a number indicating its position as seen below:</p> <div class="language- extra-class"><pre><code>#(println %1 %2 %3)
</code></pre></div><p>This type of function is useful when you need to perform a one-off computations that don't warrant defining a named function. They are commonly used in conjunction with the higher-order functions that we'll see in a moment.</p> <h3 id="named-functions"><a href="#named-functions" class="header-anchor">#</a> Named Functions</h3> <p>Named functions are simply anonymous functions bound to a symbol used as an identifier. Clojure provides a special form called <code>def</code> that's used for creating global variables. It accepts a name and the body to be assigned to it. We can create a named function using the <code>def</code> form as follows:</p> <div class="language- extra-class"><pre><code>(def double
  (fn [x] (* 2 x)))
</code></pre></div><p>Since this is such a common operation, Clojure provides a form called <code>defn</code> that does it for us:</p> <div class="language- extra-class"><pre><code>(defn square [x]
  (* x x))
</code></pre></div><p>The <code>defn</code> form behaves the same as the <code>fn</code> form we saw above, except that its first argument is the name of the function. The body of the function can consist of multiple expressions:</p> <div class="language- extra-class"><pre><code>(defn bmi [height weight]
  (println &quot;height:&quot; height)
  (println &quot;weight:&quot; weight)
  (/ weight (* height height)))
</code></pre></div><p>Here we define a function to calculate the BMI using the height and weight parameters. The body consists of two print statements and a call to divide the weight by the square of the height. All the expressions are evaluated from the inside out. In the last statement, <code>(* height height)</code> is evaluated, then the weight is divided by the result and returned. In Clojure, mathematical operators, such as <code>/</code> and <code>*</code>, are regular functions and so we call them using the prefix notation as we would with any other function.</p> <p>Note that only the result from the last expression is returned from the function, the results of all the other expressions are discarded. Therefore, any intermediate expressions should strictly be used for side effects as is the case with the <code>println</code> calls above.</p> <p>One thing to note is that Clojure uses a single pass compiler. For this reason, the functions must be declared before they are used. In a case when we need to refer to a function before it's been declared, we must use the <code>declare</code> macro in order to provide a forward declaration.</p> <div class="language- extra-class"><pre><code>(declare down)

(defn up [n]
  (if (&lt; n 10)
    (down (+ 2 n)) n))

(defn down [n]
  (up (dec n)))
</code></pre></div><p>A keen reader will have noticed that the code is structured as a tree. This tree is called the abstract syntax tree, or AST for short. By being able to see the AST directly, we can examine the relationships between pieces of logic visually.</p> <p>Since we write our code in terms of data, there are fewer syntactic hints than in most languages. For example, there is no explicit return statement and the last expression of the function body is returned implicitly.</p> <p>This might take a little getting used to if you're accustomed to seeing a lot of annotations in your code. To aid readability, functions are often kept short while indentation and spacing are used for grouping code visually.</p> <p>In Clojure, there is no distinction between functions and variables. You can assign a function to a label, pass it as a parameter, or return a function from another function. Functions that can be treated as data are referred to as being first-class because they don't have any additional restrictions attached to them.</p> <h3 id="higher-order-functions"><a href="#higher-order-functions" class="header-anchor">#</a> Higher-Order Functions</h3> <p>Functions that take other functions as parameters are called higher-order functions. One example of such a function is <code>map</code>:</p> <div class="language- extra-class"><pre><code>(map #(* % %) [1 2 3 4 5]) =&gt; (1 4 9 16 25)
</code></pre></div><p>This function accepts two parameters where the first is an anonymous function that squares its argument and the second is a collection of numbers. The map function will visit each item in the collection and square it.</p> <p>One major advantage of using a higher order function is that we can infer the intent of the code from the function being used. Let's contrast the above example to an imperative style loop:</p> <div class="language- extra-class"><pre><code>(loop [[n &amp; numbers] [1 2 3 4 5]
       result []]
  (let [result (conj result (* n n))]
    (if numbers
      (recur numbers result)
      result)))
</code></pre></div><p>The looping approach ends up having a lot more noise and thus we have to read through the code more carefully to tell what it's doing. The other problem is that the code becomes monolithic and no part of it can be used individually.</p> <p>Another example of a higher-order function is <code>filter</code>. This function goes through a collection and keeps only the items matching the specified predicate.</p> <div class="language- extra-class"><pre><code>(filter even? [1 2 3 4 5]) =&gt; (2 4)
</code></pre></div><p>Higher order functions can be easily chained together to create complex transformations:</p> <div class="language- extra-class"><pre><code>(filter even?
  (map #(* 3 %) [1 2 3 4 5]))

=&gt;(6 12)
</code></pre></div><p>Here we multiply each item by 3, then we use <code>filter</code> to only keep the even items from the resulting sequence. Having higher-order functions means that you should rarely have to write loops or explicit recursion. When iterating a collection, use a function such as <code>map</code> or <code>filter</code> instead. Since Clojure has a rich standard library, practically any data transformation can be easily achieved by combining functions found there. See <a href="https://github.com/mythz/clojure-linq-examples" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for some examples of this approach in action.</p> <p>Once you learn to associate data transformations with specific functions, many problems can be solved by simply putting these functions together in a specific order.</p> <p>Let's take a look at using this idea for a simple real world problem. We'd like to display a formatted address given the fields representing it. Commonly an address has a unit number, a street, a city, a postal code, and a country. We'll have to examine each of these fields, remove the <code>nil</code> and empty ones, and insert a separator between them. Given a table containing the following fields:</p> <div class="language- extra-class"><pre><code>unit      | street          | city      | postal_code | country
&quot;&quot;        | &quot;1 Main street&quot; | &quot;Toronto&quot; | nil         | &quot;Canada&quot;
</code></pre></div><p>We would like to output the following formatted string using the strings in the table:</p> <div class="language- extra-class"><pre><code>&quot;1 Main street, Toronto, Canada&quot;
</code></pre></div><p>All we have to do is find the functions for the tasks of removing empty fields, interposing the separator, and concatenating the result into a string:</p> <div class="language- extra-class"><pre><code>(defn concat-fields [&amp; fields]
  (clojure.string/join &quot;, &quot; (remove empty? fields)))

(concat-fields &quot;&quot; &quot;1 Main street&quot; &quot;Toronto&quot; nil &quot;Canada&quot;)
=&gt; &quot;1 Main street, Toronto, Canada&quot;
</code></pre></div><p>Notice that we didn't have to specify how to do any of the tasks when writing our code. Most of the time we simply say what we're doing by composing the functions representing the operations we wish to carry out. The resulting code also handles all the common edge cases:</p> <div class="language- extra-class"><pre><code>(concat-fields) =&gt; &quot;&quot;
(concat-fields nil) =&gt; &quot;&quot;
(concat-fields &quot;&quot;) =&gt; &quot;&quot;
</code></pre></div><p>In Clojure, it's common for the code to work correctly for all inputs out of the box.</p> <h3 id="closures"><a href="#closures" class="header-anchor">#</a> Closures</h3> <p>We've now seen how we can declare functions, name them, and pass them as parameters to other functions. One last thing we can do is write functions that return other functions as their result. One use for such functions is to provide the functionality facilitated by constructors in object-oriented languages.</p> <p>Let's say we wish to greet our guests with a warm greeting. We can write a function that will accept the greeting string as its parameter and return a function that takes the name of the guest and prints a customized greeting for that guest:</p> <div class="language- extra-class"><pre><code>(defn greeting [greeting-string]
  (fn [guest]
    (println greeting-string guest)))

(let [greet (greeting &quot;Welcome to the wonderful world of Clojure&quot;)]
  (greet &quot;Jane&quot;)
  (greet &quot;John&quot;))
</code></pre></div><p>The inner function in the <code>greeting</code> has access to the <code>greeting-string</code> value since the value is defined in its outer scope. The <code>greeting</code> function is called a closure because it closes over its parameters, in our case the <code>greeting-string</code>, and makes them available to the function that it returns.</p> <p>You'll also notice that we're using a form called <code>let</code> to bind the <code>greet</code> symbol and make it available to any expressions inside it. The <code>let</code> form serves the same purpose as declaring variables in imperative languages.</p> <h3 id="threading-expressions"><a href="#threading-expressions" class="header-anchor">#</a> Threading Expressions</h3> <p>By this point you're probably noticing that nested expressions can get difficult to read. Fortunately, Clojure provides a couple of helper forms to deal with this problem. Let's say we have a range of numbers, and we want to increment each number, interpose the number 5 between them, then sum the result. We could write the following code to do that:</p> <div class="language- extra-class"><pre><code>(reduce + (interpose 5 (map inc (range 10))))
</code></pre></div><p>It's a little difficult to tell what's happening above at a glance. With a few more steps in the chain we'd be really lost. On top of that, if we wanted to rearrange any of the steps, such as interposing 5 before incrementing, then we'd have to renest all our expressions. An alternative way to write the above expression is to use the <code>-&gt;&gt;</code> form:</p> <div class="language- extra-class"><pre><code>(-&gt;&gt; (range 10) (map inc) (interpose 5) (reduce +))
</code></pre></div><p>Here, we use <code>-&gt;&gt;</code> to thread the operations from one to the next. This means that we implicitly pass the result of each expression as the last argument of the next expression. To pass it as the first argument we'd use the <code>-&gt;</code> form instead.</p> <h3 id="laziness"><a href="#laziness" class="header-anchor">#</a> Laziness</h3> <p>Many Clojure algorithms use lazy evaluation where the operations aren't performed unless their result actually needs to be evaluated. Laziness is crucial for making many algorithms work efficiently. For example, you might think the preceding example is very inefficient since we have to iterate our sequence each time to create the range, map across it, interpose the numbers, and reduce the result.</p> <p>However, this is not actually the case. The evaluation of each expression happens on demand. The first value in the range is generated and passed to the rest of the functions, then the next, and so on, until the sequence is exhausted. This is a similar approach that languages like Python take with their iterator mechanics.</p> <h2 id="code-structure"><a href="#code-structure" class="header-anchor">#</a> Code Structure</h2> <p>One nontrivial difference between Clojure and imperative languages is the way the code is structured. In imperative style, it's a common pattern to declare a shared mutable variable and modify it by passing it different functions. Each time we access the memory location we see the result of the code that previously worked with it. For example, if we have a list of integers and we wish to square each one then print the even ones, the following Python code would be perfectly valid:</p> <div class="language- extra-class"><pre><code>l = range(1, 6)

for i, val in enumerate(l) :
  l[i] = val * val

for i in l :
  if i % 2 == 0 :
    print i
</code></pre></div><p>In Clojure this interaction has to be made explicit. Instead of creating a shared memory location and then having different functions access it sequentially, we chain functions together and pipe the input through them:</p> <div class="language- extra-class"><pre><code>(println
  (filter #(= (mod % 2) 0)
    (map #(* % %) (range 1 6))))
</code></pre></div><p>We could also flatten out the steps using the <code>-&gt;&gt;</code> macro introduced earlier:</p> <div class="language- extra-class"><pre><code>(-&gt;&gt; (range 1 6)
     (map #(* % %))
     (filter #(= (mod % 2) 0))
     (println))
</code></pre></div><p>Each function returns a new value instead of modifying the existing data in place. You might think that this can get very expensive, and it would be with a naïve implementation where the entirety of the data is copied with every change.</p> <p>In reality, Clojure is backed by persistent data structures that create in-memory revisions of the data. Each time a change is made a new revision is created proportional to the size of the change. With this approach we only pay the price of the difference between the old and the new structures while ensuring that any changes are localized.</p> <h3 id="destructuring"><a href="#destructuring" class="header-anchor">#</a> Destructuring</h3> <p>Clojure has a powerful mechanism called destructuring for declaratively accessing values in data structures. This technique provides easy access to the data and serves to document the parameters to a function. Let's look at some examples to see how it works.</p> <div class="language- extra-class"><pre><code>(let [[smaller bigger] (split-with #(&lt; % 5) (range 10))]
    (println smaller bigger))

=&gt;(0 1 2 3 4) (5 6 7 8 9)
</code></pre></div><p>Above, we use <code>split-with</code> function to split a range of ten numbers into a sequence containing two elements: numbers less than 5 and numbers greater than or equal to 5. Since we know the format of the result, we can write it in a literal form as <code>[smaller bigger]</code> in the <code>let</code> binding. Destructuring is not limited to the <code>let</code> form and works for all types of bindings such as function arguments.</p> <p>Let's look at another function called <code>print-user</code> that accepts a vector with three elements and binds them to <code>name</code>, <code>address</code>, and <code>phone</code>, respectively:</p> <div class="language- extra-class"><pre><code>(defn print-user [[name address phone]]
  (println name &quot;-&quot; address phone))

(print-user [&quot;John&quot; &quot;397 King street, Toronto&quot; &quot;416-936-3218&quot;])
=&gt; &quot;John - 397 King street, Toronto 416-936-3218&quot;
</code></pre></div><p>We can also specify variable arguments as a sequence. This is done by using <code>&amp;</code> followed by the name of the list containing the remaining arguments:</p> <div class="language- extra-class"><pre><code>(defn print-args [&amp; args]
  (println args))

(print-args &quot;a&quot; &quot;b&quot; &quot;c&quot;) =&gt; (a b c)
</code></pre></div><p>Since the variable arguments are stored in a sequence, it can be destructured like any other:</p> <div class="language- extra-class"><pre><code>(defn print-args [arg1 &amp; [arg2]]
  (println
    (if arg2
      &quot;got two arguments&quot;
      &quot;got one argument&quot;)))

(print-args &quot;bar&quot;)
=&gt;&quot;got one argument&quot;

(print-args &quot;bar&quot; &quot;baz&quot;)
=&gt;&quot;got two arguments&quot;
</code></pre></div><p>Destructuring can also be applied to maps. When destructuring a map, we create a new map where we supply the names for the local bindings pointing to the keys from the original map:</p> <div class="language- extra-class"><pre><code>(let [{foo :foo bar :bar} {:foo &quot;foo&quot; :bar &quot;bar&quot;}]
  (println foo bar))
</code></pre></div><p>It's also possible to destructure a nested data structure. As long as you know the structure of the data being passed in, you can simply write it out:</p> <div class="language- extra-class"><pre><code>(let [{[a b c] :items id :id} {:id &quot;foo&quot; :items [1 2 3]}]
  (println id &quot;-&gt;&quot; a b c))
=&gt; &quot;foo -&gt; 1 2 3&quot;
</code></pre></div><p>Finally, since extracting keys from maps is a very common operation, Clojure provides syntactic sugar for this task:</p> <div class="language- extra-class"><pre><code>(defn login [{:keys [user pass]}]
 (and (= user &quot;bob&quot;) (= pass &quot;secret&quot;)))

(login {:user &quot;bob&quot; :pass &quot;secret&quot;})
</code></pre></div><p>Another useful destructuring option allows us to extract some keys while preserving the original map:</p> <div class="language- extra-class"><pre><code>(defn register [{:keys [id pass repeat-pass] :as user}]
  (cond
    (nil? id) &quot;user id is required&quot;
    (not= pass repeat-pass) &quot;re-entered password doesn't match&quot;
    :else user))
</code></pre></div><h3 id="namespaces"><a href="#namespaces" class="header-anchor">#</a> Namespaces</h3> <p>When writing real-world applications we need tools to organize our code into separate components. Object-oriented languages provide classes for this purpose. The related methods will all be defined in the same class. In Clojure, we group our functions into namespaces instead. Let's look at how a namespace is defined.</p> <div class="language- extra-class"><pre><code>(ns colors)

(defn hex-&gt;rgb [[_ &amp; rgb]]
    (map #(-&gt;&gt; % (apply str &quot;0x&quot;) (Long/decode))
         (partition 2 rgb)))

(defn hex-str [n]
  (-&gt; (format &quot;%2s&quot; (Integer/toString n 16))
      (clojure.string/replace &quot; &quot; &quot;0&quot;)))

(defn rgb-&gt;hex [color]
  (apply str &quot;#&quot; (map hex-str color)))
</code></pre></div><p>Above, we have a namespace called <code>colors</code> containing three functions called <code>hex-&gt;rgb</code>, <code>hex-str</code>, and <code>rgb-&gt;hex</code>. The functions in the same namespace can call each other directly. However, if we wanted to call these functions from a different namespace we would have to reference the <code>colors</code> namespace there first.</p> <p>Clojure provides two ways to do this, we can either use the <code>:use</code> or the <code>:require</code> keywords. When we reference a namespace with <code>:use</code>, all its Vars become implicitly available as if they were defined in the namespace that references it.</p> <div class="language- extra-class"><pre><code>(ns myns
  (:use colors))

(hex-&gt;rgb &quot;#33d24f&quot;)
</code></pre></div><p>There are two downsides to this approach. We don't know where the function was originally defined, making it difficult to navigate the code, and if we reference two namespaces that use the same name for a function, we'll get an error.</p> <p>We can address the first problem by selecting the functions we wish to use explicitly using the <code>:only</code> keyword in our <code>:use</code> declaration.</p> <div class="language- extra-class"><pre><code>(ns myns
  (:use [colors :only [rgb-&gt;hex]]))

(defn hex-str [c]
  (println &quot;I don't do much yet&quot;))
</code></pre></div><p>This way we document where <code>rgb-&gt;hex</code> comes from, and we're able to declare our own <code>hex-str</code> function in the <code>myns</code> namespace without conflicts. Note that <code>rgb-&gt;hex</code> will still use the <code>hex-str</code> function defined in the <code>colors</code> namespace.</p> <p>The approach of using the <code>:require</code> keyword to reference the namespace provides us with more flexible options. Let's look at each of these.</p> <p>We can require a namespace without providing any further directives. In this case, any calls to Vars inside it must be prefixed with the namespace declaration indicating their origin.</p> <div class="language- extra-class"><pre><code>(ns myns (:require colors))

(colors/hex-&gt;rgb &quot;#324a9b&quot;)
</code></pre></div><p>This approach is explicit about the origin of the Vars being referenced and ensures that we won't have conflicts when referencing multiple namespaces. One problem is that when our namespace declaration is long, it gets tedious to have to type it out any time we wish to use a function declared inside it. To address this problem, the <code>:require</code> statement provides the <code>:as</code> directive, allowing us to create an alias for the namespace.</p> <div class="language- extra-class"><pre><code>(ns myotherns
  (:require [colors :as c]))

(c/hex-&gt;rgb &quot;#324a9b&quot;)
</code></pre></div><p>We can also require functions from a namespace by using the <code>:refer</code> keyword. This is synonymous with the <code>:use</code> notation we saw earlier. To require all the functions from another namespace, we can write the following:</p> <div class="language- extra-class"><pre><code>(ns myns
  (:require [colors :refer :all]))
</code></pre></div><p>If we wish to select what functions to require by name, we can instead write:</p> <div class="language- extra-class"><pre><code>(ns myns
  (:require [colors :refer [rgb-&gt;hex]))
</code></pre></div><p>As you can see, there's a number of options available for referencing Vars declared in other namespaces. If you're not sure what option to pick, then requiring the namespace by name or alias is the safest route.</p> <h3 id="dynamic-variables"><a href="#dynamic-variables" class="header-anchor">#</a> Dynamic Variables</h3> <p>Clojure provides support for declaring dynamic variables that can have their value changed within a particular scope. Let's look at how this works.</p> <div class="language- extra-class"><pre><code>(declare ^{:dynamic true} *foo*)

(println *foo*)
=&gt;#&lt;Unbound Unbound: #'bar/*foo*&gt;
</code></pre></div><p>Here we declared <code>*foo*</code> as a dynamic Var and didn't provide any value for it. When we try to print <code>*foo*</code> we get an error indicating that this Var has not been bound to any value. Let's look at how we can assign a value to <code>*foo*</code> using a binding.</p> <div class="language- extra-class"><pre><code>(defn with-foo [f]
  (binding [*foo* &quot;I exist!&quot;]
    (f)))

(with-foo #(println *foo*)) =&gt;&quot;I exist!&quot;
</code></pre></div><p>We set <code>*foo*</code> to a string with value &quot;I exist!&quot; inside the <code>with-foo</code> function. When our anonymous function is called inside with-foo we no longer get an error when trying to print its value.</p> <p>This technique can be useful when dealing with resources such as file streams, database connections, or scoped variables. In general, the use of dynamic variables is discouraged since they make code more opaque and difficult to reason about. However, there are legitimate uses for them, and it's worth knowing how they work.</p> <h2 id="polymorphism"><a href="#polymorphism" class="header-anchor">#</a> Polymorphism</h2> <p>One useful aspect of object-orientation is polymorphism, while it happens to be associated with that style it's in no way exclusive to it. Clojure provides two common ways to achieve runtime polymorphism. Let's look at each of these in turn.</p> <h3 id="multimethods"><a href="#multimethods" class="header-anchor">#</a> Multimethods</h3> <p>Multimethods provide an extremely flexible dispatching mechanism using a selector function associated with one or more methods. The multimethod is defined using <code>defmulti</code> and its methods are each defined using <code>defmethod</code>. For example, if we had different shapes and we wanted to write a multimethod to calculate the area we could do the following:</p> <div class="language- extra-class"><pre><code>(defmulti area :shape)

(defmethod area :circle [{:keys [r]}]
  (* Math/PI r r))

(defmethod area :rectangle [{:keys [l w]}]
  (* l w))

(defmethod area :default [shape]
  (throw (Exception. (str &quot;unrecognized shape: &quot; shape))))

(area {:shape :circle :r 10})
=&gt; 314.1592653589793

(area {:shape :rectangle :l 5 :w 10})
=&gt; 50
</code></pre></div><p>Above, the dispatch function uses a keyword to select the appropriate method to handle each type of map. This works because keywords act as functions and when passed a map will return the value associated with them. The dispatch function can be as sophisticated as we like however:</p> <div class="language- extra-class"><pre><code>(defmulti encounter
  (fn [x y] [(:role x) (:role y)]))

(defmethod encounter [:manager :boss] [x y]
  :promise-unrealistic-deadlines)

(defmethod encounter [:manager :developer] [x y]
  :demand-overtime)

(defmethod encounter [:developer :developer] [x y]
  :complain-about-poor-management)

(encounter {:role :manager} {:role :boss})
=&gt; :promise-unrealistic-deadlines
</code></pre></div><h3 id="protocols"><a href="#protocols" class="header-anchor">#</a> Protocols</h3> <p>Protocols allow defining an abstract set of functions that can be implemented by a concrete type. Let's look at an example protocol:</p> <div class="language- extra-class"><pre><code>(defprotocol Foo
  &quot;Foo doc string&quot;
  (bar [this b] &quot;bar doc string&quot;)
  (baz [this] [this b] &quot;baz doc string&quot;))
</code></pre></div><p>As you can see, the <code>Foo</code> protocol specifies two methods, <code>bar</code> and <code>baz</code>. The first argument to the method will be the type instance followed by its parameters. Note that the <code>baz</code> method has multiple arity. We can now create a type that implements the Foo protocol using the deftype macro:</p> <div class="language- extra-class"><pre><code>(deftype Bar [data] Foo
  (bar [this param]
    (println data param))
  (baz [this]
    (println (class this)))
  (baz [this param]
    (println param)))
</code></pre></div><p>Here we create type <code>Bar</code> that implements protocol <code>Foo</code>. Each of its methods will print out some of the parameters passed to it. Let's see what it looks like when we create an instance of <code>Bar</code> and call its methods:</p> <div class="language- extra-class"><pre><code>(let [b (Bar. &quot;some data&quot;)]
  (.bar b &quot;param&quot;)
  (.baz b)
  (.baz b &quot;baz with param&quot;))


some data param
Bar
baz with param
</code></pre></div><p>The first method call prints out the data <code>Bar</code> was initialized with and the parameter that was passed in. The second method call prints out the object's class, while the last method call demonstrates the other arity of baz.</p> <p>We can also use protocols to extend the functionality of existing types, including existing Java classes. For example, we can use extend-protocol to extend the <code>java.lang.String</code> class with the <code>Foo</code> protocol:</p> <div class="language- extra-class"><pre><code>(extend-protocol Foo String
  (bar [this param] (println this param)))

(bar &quot;hello&quot; &quot;world&quot;)
=&gt;&quot;hello world&quot;
</code></pre></div><p>The above examples illustrate the basic principles of how protocols can be used to write polymorphic code. However, there are many other uses for protocols as well and I encourage you to discover these on your own.</p> <h2 id="dealing-with-global-state"><a href="#dealing-with-global-state" class="header-anchor">#</a> Dealing With Global State</h2> <p>While predominantly immutable, Clojure provides support for shared mutable data via its STM functions in the standard library. The STM is used to ensure that all updates to shared mutable variables are done atomically.</p> <p>There are two primary mutable types: the <code>atom</code> and the <code>ref</code>. The <code>atom</code> is used in cases where we need to do uncoordinated updates and the <code>ref</code> is used when we might need to do multiple updates as a transaction. Let's look at an example of defining an <code>atom</code> and using it.</p> <div class="language- extra-class"><pre><code>(def global-val (atom nil))
</code></pre></div><p>Above, we created an <code>atom</code> called <code>global-val</code> and its current value is <code>nil</code>. We can now read its value by using the <code>deref</code> function, which returns the current value.</p> <div class="language- extra-class"><pre><code>(println (deref global-val)) =&gt; nil
</code></pre></div><p>Since this is a common operation, there is a shorthand for <code>deref</code>: the <code>@</code> symbol:</p> <div class="language- extra-class"><pre><code>(println @global-val)
</code></pre></div><p>The above code is equivalent to the preceding example.</p> <p>Let's look at two ways of setting a new value for our <code>atom</code>. We can either use <code>reset!</code> and pass in the new value, or we can use <code>swap!</code> and pass in a function that will be used to update the current value.</p> <div class="language- extra-class"><pre><code>(reset! global-val 10) (println @global-val) =&gt;10

(swap! global-val inc) (println @global-val) =&gt;11
</code></pre></div><p>￼￼ Note that both <code>swap!</code> and <code>reset!</code> end in an exclamation point <code>!</code>; this is a convention to indicate that these functions modify mutable data.</p> <p>We define refs the same way we define atoms, but the two are used rather differently. Let's take a quick look at how they work below.</p> <div class="language- extra-class"><pre><code>(def names (ref []))

(dosync
  (ref-set names [&quot;John&quot;])
  (alter names #(if (not-empty %)
                  (conj % &quot;Jane&quot;) %)))
</code></pre></div><p>In this code, we define a <code>ref</code> called <code>names</code>, then open a transaction using the <code>dosync</code> statement. Inside the transaction we set <code>names</code> to a vector with the value <code>&quot;John&quot;</code>. Next, we call <code>alter</code> to check if <code>names</code> is not empty and add <code>&quot;Jane&quot;</code> to the vector of the names if that's the case.</p> <p>Note that since this is happening inside a transaction, the check for emptiness depends on the existing state along with any state built up within the same transaction. If we tried to add or remove a name in a different transaction, it would have no visible effect on ours. In case of a collision, one of the transactions would end up being retried.</p> <h2 id="writing-code-that-writes-code"><a href="#writing-code-that-writes-code" class="header-anchor">#</a> Writing Code That Writes Code</h2> <p>Clojure, being a Lisp, provides a powerful macro system. Macros allow templating repetitive blocks of code and deferring evaluation, among numerous other uses. A macro works by treating code as data instead of evaluating it. This allows us to manipulate the code tree just like any other data structure.</p> <p>Macros execute before evaluation time and the evaluator sees the result of macro execution. Because of this level of indirection, macros can be difficult to reason about, and thus it's best not to use them when a function will do the job.</p> <p>Let's look at a concrete example of a macro and see how it differs from the regular code we saw previously. Imagine that we have a web application with a session atom that might contain a user. We might want to load certain content only if a user is present in the session and not otherwise.</p> <div class="language- extra-class"><pre><code>(def session (atom {:user &quot;Bob&quot;}))

(defn load-content []
  (if (:user @session)
    &quot;Welcome back!&quot;
    &quot;please log in&quot;))
</code></pre></div><p>This will work, but it's tedious and error-prone to write out the <code>if</code> statement every single time. Since our condition's logic stays the same, we can template this function as follows:</p> <div class="language- extra-class"><pre><code>(defmacro defprivate [name args &amp; body]
  `(defn ~(symbol name) ~args
     (if (:user @session)
       (do ~@body)
       &quot;please log in&quot;)))
</code></pre></div><p>The macros are defined using the <code>defmacro</code> special form. The major difference between <code>defn</code> and <code>defmacro</code> is that the parameters passed to <code>defmacro</code> are not evaluated by default.</p> <p>To evaluate the parameter we use the <code>~</code>, as we're doing with <code>~(symbol name)</code>. Using the <code>~</code> notation indicates that we'd like to replace the name with the value it refers to. This is called unquoting.</p> <p>The <code>~@</code> notation used in <code>(do ~@body)</code> is called unquote splicing. This notation is used when we're dealing with a sequence. The contents of the sequence will be merged into the outer form during the splicing. In this case the body consists of a list representing the function's body. The body must be wrapped in a <code>do</code> block because the <code>if</code> statement requires having no more than three arguments.</p> <p>The <code>`</code> sign means that we wish to treat the following list as data instead of executing it. This is the opposite of unquoting, and it's referred to as syntax-quoting.</p> <p>As I mentioned earlier, the macros are executed before evaluation time. To see what the macro will be rewritten as when the evaluator sees it, we can call <code>macroexpand-1</code>.</p> <div class="language- extra-class"><pre><code>(macroexpand-1 '(defprivate foo [greeting] (println greeting)))

(clojure.core/defn foo [greeting]
  (if (:user (clojure.core/deref session))
    (do (println greeting))
    &quot;please log in&quot;))
</code></pre></div><p>We can see that <code>(defprivate foo (println &quot;bar&quot;))</code> gets rewritten with a function definition that has the <code>if</code> statement inside. This resulting code is what the evaluator will see, and it's equivalent to what we would have to write by hand otherwise. Now we can simply define a private function using our macro, and it will do the check for us automatically.</p> <div class="language- extra-class"><pre><code>(defprivate foo [message] (println message))

(foo &quot;this message is private&quot;)
</code></pre></div><p>The preceding example might seem a little contrived, but it demonstrates the power of being able to easily template repetitions in code. This allows creating a notation that expresses your problem domain using the language that is natural to it.</p> <h2 id="the-read-evaluate-print-loop"><a href="#the-read-evaluate-print-loop" class="header-anchor">#</a> The Read-Evaluate-Print Loop</h2> <p>Another big aspect of working in Clojure is the read-evaluate-print loop (REPL). In many languages you write the code, then run the entire program to see what it does. In Clojure, most development is done interactively using the REPL. In this mode we can see each piece of code we write in action as soon as it's written.</p> <p>In nontrivial applications it's often necessary to build up a particular state before you can add more functionality. For example, a user has to log in and query some data from the database, then you need to write functions to format and display this data. With a REPL you can get the application to the state where the data is loaded and then write the display logic interactively without having to reload the application and build up the state every time you make a change.</p> <p>This method of development is particularly satisfying because you see immediate feedback when making changes. You can easily try things out and see what approach works best for the problem you're solving. This encourages experimentation and refactoring code as you go, which in turn helps you to write better and cleaner code.</p> <h2 id="calling-out-to-java"><a href="#calling-out-to-java" class="header-anchor">#</a> Calling Out to Java</h2> <p>One last thing that we'll cover is how Clojure embraces its host platform to benefit from the rich ecosystem of existing Java libraries. In some cases we may wish to call a Java library to accomplish a particular task that doesn't have a native Clojure implementation. Calling Java classes is very simple, and follows the standard Clojure syntax fairly closely.</p> <h3 id="importing-classes"><a href="#importing-classes" class="header-anchor">#</a> Importing Classes</h3> <p>When we wish to use a Clojure namespace, we employ either the <code>:use</code> or the <code>:require</code> statements discussed above. However, when we wish to import a Java class, we have to use the <code>:import</code> statement instead:</p> <div class="language- extra-class"><pre><code>(ns myns
  (:import java.io.File))
</code></pre></div><p>We can also group multiple classes from the same package in a single import, as follows:</p> <div class="language- extra-class"><pre><code>(ns myns
  (:import [java.io File FileInputStream FileOutputStream]))
</code></pre></div><h3 id="instantiating-classes"><a href="#instantiating-classes" class="header-anchor">#</a> Instantiating Classes</h3> <p>To create an instance of a class, we can call new just as we would in Java:</p> <div class="language- extra-class"><pre><code>(new File &quot;.&quot;)
</code></pre></div><p>There is also a commonly used shorthand for instantiating objects:</p> <div class="language- extra-class"><pre><code>(File. &quot;.&quot;)
</code></pre></div><h3 id="calling-methods"><a href="#calling-methods" class="header-anchor">#</a> Calling Methods</h3> <p>Once we have an instance of a class, we can start calling methods on it. The notation is similar to making a regular function call. When we call a method, we pass the object as its first parameter followed by any other parameters that the method accepts.</p> <div class="language- extra-class"><pre><code>(let [f (File. &quot;.&quot;)]
  (println (.getAbsolutePath f)))
</code></pre></div><p>Above, we created a new file object <code>f</code>, and then called the <code>.getAbsolutePath</code> method on it. Notice that methods have a period <code>.</code> in front of them to differentiate them from a regular Clojure function. If we wanted to reference a static method or a variable in a class, we would use the <code>/</code> notation instead:</p> <div class="language- extra-class"><pre><code>(str File/separator &quot;foo&quot; File/separator &quot;bar&quot;)

(Math/sqrt 256)
</code></pre></div><p>There's also a shorthand for chaining multiple method calls together using the <code>..</code> notation. Say we wanted to get the string indicating the file path and then get its bytes; we could write the code for that in two ways.</p> <div class="language- extra-class"><pre><code>(.getBytes (.getAbsolutePath (File. &quot;.&quot;)))

(.. (File. &quot;.&quot;) getAbsolutePath getBytes)
</code></pre></div><h2 id="further-reading"><a href="#further-reading" class="header-anchor">#</a> Further Reading</h2> <p>This concludes our tour of Clojure basics. While we only touched on only a small portion of the overall language, I hope that the guide has provided you with a bit of insight into how idiomatic Clojure code is written. Below are some useful links for more in-depth documentation about the language.</p> <ul><li><a href="http://clojure.org/guides/getting_started" target="_blank" rel="noopener noreferrer">Official Clojure documentation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.braveclojure.com/" target="_blank" rel="noopener noreferrer">Clojure for the Brave and True<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://aphyr.com/posts/301-clojure-from-the-ground-up-welcome" target="_blank" rel="noopener noreferrer">Clojure from the ground up<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://clojure-doc.org/" target="_blank" rel="noopener noreferrer">Community Clojure documentation site<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://grimoire.arrdem.com/" target="_blank" rel="noopener noreferrer">Clojure API documentation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://clojure.org/cheatsheet" target="_blank" rel="noopener noreferrer">Clojure cheatsheet<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/bbatsov/clojure-style-guide" target="_blank" rel="noopener noreferrer">Clojure style guide<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>Copyright © 2023 Dmitri Sotnikov</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8eead098.js" defer></script><script src="/assets/js/6.5cfa5282.js" defer></script><script src="/assets/js/28.616b8c2f.js" defer></script>
  </body>
</html>
