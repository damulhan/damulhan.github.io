<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>주문을 걸기 (Casting SPELs) | 프로그래밍 인 액션</title>
    <meta name="generator" content="VuePress 1.9.9">
    <script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-FZZE483ETN"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
      
        gtag('config', 'G-FZZE483ETN');      
    </script>
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.a471a02c.css" as="style"><link rel="preload" href="/assets/js/app.8eead098.js" as="script"><link rel="preload" href="/assets/js/6.5cfa5282.js" as="script"><link rel="preload" href="/assets/js/18.385998a5.js" as="script"><link rel="prefetch" href="/assets/js/10.1bc3d943.js"><link rel="prefetch" href="/assets/js/11.18aecc2e.js"><link rel="prefetch" href="/assets/js/12.0f6995fb.js"><link rel="prefetch" href="/assets/js/13.d1e47c85.js"><link rel="prefetch" href="/assets/js/14.04c1e3cd.js"><link rel="prefetch" href="/assets/js/15.7634eb2e.js"><link rel="prefetch" href="/assets/js/16.e7b5b12f.js"><link rel="prefetch" href="/assets/js/17.077b7aff.js"><link rel="prefetch" href="/assets/js/19.edc92b47.js"><link rel="prefetch" href="/assets/js/2.540d1b33.js"><link rel="prefetch" href="/assets/js/20.c0794e87.js"><link rel="prefetch" href="/assets/js/21.c9e3ea69.js"><link rel="prefetch" href="/assets/js/22.5b54f678.js"><link rel="prefetch" href="/assets/js/23.07f6101e.js"><link rel="prefetch" href="/assets/js/24.3178700c.js"><link rel="prefetch" href="/assets/js/25.5466da51.js"><link rel="prefetch" href="/assets/js/26.d16ec0e0.js"><link rel="prefetch" href="/assets/js/27.60cbad3d.js"><link rel="prefetch" href="/assets/js/28.616b8c2f.js"><link rel="prefetch" href="/assets/js/29.60eb2bb9.js"><link rel="prefetch" href="/assets/js/3.6a339483.js"><link rel="prefetch" href="/assets/js/30.926affe7.js"><link rel="prefetch" href="/assets/js/31.34de4dba.js"><link rel="prefetch" href="/assets/js/32.335f6f04.js"><link rel="prefetch" href="/assets/js/33.8fca5103.js"><link rel="prefetch" href="/assets/js/34.f2d20cdc.js"><link rel="prefetch" href="/assets/js/35.09b256f0.js"><link rel="prefetch" href="/assets/js/36.b13d6b9b.js"><link rel="prefetch" href="/assets/js/37.a1fb05ef.js"><link rel="prefetch" href="/assets/js/38.9d11e83f.js"><link rel="prefetch" href="/assets/js/39.577feb17.js"><link rel="prefetch" href="/assets/js/4.dc20e8a4.js"><link rel="prefetch" href="/assets/js/40.86023459.js"><link rel="prefetch" href="/assets/js/41.4d41e8d7.js"><link rel="prefetch" href="/assets/js/42.c4620975.js"><link rel="prefetch" href="/assets/js/43.9a1db1cd.js"><link rel="prefetch" href="/assets/js/44.bef60950.js"><link rel="prefetch" href="/assets/js/5.221d601f.js"><link rel="prefetch" href="/assets/js/7.5aa03c37.js"><link rel="prefetch" href="/assets/js/8.c5761a72.js"><link rel="prefetch" href="/assets/js/9.dba8f914.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a471a02c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">프로그래밍 인 액션</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/clojure/" class="nav-link router-link-active">
  Clojure
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/clojure/" class="nav-link router-link-active">
  Clojure
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>clojure books</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/clojure/clojure_distilled" class="sidebar-heading clickable"><span>Clojure 증류하기 (Clojure Distilled)</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/clojure/clojure_spells" class="sidebar-heading clickable router-link-active open"><span>Clojure로 주문읽기(casting spells in clojure)</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/clojure/clojure_spells/01-intro.html" class="sidebar-link">서문</a></li><li><a href="/clojure/clojure_spells/02-syntax_and_meaning.html" class="sidebar-link">문법과 의미</a></li><li><a href="/clojure/clojure_spells/03-defining_data_and_game_world.html" class="sidebar-link">우리의 게임세계를 위한 데이터 정의하기</a></li><li><a href="/clojure/clojure_spells/04-looking_around.html" class="sidebar-link">게임 세계 둘러보기</a></li><li><a href="/clojure/clojure_spells/05-waling_around.html" class="sidebar-link">세상 속 둘러보기</a></li><li><a href="/clojure/clojure_spells/06-casting_spells.html" aria-current="page" class="active sidebar-link">주문을 걸기</a></li><li><a href="/clojure/clojure_spells/07-creating_special_actions.html" class="sidebar-link">우리 게임에서 특별한 동작을 생성하기</a></li><li><a href="/clojure/clojure_spells/08-addendum.html" class="sidebar-link">부록</a></li><li><a href="/clojure/clojure_spells/09-the_cast_against_the_word_macro.html" class="sidebar-link">&quot;매크로&quot;라는 단어에 대한 사례</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>columns &amp; lectures</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="주문을-걸기-casting-spels"><a href="#주문을-걸기-casting-spels" class="header-anchor">#</a> 주문을 걸기 (Casting SPELs)</h1> <p>Now we're going to learn an incredibly powerful feature of Lisp: Creating SPELs!</p> <p>이제 Lisp의 놀랍도록 강력한 기능을 배워보겠습니다. 바로 스펠 만들기입니다!</p> <p>SPEL is short for &quot;Semantic Program Enhancement Logic&quot; and lets us create new behavior inside the world of our computer code that changes the Lisp language at a fundamental level in order to customize its behavior for our needs- It's the part of Lisp that looks most like magic. To enable SPELs, we first need to activate SPELs inside our Lisp compiler ( Don't worry about what this line does - Advanced Lispers should click <a href="http://www.lisperati.com/clojure-spels/no_macros.html" target="_blank" rel="noopener noreferrer">here.<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> )</p> <p>SPEL은 &quot;시맨틱 프로그램 향상 논리&quot;의 줄임말로, 컴퓨터 코드의 세계 내부에 새로운 동작을 생성하여 필요에 맞게 동작을 사용자 지정하기 위해 기본적인 수준에서 Lisp 언어를 변경할 수 있게 해 줍니다. SPEL을 활성화하려면 먼저 Lisp 컴파일러 내에서 SPEL을 활성화해야 합니다(이 줄의 기능에 대해 걱정하지 마세요. 고급 Lisp 사용자는 <a href="/clojure/clojure_spells/09-the_cast_against_the_word_macro.html">여기</a>를 클릭하세요.).</p> <div class="language-clojure extra-class"><pre class="language-clojure"><code><span class="token punctuation">(</span><span class="token keyword">defmacro</span> defspel <span class="token punctuation">[</span>&amp; rest<span class="token punctuation">]</span> <span class="token operator">`</span><span class="token punctuation">(</span><span class="token keyword">defmacro</span> <span class="token operator">~</span><span class="token operator">@</span>rest<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>Ok, now that they're enabled, let's cast our first spell, called <code>walk</code>:</p> <p>이제 기능이 활성화되었으니 첫 번째 주문인 '<code>walk</code>'를 사용해 보겠습니다:</p> <div class="language-clojure extra-class"><pre class="language-clojure"><code><span class="token punctuation">(</span><span class="token function">defspel</span> walk <span class="token punctuation">[</span>direction<span class="token punctuation">]</span> <span class="token operator">`</span><span class="token punctuation">(</span><span class="token function">walk-direction</span> '<span class="token operator">~</span>direction<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>What this code does is it tells the Lisp compiler that the word <code>walk</code> is not actually the word <code>walk</code> but the word <code>walk-direction</code> and that the word <code>direction</code> actually has a quote in front of it, even though we can't see it. Basically we can sneak in some special code inbetween our program and the compiler that changes our code into something else before it is compiled:</p> <p>이 코드가 하는 일은 걷는다는 단어가 실제로는 걷는다는 단어가 아니라 걷는 방향이라는 단어이며, 우리가 볼 수는 없지만 실제로는 방향이라는 단어 앞에 따옴표가 있다는 것을 Lisp 컴파일러에게 알려주는 것입니다. 기본적으로 프로그램과 컴파일러 사이에 코드를 컴파일하기 전에 코드를 다른 것으로 변경하는 특수 코드를 몰래 삽입할 수 있습니다.</p> <p><img src="/assets/img/spel_compile1.505bea7b.jpg" alt="Compiling a SPEL"></p> <p>Notice how similar this function looks to the code we had written before for describe-path: In Lisp, not only do code and data look a lot identical, but code and special commands to the compiler (the SPELs) look identical as well - A very consistent and clean design! Let's try our new spell:</p> <p>이 함수가 이전에 설명 경로에 대해 작성했던 코드와 얼마나 유사한지 주목하세요: Lisp에서는 코드와 데이터가 거의 동일하게 보일 뿐만 아니라 코드와 컴파일러에 대한 특수 명령(SPEL)도 동일하게 보입니다. 매우 일관되고 깔끔한 디자인입니다! 새로운 스펠을 사용해 봅시다:</p> <div class="language-clojure extra-class"><pre class="language-clojure"><code><span class="token punctuation">(</span><span class="token function">walk</span> east<span class="token punctuation">)</span>

user=&gt; <span class="token punctuation">(</span><span class="token function">walk</span> east<span class="token punctuation">)</span>                                             
<span class="token punctuation">(</span><span class="token function">you</span> are in the living room of a wizards house -
there is a wizard snoring loudly on the couch -
there is a door going west from here -
there is a stairway going upstairs from here -
you see a whiskey-bottle on the floor -
you see a bucket on the floor -<span class="token punctuation">)</span>
</code></pre></div><p>much better!</p> <p>훨씬 좋아보입니다!</p> <p>Now we'll create a command to pickup objects in our world:</p> <p>이제 월드에서 오브젝트를 픽업하는 명령을 만들어 보겠습니다.</p> <div class="language-clojure extra-class"><pre class="language-clojure"><code><span class="token punctuation">(</span><span class="token keyword">defn</span> pickup-object <span class="token punctuation">[</span>object<span class="token punctuation">]</span>  
  <span class="token punctuation">(</span><span class="token keyword">cond</span> <span class="token punctuation">(</span><span class="token function">is-at?</span> object location object-locations<span class="token punctuation">)</span>  
        <span class="token punctuation">(</span><span class="token keyword">do</span>  
          <span class="token punctuation">(</span><span class="token keyword">def</span> object-locations <span class="token punctuation">(</span><span class="token keyword">assoc</span> object-locations object 'body<span class="token punctuation">)</span><span class="token punctuation">)</span>  
          <span class="token operator">`</span><span class="token punctuation">(</span><span class="token function">you</span> are now carrying the <span class="token operator">~</span>object<span class="token punctuation">)</span><span class="token punctuation">)</span>  
        <span class="token symbol">:else</span> '<span class="token punctuation">(</span>you cannot get that.<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
</code></pre></div><p>This function checks to see if the object is indeed on the floor of the current location - If it is, it <em>pushes</em> the new location (the player's body) onto the list (<em>pushing</em> means to add a new item to the list, in a way that the <em>assoc</em> command sees and therefore hides the previous location) and returns a sentence letting us know wether it succeeded.</p> <p>이 함수는 오브젝트가 실제로 현재 위치의 바닥에 있는지 확인하고, 만약 그렇다면 새 위치(플레이어의 몸)를 목록에 밀어넣고(밀어넣는다는 것은 목록에 새 항목을 추가하는 것을 의미하며, assoc 명령이 이전 위치를 보고 숨기는 방식입니다) 성공 여부를 알려주는 문장을 반환합니다.</p> <p>Now let's cast another SPEL to make the command easier to use:</p> <p>이제 명령을 더 쉽게 사용할 수 있도록 다른 주문을 시전해 보겠습니다:</p> <div class="language-clojure extra-class"><pre class="language-clojure"><code><span class="token punctuation">(</span><span class="token function">defspel</span> pickup <span class="token punctuation">[</span>object<span class="token punctuation">]</span> <span class="token operator">`</span><span class="token punctuation">(</span><span class="token function">spel-print</span> <span class="token punctuation">(</span><span class="token function">pickup-object</span> '<span class="token operator">~</span>object<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>Now let's try our new SPEL:</p> <p>이제 새로운 스펠(SPEL)을 사용해 보겠습니다:</p> <div class="language-clojure extra-class"><pre class="language-clojure"><code><span class="token punctuation">(</span><span class="token function">pickup</span> whiskey-bottle<span class="token punctuation">)</span>

user=&gt; <span class="token punctuation">(</span><span class="token function">pickup</span> whiskey-bottle<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token function">you</span> are now carrying the whiskey-bottle<span class="token punctuation">)</span>
</code></pre></div><p>Now let's add a couple more useful commands - First, a command that lets us see our current inventory of items we're carrying:</p> <p>이제 몇 가지 유용한 명령을 추가해 보겠습니다. 먼저, 현재 가지고 있는 아이템의 인벤토리를 확인할 수 있는 명령입니다:</p> <div class="language-clojure extra-class"><pre class="language-clojure"><code><span class="token punctuation">(</span><span class="token keyword">defn</span> inventory <span class="token punctuation">[</span><span class="token punctuation">]</span>  
  <span class="token punctuation">(</span><span class="token keyword">filter</span> <span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">is-at?</span> x 'body object-locations<span class="token punctuation">)</span><span class="token punctuation">)</span> objects<span class="token punctuation">)</span><span class="token punctuation">)</span>  
</code></pre></div><p>Now a function that tells us if he have a certain object on us:</p> <p>이제 특정 물체를 가지고 있는지 알려주는 함수가 있습니다:</p> <div class="language-clojure extra-class"><pre class="language-clojure"><code><span class="token punctuation">(</span><span class="token keyword">defn</span> have? <span class="token punctuation">[</span>object<span class="token punctuation">]</span>  
   <span class="token punctuation">(</span><span class="token keyword">some</span> <span class="token operator">#</span><span class="token punctuation">{</span>object<span class="token punctuation">}</span> <span class="token punctuation">(</span><span class="token function">inventory</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/clojure/clojure_spells/05-waling_around.html" class="prev">
        세상 속 둘러보기
      </a></span> <span class="next"><a href="/clojure/clojure_spells/07-creating_special_actions.html">
        우리 게임에서 특별한 동작을 생성하기
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8eead098.js" defer></script><script src="/assets/js/6.5cfa5282.js" defer></script><script src="/assets/js/18.385998a5.js" defer></script>
  </body>
</html>
